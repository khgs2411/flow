#!/usr/bin/env bash

################################################################################
# Flow Framework Deployment Script
#
# Self-contained script with all framework content embedded.
# Distribute this single file to install the Flow framework.
#
# Version: 1.0.10
# Generated by build-standalone.sh
################################################################################

set -e

FLOW_VERSION="1.0.10"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

COMMANDS=(
  # Plan Initialization (3 commands)
  "flow-blueprint" "flow-migrate" "flow-plan-update"
  # Phase Lifecycle (3 commands)
  "flow-phase-add" "flow-phase-start" "flow-phase-complete"
  # Task Lifecycle (3 commands)
  "flow-task-add" "flow-task-start" "flow-task-complete"
  # Iteration Lifecycle (6 commands)
  "flow-iteration-add"
  "flow-brainstorm-start" "flow-brainstorm-subject" "flow-brainstorm-resolve" "flow-brainstorm-complete"
  "flow-implement-start" "flow-implement-complete"
  # Navigation (3 commands)
  "flow-next" "flow-next-subject" "flow-next-iteration"
  # Status & Validation (5 commands)
  "flow-status" "flow-summarize" "flow-verify-plan" "flow-compact" "flow-rollback"
)

# Deprecated commands (renamed in v1.0.11+) - cleaned up during --force
DEPRECATED_COMMANDS=(
  "flow-phase" "flow-task" "flow-iteration"
  "flow-brainstorm_start" "flow-brainstorm_subject" "flow-brainstorm_resolve" "flow-brainstorm_complete"
  "flow-implement_start" "flow-implement_complete"
  "flow-update-plan-version"
)

FORCE=false

print_help() {
  cat <<EOF

Flow Framework Deployment Script v$FLOW_VERSION

USAGE:
  ./flow.sh [OPTIONS]

OPTIONS:
  --force, -f       Overwrite existing files
  --version, -v     Show version information
  --help, -h        Show this help

DEPLOYMENT STRUCTURE:
  .claude/commands/          Slash commands (20 files)
  .flow/                     Framework documentation
    ├── DEVELOPMENT_FRAMEWORK.md
    └── EXAMPLE_PLAN.md

This script is SELF-CONTAINED - no external files needed!

EOF
}

print_version() {
  cat <<EOF
Flow Framework v$FLOW_VERSION

A spec-driven iterative development methodology combining
Domain-Driven Design principles with Agile philosophy.

Created by: Liad Goren
Repository: https://github.com/khgs2411/flow
License: Open for personal and commercial use

EOF
}

extract_command() {
  local cmd="$1"
  local marker="## /${cmd}$"
  awk -v marker="$marker" '
    $0 ~ marker {found=1; next}
    found && /^```markdown$/ {inside=1; next}
    found && inside && /^```$/ {exit}
    found && inside {print}
  ' <<'COMMANDS_DATA_EOF'
# Flow Framework - Slash Commands

This file contains all slash command definitions for the Flow framework. Copy these to `.claude/commands/` when ready to use.

---

## Command Guidelines

**IMPORTANT**: Every command must:

1. **Read the framework guide** at the start to understand patterns and structure
2. **Find and parse .flow/PLAN.md** to understand current state
3. **Follow framework patterns exactly** (status markers, section structure, etc.)
4. **Update .flow/PLAN.md** according to framework conventions
5. **Provide clear next steps** to the user

**File Locations**:
- **Plan File**: `.flow/PLAN.md` (Flow manages the plan from this directory)
- **Framework Guide**: Search in order:
  1. `.flow/DEVELOPMENT_FRAMEWORK.md`
  2. `.claude/DEVELOPMENT_FRAMEWORK.md`
  3. `./DEVELOPMENT_FRAMEWORK.md` (project root)
  4. `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)

**Finding PLAN.md** (all commands except `/flow-blueprint` and `/flow-migrate`):
- Primary location: `.flow/PLAN.md`
- If not found, search project root and traverse up
- If still not found: Suggest `/flow-blueprint` (new project) or `/flow-migrate` (existing docs)

**Status Markers** (use consistently):
- ✅ Complete
- ⏳ Pending
- 🚧 In Progress
- 🎨 Ready for Implementation
- ❌ Cancelled
- 🔮 Deferred

---

## /flow-blueprint

**File**: `flow-blueprint.md`

```markdown
---
description: Create new .flow/PLAN.md for a feature/project from scratch
---

You are executing the `/flow-blueprint` command from the Flow framework.

**Purpose**: Create a brand new PLAN.md file from scratch for a new feature/project/bug/issue.

**IMPORTANT**: This command ALWAYS creates a fresh `.flow/PLAN.md`, overwriting any existing plan file. Use `/flow-migrate` if you want to convert existing documentation.

**💡 TIP FOR USERS**: Provide rich context in $ARGUMENTS! You are the domain expert - the more details you provide upfront, the better the plan.

**Good example**:
```
/flow-blueprint "Payment Gateway Integration

Requirements:
- Integrate with Stripe API for credit card processing
- Support webhooks for async payment notifications
- Handle failed payments with retry logic (3 attempts, exponential backoff)

Constraints:
- Must work with existing Express.js backend
- Maximum 2-second response time

Reference:
- See src/legacy/billing.ts for old PayPal integration
- Similar webhook pattern in src/webhooks/shipment.ts

Testing:
- Simulation-based per service (scripts/{service}.scripts.ts)
"
```

**Minimal example** (AI will ask follow-up questions):
```
/flow-blueprint "payment gateway"
```

**Instructions**:

1. **Read the framework guide**:
   - Search for DEVELOPMENT_FRAMEWORK.md in these locations (in order):
     - `.flow/DEVELOPMENT_FRAMEWORK.md`
     - `.claude/DEVELOPMENT_FRAMEWORK.md`
     - `./DEVELOPMENT_FRAMEWORK.md` (project root)
     - `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
   - Read the first found location
   - Understand the hierarchy: PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION
   - Study the plan file template section
   - Note the status markers and section structure

2. **Analyze the feature request**: `$ARGUMENTS`
   - Extract all provided information: requirements, constraints, reference paths, testing preferences
   - If user provided rich context (requirements, constraints, references), use it directly
   - If minimal context provided (just a name), prepare to ask follow-up questions

3. **Check for reference implementation** (if not already in $ARGUMENTS):
   - If user mentioned reference paths in arguments (e.g., "See src/legacy/billing.ts"), read and analyze them
   - If no reference mentioned, ask: "Do you have a reference implementation I should analyze? (Provide path or say 'no')"
   - If reference provided, read and analyze it to inform the planning

4. **Gather testing methodology** (CRITICAL - if not already in $ARGUMENTS):
   - If user provided testing details in arguments (e.g., "Testing: Simulation-based per service"), use them directly and skip to step 5
   - Otherwise, ask: "How do you prefer to verify implementations? Choose or describe:
     - **Simulation-based (per-service)**: Each service has its own test file (e.g., `{service}.scripts.ts`)
     - **Simulation-based (single file)**: All tests in one orchestration file (e.g., `run.scripts.ts`)
     - **Unit tests**: Test individual functions/classes after implementation (Jest/Vitest/etc.)
     - **TDD**: Write tests before implementation, then make them pass
     - **Integration/E2E**: Focus on end-to-end workflows, minimal unit tests
     - **Manual QA**: No automated tests, manual verification only
     - **Custom**: Describe your approach"
   - **CRITICAL follow-up questions**:
     - "What's your test file naming convention?" (e.g., `{service}.scripts.ts`, `{feature}.test.ts`, `{feature}.spec.ts`)
     - "Where do test files live?" (e.g., `scripts/`, `__tests__/`, `tests/`, `e2e/`)
     - "When should I create NEW test files vs. add to existing?" (e.g., "Create `{service}.scripts.ts` for new services, add to existing for enhancements")
   - **IMPORTANT**: These answers determine how AI creates/modifies test files in every iteration

5. **Gather any other project-specific patterns** (if not clear from $ARGUMENTS):
   - File naming conventions (if mentioned or user specifies)
   - Directory structure preferences (if relevant)
   - Code style preferences (if mentioned)
   - Skip if not applicable to project type

6. **Generate .flow/PLAN.md** following the framework template (ALWAYS overwrites if exists):
   - Note: .flow/ directory already exists (created by flow.sh installation)
   - **Framework reference**: Link to DEVELOPMENT_FRAMEWORK.md at top
   - **Overview section**: Purpose, goals, scope
   - **Architecture section**: High-level design, key components
   - **Testing Strategy section** (NEW - REQUIRED):
     - Document the testing methodology from step 4
     - **Must include**: Methodology, Location, Naming Convention, When to create, When to add, Tooling
     - Include file structure example showing test file organization
     - Add IMPORTANT section with ✅ DO and ❌ DO NOT examples
     - Example for per-service simulation:
       ```markdown
       ## Testing Strategy
       **Methodology**: Simulation-based orchestration per service
       **Naming Convention**: `{service}.scripts.ts`
       **Location**: `scripts/` directory
       **When to create**: If `scripts/{service}.scripts.ts` doesn't exist for new service
       **When to add**: If file exists, add test cases to existing file
       **IMPORTANT**:
       - ✅ Create `scripts/gold.scripts.ts` for new "gold" service
       - ✅ Add to `scripts/blue.scripts.ts` for blue enhancements
       - ❌ Do NOT create `test.*.ts` files (wrong naming pattern)
       ```
     - Example for unit tests: "Unit tests created after implementation in __tests__/ using Jest. Create `{feature}.test.ts` for new features, add to existing for enhancements."
   - **Progress Dashboard**: For complex projects (optional, can add later)
   - **Development Plan**:
     - Estimate 2-4 phases (Foundation, Core Implementation, Testing, Enhancement/Polish)
     - For each phase: 1-5 tasks
     - For each task: 2-10 iterations (high-level names only)
     - Mark everything as ⏳ PENDING
     - Add placeholder brainstorming sessions (empty subject lists)

7. **Depth**: Medium detail
   - Phase names and strategies
   - Task names and purposes
   - Iteration names only (no brainstorming subjects yet)

8. **Confirm to user**:
   - "✨ Created .flow/PLAN.md with [X] phases, [Y] tasks, [Z] iterations"
   - "📂 Flow is now managing this project from .flow/ directory"
   - "Use `/flow-status` to see current state"
   - "Use `/flow-brainstorm-start [topic]` to begin first iteration"

**Output**: Create `.flow/PLAN.md` file and confirm creation to user.
```

---

## /flow-migrate

**File**: `flow-migrate.md`

```markdown
---
description: Migrate existing PRD/PLAN/TODO to Flow's .flow/PLAN.md format
---

You are executing the `/flow-migrate` command from the Flow framework.

**Purpose**: Migrate existing project documentation (PLAN.md, TODO.md, etc.) to Flow-compliant `.flow/PLAN.md` format.

**IMPORTANT**: This command ALWAYS creates a fresh `.flow/PLAN.md`, overwriting any existing plan file. It reads your current documentation and converts it to Flow format.

**Instructions**:

1. **Read the framework guide**:
   - Search for DEVELOPMENT_FRAMEWORK.md in these locations (in order):
     - `.flow/DEVELOPMENT_FRAMEWORK.md`
     - `.claude/DEVELOPMENT_FRAMEWORK.md`
     - `./DEVELOPMENT_FRAMEWORK.md` (project root)
     - `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
   - Understand Flow's hierarchy: PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION
   - Study the Progress Dashboard template
   - Note all status markers (✅ ⏳ 🚧 🎨 ❌ 🔮)

2. **Discover existing documentation**:
   - Check if user provided path in `$ARGUMENTS`
   - Otherwise, search project root for common files (in order):
     - `PRD.md` (common in TaskMaster AI, Spec-Kit)
     - `PLAN.md`
     - `TODO.md`
     - `DEVELOPMENT.md`
     - `ROADMAP.md`
     - `TASKS.md`
   - If multiple found, list them and ask: "Found [X] files. Which should I migrate? (number or path)"
   - If none found, ask: "No plan files found. Provide path to file you want to migrate, or use `/flow-blueprint` to start fresh."

3. **Read and analyze source file**:
   - Read entire source file
   - Detect structure type:
     - **STRUCTURED** (Path A): Has phases/tasks/iterations or similar hierarchy
     - **FLAT_LIST** (Path B): Simple todo list or numbered items
     - **UNSTRUCTURED** (Path C): Free-form notes, ideas, design docs
   - Extract key information:
     - Project context/purpose
     - Existing work completed
     - Current status/position
     - Remaining work
     - Architecture/design notes
     - V1/V2 splits (if mentioned)
     - Deferred items
     - Cancelled items

4. **Create backup**:
   - Copy source file: `[original].pre-flow-backup-$(date +%Y-%m-%d-%H%M%S)`
   - Confirm: "✅ Backed up [original] to [backup]"

5. **Generate .flow/PLAN.md** based on detected structure (ALWAYS overwrites if exists):
   - Note: .flow/ directory already exists (created by flow.sh installation)

   **Path A - STRUCTURED** (already has phases/tasks):
   - Keep existing hierarchy
   - Add framework reference at top
   - Add/enhance Progress Dashboard section (after Overview, before Architecture)
   - **Remove duplicate progress sections** (search for patterns like "Current Phase:", "Implementation Tasks", old progress trackers)
   - **Update status pointers** (change "Search for 'Current Phase' below" to jump link to Progress Dashboard)
   - **Identify redundant framework docs** (ask user if sections like "Brainstorming Framework" should be removed since Flow provides this)
   - Standardize status markers (✅ ⏳ 🚧 🎨 ❌ 🔮)
   - Add jump links to Progress Dashboard
   - Preserve all content, decisions, and context
   - Reformat sections to match Flow template
   - Report: "Enhanced existing structure (preserved [X] phases, [Y] tasks, [Z] iterations, removed [N] duplicate sections)"

   **Path B - FLAT_LIST** (todos/bullets):
   - Ask: "Group items into phases? (Y/n)"
   - If yes, intelligently group related items
   - If no, create single phase with items as iterations
   - Add framework reference
   - Add Progress Dashboard
   - Convert items to Flow iteration format
   - Add placeholder brainstorming sessions
   - Mark completed items as ✅, pending as ⏳
   - Report: "Converted flat list to Flow structure ([X] phases, [Y] tasks, [Z] iterations)"

   **Path C - UNSTRUCTURED** (notes):
   - Extract key concepts and features mentioned
   - Create Framework reference
   - Create Overview section from notes
   - Create Architecture section if design mentioned
   - Create Progress Dashboard (minimal - project just starting)
   - Create initial brainstorming session with subjects from notes
   - Mark everything as ⏳ PENDING
   - Report: "Created Flow plan from notes (extracted [X] key concepts as brainstorming subjects)"

7. **Add standard Flow sections** (all paths):
   - Framework reference: `> **📖 Framework Guide**: See DEVELOPMENT_FRAMEWORK.md`
   - Progress Dashboard (with proper format)
   - Development Plan with proper hierarchy
   - Status markers at every level

8. **Smart content preservation**:
   - NEVER discard user's original content
   - Preserve all decisions, rationale, context
   - Preserve code examples, file paths, references
   - Preserve completion status and dates
   - Enhance with Flow formatting, don't replace

9. **Confirm to user**:
   ```
   ✨ Migration complete!

   📂 Source: [original file path]
   💾 Backup: [backup file path]
   🎯 Output: .flow/PLAN.md

   Migration type: [STRUCTURED/FLAT_LIST/UNSTRUCTURED]
   Changes:
     + Added Progress Dashboard with jump links
     + Enhanced [X] status markers
     + Preserved [Y] completed items
     + Preserved [Z] pending items
     + [other changes specific to migration type]

   Next steps:
     1. Review: diff [backup] .flow/PLAN.md
     2. Verify: /flow-status
     3. Start using Flow: /flow-brainstorm_start [topic]

   📂 Flow is now managing this project from .flow/ directory
   ```

10. **Handle edge cases**:
    - If source file is empty: Suggest `/flow-blueprint` instead
    - If source file is already Flow-compliant: Mention it's already compatible, migrate anyway
    - If can't determine structure: Default to Path C (unstructured)
    - If migration fails: Keep backup safe, report error, suggest manual approach

**Output**: Create `.flow/PLAN.md` from existing documentation, create backup, confirm migration to user.
```

---

## /flow-plan-update

**File**: `flow-plan-update.md`

```markdown
---
description: Update existing plan to match latest Flow framework structure
---

You are executing the `/flow-plan-update` command from the Flow framework.

**Purpose**: Update an existing `.flow/PLAN.md` to match the latest Flow framework structure and patterns.

**IMPORTANT**: This command updates your current plan file to match framework changes (e.g., Progress Dashboard moved, new status markers, structural improvements).

**Instructions**:

1. **Read the framework guide**:
   - Search for DEVELOPMENT_FRAMEWORK.md in these locations (in order):
     - `.flow/DEVELOPMENT_FRAMEWORK.md`
     - `.claude/DEVELOPMENT_FRAMEWORK.md`
     - `./DEVELOPMENT_FRAMEWORK.md` (project root)
     - `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
   - Understand current framework structure and patterns
   - Study the Progress Dashboard template and its location
   - Note all status markers and section structure requirements

2. **Read the example plan**:
   - Search for EXAMPLE_PLAN.md in these locations (in order):
     - `.flow/EXAMPLE_PLAN.md`
     - `.claude/EXAMPLE_PLAN.md`
     - `~/.claude/flow/EXAMPLE_PLAN.md` (global)
   - Study the section order and formatting
   - Note how Progress Dashboard is positioned
   - Understand the complete structure template

3. **Read current plan**:
   - Read `.flow/PLAN.md` (your project's current plan)
   - Analyze its current structure
   - Identify what needs updating to match framework

4. **Create backup**:
   - Copy current plan: `.flow/PLAN.md.version-update-backup-$(date +%Y-%m-%d-%H%M%S)`
   - Confirm: "✅ Backed up .flow/PLAN.md to [backup]"

5. **Update plan structure** (preserve ALL content):
   - **NEVER discard any user content** - only reformat and enhance
   - Update section order to match framework:
     1. Title + Framework Reference
     2. Overview (Purpose, Goals, Scope)
     3. **Progress Dashboard** (if complex project, OR create if missing)
     4. Architecture
     5. Development Plan (Phases → Tasks → Iterations)
   - Move Progress Dashboard if in wrong location (should be after Overview, before Architecture)
   - **Remove duplicate progress sections** (search for old "Implementation Tasks", "Current Phase" headers, redundant trackers)
   - **Update status pointers** (change old references like "Search for 'Current Phase' below" to jump link: `[Progress Dashboard](#-progress-dashboard)`)
   - **Clean up redundant framework documentation** (if user has custom brainstorming/workflow docs that duplicate Flow, ask if they want to remove)
   - Add Progress Dashboard if missing and project is complex (10+ iterations)
   - Ensure all status markers are standardized (✅ ⏳ 🚧 🎨 ❌ 🔮)
   - Add jump links to Progress Dashboard if missing
   - Update any deprecated patterns to new format
   - Preserve all:
     - Decisions and rationale
     - Brainstorming subjects and resolutions
     - Implementation notes
     - Completion dates
     - Bug discoveries
     - Code examples

6. **Verify consistency**:
   - Check Progress Dashboard matches status markers
   - Verify all sections follow framework structure
   - Ensure no content was lost

7. **Confirm to user**:
   ```
   ✨ Plan structure updated to match latest Flow framework!

   💾 Backup: .flow/PLAN.md.version-update-backup-[timestamp]
   🎯 Updated: .flow/PLAN.md

   Changes made:
     + Moved Progress Dashboard to correct location (after Overview, before Architecture)
     + Removed [N] duplicate progress sections (old trackers)
     + Updated status pointers to use jump links
     + Added [X] jump links to Progress Dashboard
     + Standardized [Y] status markers
     + Cleaned up [Z] redundant framework documentation
     + [other changes specific to this update]

   Next steps:
     1. Review changes: diff [backup] .flow/PLAN.md
     2. Verify: /flow-status
     3. Continue work: /flow-next

   All your content preserved - only structure enhanced.
   ```

8. **Handle edge cases**:
   - If `.flow/PLAN.md` doesn't exist: Suggest `/flow-blueprint` or `/flow-migrate`
   - If plan already matches latest structure: Report "Already up to date!"
   - If can't determine what to update: Ask user what framework version they're coming from

**Output**: Update `.flow/PLAN.md` to latest framework structure, create backup, confirm changes to user.
```

---

## /flow-phase-add

**File**: `flow-phase-add.md`

```markdown
---
description: Add a new phase to the development plan
---

You are executing the `/flow-phase-add` command from the Flow framework.

**Purpose**: Add a new phase to the current PLAN.md file.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this phase that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Verify framework understanding**: Know that phases are top-level milestones (e.g., "Foundation", "Core Implementation", "Testing")

2. **Parse arguments**: `$ARGUMENTS` = phase description

3. **Add new phase section**:
   ```markdown
   ### Phase [N]: [$ARGUMENTS] ⏳

   **Strategy**: [Ask user or infer from description]

   **Goal**: [What this phase achieves]

   ---
   ```

4. **Update .flow/PLAN.md**: Append new phase to Development Plan section

5. **Confirm to user**: "Added Phase [N]: [$ARGUMENTS] to PLAN.md"

**Output**: Update .flow/PLAN.md with new phase.
```

---

## /flow-phase-start

**File**: `flow-phase-start.md`

```markdown
---
description: Mark current phase as in progress
---

You are executing the `/flow-phase-start` command from the Flow framework.

**Purpose**: Mark the current phase as 🚧 IN PROGRESS (when first task starts).

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this phase that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current phase**: Look for last phase marked ⏳ PENDING

3. **Update phase status**: Change marker from ⏳ to 🚧 IN PROGRESS

4. **Update Progress Dashboard**:
   - Find "## 📋 Progress Dashboard" section
   - Update current phase information
   - Update last updated timestamp
   - Add action description: "Phase [N] started"

5. **Confirm to user**: "Started Phase [N]: [Name]. Use `/flow-task-add [description]` to create tasks."

**Output**: Update .flow/PLAN.md with phase status change and Progress Dashboard update.
```

---

## /flow-phase-complete

**File**: `flow-phase-complete.md`

```markdown
---
description: Mark current phase as complete
---

You are executing the `/flow-phase-complete` command from the Flow framework.

**Purpose**: Mark the current phase as ✅ COMPLETE (when all tasks done).

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current phase**: Look for phase marked 🚧 IN PROGRESS

3. **Verify all tasks complete**: Check that all tasks in this phase are marked ✅ COMPLETE
   - If incomplete tasks found: "Phase has incomplete tasks. Complete them first or mark as ❌ CANCELLED / 🔮 DEFERRED."

4. **Update phase status**: Change marker from 🚧 to ✅ COMPLETE

5. **Update Progress Dashboard**:
   - Find "## 📋 Progress Dashboard" section
   - Update current phase to next phase (or mark project complete if no next phase)
   - Update completion percentages
   - Update last updated timestamp
   - Add action description: "Phase [N] complete"

6. **Check for next phase**:
   - If next phase exists: Auto-advance to next phase (show name)
   - If no next phase: "All phases complete! Project finished."

7. **Confirm to user**: "Phase [N] marked complete! Next: Phase [N+1]: [Name]. Use `/flow-phase-start` when ready."

**Output**: Update .flow/PLAN.md with phase completion and Progress Dashboard update.
```

---

## /flow-task-add

**File**: `flow-task-add.md`

```markdown
---
description: Add a new task under the current phase
---

You are executing the `/flow-task-add` command from the Flow framework.

**Purpose**: Add a new task to the current phase in PLAN.md.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this task that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse arguments**: `$ARGUMENTS` = task description

3. **Find current phase**: Look for last phase marked ⏳ or 🚧

4. **Add new task section**:
   ```markdown
   #### Task [N]: [$ARGUMENTS] ⏳

   **Status**: PENDING
   **Purpose**: [What this task accomplishes]

   ---
   ```

5. **Update .flow/PLAN.md**: Append task under current phase

6. **Confirm to user**: "Added Task [N]: [$ARGUMENTS] to current phase"

**Output**: Update .flow/PLAN.md with new task.
```

---

## /flow-task-start

**File**: `flow-task-start.md`

```markdown
---
description: Mark current task as in progress
---

You are executing the `/flow-task-start` command from the Flow framework.

**Purpose**: Mark the current task as 🚧 IN PROGRESS (when first iteration starts).

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this task that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current task**: Look for last task marked ⏳ PENDING in current phase

3. **Update task status**: Change marker from ⏳ to 🚧 IN PROGRESS

4. **Update Progress Dashboard**:
   - Find "## 📋 Progress Dashboard" section
   - Update current task information
   - Update last updated timestamp
   - Add action description: "Task [N] started"

5. **Confirm to user**: "Started Task [N]: [Name]. Use `/flow-iteration-add [description]` to create iterations."

**Output**: Update .flow/PLAN.md with task status change and Progress Dashboard update.
```

---

## /flow-task-complete

**File**: `flow-task-complete.md`

```markdown
---
description: Mark current task as complete
---

You are executing the `/flow-task-complete` command from the Flow framework.

**Purpose**: Mark the current task as ✅ COMPLETE (when all iterations done).

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current task**: Look for task marked 🚧 IN PROGRESS

3. **Verify all iterations complete**: Check that all iterations in this task are marked ✅ COMPLETE
   - If incomplete iterations found: "Task has incomplete iterations. Complete them first or mark as ❌ CANCELLED / 🔮 DEFERRED."

4. **Update task status**: Change marker from 🚧 to ✅ COMPLETE

5. **Update Progress Dashboard**:
   - Find "## 📋 Progress Dashboard" section
   - Update current task to next task (or next phase if all tasks done)
   - Update completion percentages
   - Update last updated timestamp
   - Add action description: "Task [N] complete"

6. **Check if phase complete**:
   - If all tasks in phase are ✅ COMPLETE: Suggest `/flow-phase-complete`
   - If more tasks: Auto-advance to next task (show name)

7. **Confirm to user**: "Task [N] marked complete! Next: Task [N+1]: [Name]. Use `/flow-task-start` when ready."

**Output**: Update .flow/PLAN.md with task completion and Progress Dashboard update.
```

---

## /flow-iteration-add

**File**: `flow-iteration-add.md`

```markdown
---
description: Add a new iteration under the current task
---

You are executing the `/flow-iteration-add` command from the Flow framework.

**Purpose**: Add a new iteration to the current task in PLAN.md.

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this iteration that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse arguments**: `$ARGUMENTS` = iteration description

3. **Find current task**: Look for last task marked ⏳ or 🚧

4. **Add new iteration section**:
   ```markdown
   ##### Iteration [N]: [$ARGUMENTS] ⏳

   **Status**: PENDING
   **Goal**: [What this iteration builds]

   ---
   ```

5. **Update .flow/PLAN.md**: Append iteration under current task

6. **Confirm to user**: "Added Iteration [N]: [$ARGUMENTS] to current task. Use `/flow-brainstorm-start [topic]` to begin."

**Output**: Update .flow/PLAN.md with new iteration.
```

---

## /flow-brainstorm-start

**File**: `flow-brainstorm-start.md`

```markdown
---
description: Start brainstorming session for current iteration
---

You are executing the `/flow-brainstorm-start` command from the Flow framework.

**Purpose**: Begin a brainstorming session for the current iteration.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)
- **Framework Pattern**: See "Brainstorming Session Pattern" section in framework guide

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues during brainstorming that are NOT part of the current iteration:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse arguments**: `$ARGUMENTS` = brainstorming topic

3. **Find current iteration**: Look for last iteration marked ⏳ or 🚧

4. **Update iteration status**: Change to 🚧 IN PROGRESS

5. **Add brainstorming section**:
   ```markdown
   ### **Brainstorming Session - [$ARGUMENTS]**

   **Subjects to Discuss** (tackle one at a time):

   1. ⏳ [Suggest first subject based on iteration goal]

   **Resolved Subjects**:

   ---
   ```

6. **Suggest first subject**: Based on iteration name/goal, suggest an initial subject to discuss

7. **Confirm to user**: "Started brainstorming session: [$ARGUMENTS]. First subject: [subject name]. Use `/flow-brainstorm-subject [name]` to add more subjects."

**Output**: Update .flow/PLAN.md with brainstorming section and status change.
```

---

## /flow-brainstorm-subject

**File**: `flow-brainstorm-subject.md`

```markdown
---
description: Add a subject to discuss in brainstorming
---

You are executing the `/flow-brainstorm-subject` command from the Flow framework.

**Purpose**: Add a new subject to the current brainstorming session.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse arguments**: `$ARGUMENTS` = subject name and optional brief description

3. **Find current brainstorming session**: Look for "Subjects to Discuss" section

4. **Add subject to list**:
   - Count existing subjects
   - Append: `[N]. ⏳ **[$ARGUMENTS]** - [Brief description if provided]`

5. **Update .flow/PLAN.md**: Add subject to "Subjects to Discuss" list

6. **Confirm to user**: "Added Subject [N]: [$ARGUMENTS] to brainstorming session."

**Output**: Update .flow/PLAN.md with new subject.
```

---

## /flow-brainstorm-resolve

**File**: `flow-brainstorm-resolve.md`

```markdown
---
description: Resolve current subject with decision
---

You are executing the `/flow-brainstorm-resolve` command from the Flow framework.

**Purpose**: Mark a brainstorming subject as resolved with a decision.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse arguments**: `$ARGUMENTS` = subject name/number

3. **Find subject**:
   - If number provided, find subject [N]
   - If name provided, find matching subject
   - Default: Find first ⏳ subject (not yet resolved)

4. **Update subject status**: Change ⏳ to ✅ in "Subjects to Discuss" list

5. **Prompt user for details**:
   - "What decision did you make for this subject?"
   - "What's the rationale? (comma-separated reasons)"

6. **Determine resolution type** (IMPORTANT - choose ONE):

   **Type A: Pre-Implementation Task** (code changes needed before implementing iteration)
   - Ask: "Does this decision require code changes before implementing this iteration? (refactoring, bug fixes, system changes)"
   - If YES:
     - Create new pre-implementation task in "### **Pre-Implementation Tasks:**" section
     - Include: Objective, Root Cause (if bug), Solution, Action Items, Files to Modify
     - Mark subject resolution as: "**Action Items**: Pre-Implementation Task [N] created"
     - Example: "Task 3: Fix Conversion Placeholder Requirement"

   **Type B: Immediate Documentation** (architectural decision, no code changes yet)
   - If NO code changes needed:
     - Document decision in appropriate section (Architecture, Design Decisions, etc.)
     - List conceptual action items (if any)
     - Example: "Added `foundational: boolean` property to architecture docs"

   **Type C: Auto-Resolved** (answered by another subject's decision)
   - If subject was resolved by cascade effect:
     - Mark as: "**Resolution**: Auto-resolved by Subject [X]'s decision"
     - Briefly explain why it's answered
     - No separate action items needed

7. **Add resolution section** under "Resolved Subjects":
   ```markdown
   ### ✅ **Subject [N]: [Name]**

   **Decision**: [User's decision]

   **Rationale**:
   - [Reason 1]
   - [Reason 2]

   **Action Items**:
   - [ ] Pre-Implementation Task [N] created (Type A)
     OR
   - [ ] Updated Architecture section with [decision] (Type B)
     OR
   - Auto-resolved by Subject [X] (Type C)

   ---
   ```

8. **Update .flow/PLAN.md**: Update subject status, add resolution section, create pre-implementation task if Type A

9. **Suggest next action**:
   - Type A: "Created Pre-Implementation Task [N]. Continue with next subject or use `/flow-brainstorm-complete` when all subjects resolved."
   - Type B: "Documented decision. Continue with next subject or use `/flow-brainstorm-complete` when all subjects resolved."
   - Type C: "Auto-resolved. Continue with next subject or use `/flow-brainstorm-complete` when all subjects resolved."

10. **Confirm to user**: "Resolved Subject [N]: [Name] ([Resolution Type]). Use `/flow-brainstorm-subject` to add more, or `/flow-brainstorm-complete` when done."

**Output**: Update .flow/PLAN.md with resolved subject.
```

---

## /flow-brainstorm-complete

**File**: `flow-brainstorm-complete.md`

```markdown
---
description: Complete brainstorming and generate action items
---

You are executing the `/flow-brainstorm-complete` command from the Flow framework.

**Purpose**: Close the current brainstorming session (only after pre-implementation tasks are done).

**IMPORTANT**: Pre-implementation tasks should be documented IN PLAN.md during brainstorming, then completed BEFORE running this command.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Verify all subjects resolved**: Check "Subjects to Discuss" - all should be ✅

3. **Check for pre-implementation tasks**:
   - Look for "### **Pre-Implementation Tasks:**" section in PLAN.md
   - If found:
     - Check if all pre-tasks are marked ✅ COMPLETE
     - If any are ⏳ PENDING or 🚧 IN PROGRESS:
       "Pre-implementation tasks exist but are not complete. Complete them first, then run this command again."
     - If all are ✅ COMPLETE: Proceed to step 4
   - If not found:
     - Ask user: "Are there any pre-implementation tasks that need to be completed before starting the main implementation? (Refactoring, system-wide changes, bug fixes discovered during brainstorming, etc.)"
     - If yes: "Please document pre-implementation tasks in PLAN.md first (see framework guide), complete them, then run this command again."
     - If no: Proceed to step 4

4. **Update iteration status**: Change from 🚧 to 🎨 READY FOR IMPLEMENTATION

5. **Add note**: "**Status**: All brainstorming complete, pre-implementation tasks done, ready for implementation"

6. **Confirm to user**: "Brainstorming session complete. Iteration is now 🎨 READY FOR IMPLEMENTATION. Use `/flow-implement-start` to begin."

**Output**: Update .flow/PLAN.md with brainstorming completion status.
```

---

## /flow-implement-start

**File**: `flow-implement-start.md`

```markdown
---
description: Begin implementation of current iteration
---

You are executing the `/flow-implement-start` command from the Flow framework.

**Purpose**: Begin implementation phase for the current iteration.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)
- **Framework Pattern**: See "Implementation Pattern" section in framework guide
- **Prerequisite**: Brainstorming must be ✅ COMPLETE and all pre-implementation tasks done

**🚨 SCOPE BOUNDARY RULE (CRITICAL)**:
If you discover NEW issues during implementation that are NOT part of the current iteration's action items:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval
**Exception**: Syntax errors or blocking issues in files you must modify (document what you fixed)

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current iteration**: Look for iteration marked 🎨 READY FOR IMPLEMENTATION

3. **Read Testing Strategy section** (CRITICAL):
   - Locate "## Testing Strategy" section in PLAN.md
   - Understand the verification methodology (simulation, unit tests, TDD, manual QA, etc.)
   - Note file locations, naming conventions, and when verification happens
   - **IMPORTANT**: Follow Testing Strategy exactly - do NOT create test files that violate conventions

4. **Verify readiness**:
   - Brainstorming should be marked ✅ COMPLETE
   - All pre-implementation tasks should be ✅ COMPLETE
   - If not ready: Warn user and ask to complete brainstorming first

5. **Update iteration status**: Change from 🎨 to 🚧 IN PROGRESS

6. **Create implementation section**:
   ```markdown
   ### **Implementation - Iteration [N]: [Name]**

   **Status**: 🚧 IN PROGRESS

   **Action Items** (from brainstorming):

   [Copy all unchecked action items from resolved subjects]

   **Implementation Notes**:

   [Leave blank for user to fill during implementation]

   **Files Modified**:

   [Leave blank - will be filled as work progresses]

   **Verification**: [Leave blank - how work will be verified]

   ---
   ```

6. **Confirm to user**: "Implementation started for Iteration [N]. Work through action items and check them off as you complete them. Use `/flow-implement-complete` when done."

**Output**: Update .flow/PLAN.md with implementation section and status change.
```

---

## /flow-implement-complete

**File**: `flow-implement-complete.md`

```markdown
---
description: Mark current iteration as complete
---

You are executing the `/flow-implement-complete` command from the Flow framework.

**Purpose**: Mark the current iteration as complete.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current iteration**: Look for iteration marked 🚧 IN PROGRESS

3. **Verify completion**:
   - Check all action items are ✅ checked
   - If unchecked items remain: Ask user "There are unchecked action items. Are you sure you want to mark complete? (yes/no)"

4. **Prompt for verification notes**:
   - "How did you verify this iteration works? (tests, manual checks, etc.)"

5. **Update iteration status**: Change from 🚧 to ✅ COMPLETE

6. **Update implementation section**:
   - Add verification notes
   - Add timestamp

7. **Add completion summary**:
   ```markdown
   **Implementation Results**:
   - [Summarize what was built]
   - [List key accomplishments]

   **Verification**: [User's verification method]

   **Completed**: [Date]
   ```

8. **Check if task/phase complete**:
   - If all iterations in task complete → Mark task ✅
   - If all tasks in phase complete → Mark phase ✅

9. **Confirm to user**: "Iteration [N] marked complete! Use `/flow-iteration-add [description]` to start next iteration, or `/flow-status` to see current state."

**Output**: Update .flow/PLAN.md with completion status and summary.
```

---

## /flow-status

**File**: `flow-status.md`

```markdown
---
description: Show current position and verify plan consistency
---

You are executing the `/flow-status` command from the Flow framework.

**Purpose**: Show current position in the plan.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse Progress Dashboard** (if exists):
   - Look for "## 📋 Progress Dashboard" section
   - Extract claimed current phase/task/iteration
   - Extract completion percentages
   - Note: Dashboard is manual, may need verification

3. **Parse status markers** (ground truth):
   - Find current phase (last phase with ⏳ 🚧 🎨 ❌ 🔮)
   - Find current task (last task with ⏳ 🚧 🎨 ❌ 🔮)
   - Find current iteration (last iteration with ⏳ 🚧 🎨 ❌ 🔮)
   - Count ✅ COMPLETE items (these are frozen, skip verification)

4. **Smart verification** (active work only):
   - **Skip ✅ COMPLETE items** - Already verified, now frozen
   - **Verify active work** (🚧 ⏳ 🎨):
     - Check if Progress Dashboard claims match markers
     - Check if ❌ CANCELLED items have reasons
     - Check if 🔮 DEFERRED items have reasons + destinations
   - **Report**:
     ```
     🔍 Consistency Check (Active Work Only):

     ✅ Phase 2 marker: 🚧 IN PROGRESS ✓
     ✅ Task 5 marker: 🚧 IN PROGRESS ✓
     ✅ Iteration 6 marker: 🚧 IN PROGRESS ✓

     ⏭️  Skipped: 15 completed items (verified & frozen)

     Status: All active markers aligned with Progress Dashboard ✓
     ```

5. **If inconsistency detected**:
   ```
   ⚠️  INCONSISTENCY (Active Work):

   Progress Dashboard: Iteration 6 🚧 IN PROGRESS
   Actual marker: Iteration 6 ⏳ PENDING

   Action: Update Progress Dashboard to match markers
   (Markers are ground truth)

   ⏭️  Skipped: 15 completed items
   ```

6. **Display hierarchy**:
   ```
   📋 Current Status:

   Phase [N]: [Name] [Status]
     └─ Task [N]: [Name] [Status]
         └─ Iteration [N]: [Name] [Status]

   Next Action: [Suggest next command based on status]
   ```

7. **Suggest next action**:
   - If ⏳ PENDING → "Use `/flow-brainstorm-start [topic]` to begin"
   - If 🚧 IN PROGRESS (brainstorming) → "Continue resolving subjects with `/flow-brainstorm-resolve`"
   - If 🎨 READY → "Use `/flow-implement-start` to begin implementation"
   - If 🚧 IN PROGRESS (implementing) → "Work through action items, use `/flow-implement-complete` when done"
   - If ✅ COMPLETE → "Use `/flow-iteration [description]` to start next iteration"

8. **Show progress summary**:
   - Count completed vs total iterations
   - Count completed vs total tasks
   - Show percentage complete
   - Show deferred count (🔮)
   - Show cancelled count (❌)

**Output**: Display current status, smart verification results, and suggest next action.
```

---

## /flow-summarize

**File**: `flow-summarize.md`

```markdown
---
description: Generate summary of all phases/tasks/iterations
---

You are executing the `/flow-summarize` command from the Flow framework.

**Purpose**: Generate high-level overview of entire project structure and completion state.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)
- **Use case**: "Bird's eye view" of project health, progress across all phases, quick status reports

**Comparison to other commands**:
- `/flow-status` = "Where am I RIGHT NOW?" (micro view - current iteration)
- `/flow-summarize` = "What's the WHOLE PICTURE?" (macro view - all phases/tasks/iterations)
- `/flow-verify-plan` = "Is this accurate?" (validation)
- `/flow-compact` = "Transfer full context" (comprehensive handoff)

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Parse entire PLAN.md structure**:
   - Extract Version (from metadata at top)
   - Extract current Status line (from metadata)
   - Parse ALL phases with their status markers
   - For each phase, parse ALL tasks
   - For each task, parse ALL iterations
   - Track completion percentages at each level

3. **Generate structured summary** (compact, scannable format):

   ```
   📊 Flow Summary

   Version: [V1/V2/V3]
   Status: [Current phase/task/iteration from metadata]

   Phase [N]: [Name] [Status] [%]
   - Task [N]: [Name] [Status]
     - Iter [N-N] [Status]: [Concise description]
     - Iter [N] 🚧 CURRENT: [What you're working on]
     - Iter [N] ⏳: [What's next]

   Phase [N]: [Name] [Status] [%]
   - Task [N-N]: [Grouped if similar] [Status]
   - Task [N]: [Name] [Status]

   Deferred to V2:
   - [Iteration/feature name]
   - [Iteration/feature name]

   ---
   TL;DR: [One punchy sentence about overall state]
   ```

4. **Formatting rules**:
   - **Compact**: Group consecutive completed iterations (e.g., "Iter 1-5 ✅")
   - **Scannable**: Use emojis (✅ ⏳ 🚧 🎨) and percentages prominently
   - **Highlight**: Mark CURRENT work explicitly in bold or with flag
   - **Indent**: Phase (no indent), Task (- prefix), Iteration (-- or nested -)
   - **Defer section**: Show V2/future items at bottom
   - **Skip noise**: Don't list every task name if they're obvious/sequential
   - **Focus on active work**: Emphasize in-progress and next items

5. **Example output** (payment gateway):

   ```
   📊 Flow Summary

   Version: V1
   Status: Phase 2, Task 5, Iteration 2 - In Progress

   Phase 1: Foundation ✅ 100%
   - Task 1-2: Setup, API, Database schema ✅

   Phase 2: Core Implementation 🚧 75%
   - Task 3-4: Payment processing, Webhooks ✅
   - Task 5: Error Handling
     - Iter 1 ✅: Retry logic
     - Iter 2 🚧 CURRENT: Circuit breaker
     - Iter 3 ⏳: Dead letter queue

   Phase 3: Testing & Integration ⏳ 0%
   - Task 6: Integration tests (pending)

   Deferred to V2:
   - Advanced features (monitoring, metrics)
   - Name generation

   ---
   TL;DR: Foundation done, core payment flow working, currently building circuit breaker for error handling.
   ```

   **Example output** (RED project - showing V1/V2 split):

   ```
   📊 Flow Summary - RED Ability Generation

   === V1 - Core System ===

   Phase 1: Foundation ✅ 100%
   - Task 1-4: Constants, enums, types, refactoring ✅

   Phase 2: Core Implementation 🚧 85%
   - Iter 1-5 ✅: Tier gen, slots, filtering, selection, template parsing
   - Iter 6 🚧 NEXT: Green.generate() integration (ties everything together)
   - Iter 7 ⏳: Blue validation (input guards)
   - Iter 9 ⏳ LAST: Red API wrapper (exposes Blue → Green)

   Phase 3: Testing
   - Script-based testing (Blue → Green flow)

   Deferred to V2:
   - Iter 8: Name generation (stub returns "Generated Ability")
   - Database persistence
   - Stats-based damage calculations

   === V2 - Enhanced System (Phase 4) ===

   Enhancements:
   - Potency system (stats × formulas replace fixed damage)
   - Name generation (124 weighted prefix/suffix combos)
   - 12 new placeholders (conditionals, resources, targeting)
   - Damage variance (±10% for crits)
   - Points & Luck systems
   - Database persistence

   ---
   TL;DR:
   V1 = Basic working system with hardcoded damage ranges (85% done, integration next)
   V2 = Dynamic formulas, character stats integration, full feature set
   ```

6. **Add deferred/cancelled sections**:
   ```
   🔮 Deferred Items:
   - Iteration 10: Name Generation (V2 - complexity, needs 124 components)
   - Task 12: Advanced Features (V2 - out of V1 scope)
   - Feature X: Multi-provider support (V3 - abstraction layer)

   ❌ Cancelled Items:
   - Task 8: Custom HTTP Client (rejected - SDK is better)
   - Subject 3: GraphQL API (rejected - REST is sufficient)
   ```

7. **Smart verification** (active work only):
   - Skip ✅ COMPLETE items (verified & frozen)
   - Verify 🚧 ⏳ 🎨 items match Progress Dashboard
   - Check ❌ items have reasons
   - Check 🔮 items have reasons + destinations
   - Report:
     ```
     🔍 Verification (Active Work Only):
     ✅ All active markers (🚧 ⏳) match Progress Dashboard
     ⏭️  Skipped 18 completed items (verified & frozen)
     ```

8. **Handle multiple versions**:
   - If PLAN.md has V2/V3 sections, use `=== V1 Summary ===` separator
   - V1 gets full Phase/Task/Iteration breakdown
   - V2+ get high-level "Enhancements" list (not full iteration tree)
   - Separate TL;DR line for each version

9. **After generating summary**:
   - "Use `/flow-status` to see detailed current position"
   - "Use `/flow-verify-plan` to verify accuracy against actual code"

**Manual alternative**:
- Read entire PLAN.md manually
- Create outline of all phases/tasks/iterations
- Count completions and calculate percentages
- Format into hierarchical view

**Output**: Hierarchical summary of entire project structure with completion tracking.
```

---

## /flow-next-subject

**File**: `flow-next-subject.md`

```markdown
---
description: Move to next brainstorming subject
---

You are executing the `/flow-next-subject` command from the Flow framework.

**Purpose**: Move to the next unresolved subject in the current brainstorming session.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current brainstorming session**: Look for "Subjects to Discuss" section

3. **Find first unresolved subject**: Look for first ⏳ subject in the list

4. **If found**:
   - Display subject name and description
   - Ask: "Ready to resolve this subject? Use `/flow-brainstorm-resolve [subject-name]`"

5. **If all resolved**:
   - Notify: "All subjects resolved! Use `/flow-brainstorm-complete` to finish brainstorming."

6. **Show progress**: "[N] of [Total] subjects resolved"

**Output**: Show next subject to work on.
```

---

## /flow-next-iteration

**File**: `flow-next-iteration.md`

```markdown
---
description: Show next iteration details
---

You are executing the `/flow-next-iteration` command from the Flow framework.

**Purpose**: Display details about the next pending iteration in the current task.

**Pattern**: Works like `/flow-next-subject` but for iterations - shows what's coming next.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current task**: Look for task marked 🚧 IN PROGRESS

3. **Find next pending iteration**: Look for first iteration in current task marked ⏳ PENDING

4. **If found, display iteration details**:
   ```
   📋 Next Iteration:

   **Iteration [N]**: [Name]

   **Goal**: [What this iteration builds]

   **Status**: ⏳ PENDING

   **Approach**: [Brief description from iteration section if available]

   ---
   Ready to start? Use `/flow-brainstorm-start [topic]` to begin.
   ```

5. **If NOT found (no pending iterations)**:
   - Check if current iteration is in progress: "Still working on Iteration [N]: [Name]. Use `/flow-implement-complete` when done."
   - Otherwise: "No more iterations in current task. Use `/flow-iteration-add [description]` to create next iteration, or `/flow-task-complete` if task is done."

6. **Show progress**: "Iteration [current] of [total] in current task"

**Output**: Display next iteration details and suggest appropriate next action.
```

---

## /flow-next

**File**: `flow-next.md`

```markdown
---
description: Smart helper - suggests next action based on current context
---

You are executing the `/flow-next` command from the Flow framework.

**Purpose**: Auto-detect current context and suggest the next logical step.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Determine current context**:
   - Check current iteration status (⏳ 🚧 🎨 ✅)
   - Check if in brainstorming session (look for "Subjects to Discuss")
   - Check if in implementation (look for "Action Items")

3. **Suggest next command based on context**:

   **If in brainstorming (🚧)**:
   - "Use `/flow-next-subject` to see next subject to resolve"
   - OR "Use `/flow-brainstorm-complete` if all subjects done"

   **If ready for implementation (🎨)**:
   - "Use `/flow-implement-start` to begin implementation"

   **If implementing (🚧)**:
   - Show unchecked action items count
   - "Complete action items and use `/flow-implement-complete` when done"

   **If iteration complete (✅)**:
   - "Use `/flow-next-iteration` to move to next iteration"

   **If pending (⏳)**:
   - "Use `/flow-brainstorm-start [topic]` to begin this iteration"

4. **Show current status summary**: Brief summary of where you are

**Output**: Suggest appropriate next command based on context.
```

---

## /flow-rollback

**File**: `flow-rollback.md`

```markdown
---
description: Undo last plan change
---

You are executing the `/flow-rollback` command from the Flow framework.

**Purpose**: Undo the last change made to PLAN.md.

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Check if rollback is possible**:
   - Look for "Changelog" section at bottom of PLAN.md
   - If no recent changes logged: "No recent changes to rollback."

3. **Identify last change**:
   - Parse last entry in Changelog
   - Determine what was changed (phase added, task marked complete, etc.)

4. **Ask for confirmation**:
   - "Last change: [Description of change]. Rollback? (yes/no)"

5. **If confirmed, revert change**:
   - Remove last added section, OR
   - Change status marker back to previous state, OR
   - Uncheck last checked checkbox

6. **Update Changelog**: Add rollback entry

7. **Confirm to user**: "Rolled back: [Description of change]"

**Limitation**: Can only rollback one step at a time. For major reverts, manually edit PLAN.md.

**Output**: Revert last change in PLAN.md.
```

---

## /flow-verify-plan

**File**: `flow-verify-plan.md`

```markdown
---
description: Verify plan file matches actual codebase state
---

You are executing the `/flow-verify-plan` command from the Flow framework.

**Purpose**: Verify that PLAN.md is synchronized with the actual project state.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)
- **Use case**: Run before starting new AI session or compacting conversation to ensure context is accurate

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Find current iteration**: Look for iteration marked 🚧 IN PROGRESS or 🎨 READY FOR IMPLEMENTATION

3. **Read current implementation section**:
   - Find "Implementation - Iteration [N]" section
   - Identify all action items
   - Note which items are marked as ✅ complete

4. **Verify claimed completions against actual project state**:
   - For each ✅ completed action item, check if it actually exists:
     - "Create UserAuth.ts" → Verify file exists
     - "Add login endpoint" → Search for login endpoint in code
     - "Update database schema" → Check schema files
   - List any discrepancies found

5. **Check for unreported work**:
   - Look for modified files that aren't mentioned in PLAN.md
   - Check git status (if available) for uncommitted changes
   - Identify files that were changed but not documented

6. **Report findings**:
   ```
   📋 Plan Verification Results:

   ✅ Verified Complete:
   - [List action items that are correctly marked complete]

   ❌ Discrepancies Found:
   - [List action items marked complete but evidence not found]

   📝 Unreported Work:
   - [List files changed but not mentioned in PLAN.md]

   Status: [SYNCHRONIZED / NEEDS UPDATE]
   ```

7. **If discrepancies found**:
   - Ask user: "PLAN.md is out of sync with project state. Update .flow/PLAN.md now? (yes/no)"
   - If yes: Update .flow/PLAN.md to reflect actual state:
     - Uncheck items that aren't actually done
     - Add notes about files modified
     - Update status markers if needed
   - If no: "Review discrepancies above and update PLAN.md manually."

8. **If synchronized**:
   - "PLAN.md is synchronized with project state. Ready to continue work."

**Manual alternative**:
- Review PLAN.md action items manually
- Check each completed item exists in codebase
- Use `git status` and `git diff` to verify changes
- Update .flow/PLAN.md to match reality

**Output**: Verification report and optional PLAN.md updates.
```

---

## /flow-compact

**File**: `flow-compact.md`

```markdown
You are executing the `/flow-compact` command from the Flow framework.

**Purpose**: Generate comprehensive conversation report for context transfer to new AI instance.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: .flow/PLAN.md (current project)
- **Use case**: Before compacting conversation or starting new AI session - ensures zero context loss

**Instructions**:

1. **Find .flow/PLAN.md**: Look for .flow/PLAN.md (primary location: .flow/ directory)

2. **Run status verification first**:
   - Execute `/flow-status` command logic to verify current position
   - Check for conflicting status sections (warn if found)
   - Use this verified status as authoritative source for the report

3. **Generate comprehensive report covering**:

   **Current Work Context**:
   - What feature/task are we working on?
   - What phase/task/iteration are we in? (with status)
   - What was the original goal?

   **Conversation History**:
   - What decisions were made during brainstorming? (with rationale)
   - What subjects were discussed and resolved?
   - What pre-implementation tasks were identified and completed?
   - What action items were generated?

   **Implementation Progress**:
   - What has been implemented so far?
   - What files were created/modified?
   - What verification was done?
   - What remains incomplete?

   **Challenges & Solutions**:
   - What blockers were encountered?
   - How were they resolved?
   - What design trade-offs were made?

   **Next Steps**:
   - What is the immediate next action?
   - What are the pending action items?
   - What should the next AI instance focus on?

   **Important Context**:
   - Any quirks or special considerations for this feature
   - Technical constraints or dependencies
   - User preferences or decisions that must be preserved

4. **Report format**:
   ```
   # Context Transfer Report
   ## Generated: [Date/Time]

   ## Current Status
   [Phase/Task/Iteration with status markers]

   ## Feature Overview
   [What we're building and why]

   ## Conversation Summary
   [Chronological summary of discussions and decisions]

   ## Implementation Progress
   [What's done, what's in progress, what's pending]

   ## Key Decisions & Rationale
   [Critical decisions made with reasoning]

   ## Files Modified
   [List with brief description of changes]

   ## Challenges Encountered
   [Problems and how they were solved]

   ## Next Actions
   [Immediate next steps for new AI instance]

   ## Critical Context
   [Must-know information for continuation]
   ```

5. **Important guidelines**:
   - **Do NOT include generic project info** (tech stack, architecture overview, etc.)
   - **Focus ENTIRELY on the feature at hand** and this conversation
   - **Do NOT worry about token output length** - comprehensive is better than brief
   - **Include WHY, not just WHAT** - decisions need context
   - **Be specific** - reference exact file names, function names, line numbers
   - **Preserve user preferences** - if user made specific choices, document them

6. **After generating report**:
   - "Context transfer report generated. Copy this report to a new AI session to continue work with zero context loss."
   - "Use `/flow-verify-plan` before starting new session to ensure PLAN.md is synchronized."

**Manual alternative**:
- Read entire conversation history manually
- Summarize key points, decisions, and progress
- Document in separate notes file
- Reference PLAN.md for structure

**Output**: Comprehensive context transfer report.
```

---

## Installation Instructions

To use these commands:

1. **Copy individual command files** to `.claude/commands/`:
   ```bash
   mkdir -p .claude/commands
   # Copy each command section above into separate .md files
   # Example: flow-blueprint.md, flow-phase.md, etc.
   ```

2. **Or use the copy-paste method**:
   - Copy the content between the code blocks for each command
   - Create corresponding `.md` files in `.claude/commands/`
   - File names should match command names (e.g., `flow-blueprint.md`)

3. **Test with `/help`**: Run `/help` in Claude Code to see your new commands listed

---

## Command Execution Flow

```
/flow-blueprint
    ↓
Creates PLAN.md with skeleton
    ↓
/flow-brainstorm_start
    ↓
/flow-brainstorm-subject (repeat as needed)
    ↓
/flow-brainstorm_resolve (for each subject)
    ↓
Complete pre-implementation tasks (if any)
    ↓
/flow-brainstorm_complete
    ↓
/flow-implement-start
    ↓
Work through action items (check them off)
    ↓
/flow-implement-complete
    ↓
Repeat for next iteration
```

**Helper commands** available at any time:
- `/flow-status` - Check current position
- `/flow-next` - Auto-advance to next step
- `/flow-rollback` - Undo last change
- `/flow-phase-add`, `/flow-task-add`, `/flow-iteration-add` - Add structure as needed

---

**Version**: 1.0.9
**Last Updated**: 2025-10-02
COMMANDS_DATA_EOF
}

get_framework_content() {
  cat <<'FRAMEWORK_DATA_EOF'
**Version**: 1.0.9

# Domain-Driven Design with Agile Iterative Philosophy

**A spec-driven iterative development framework for building complex features with minimal refactoring.**

---

## Philosophy

This framework combines **Domain-Driven Design** principles with an **Agile iterative approach** to software development. The core analogy is building the human body:

1. **Skeleton first** - Create the basic structure and foundational components
2. **Add veins** - Implement core data flow and connections
3. **Add flesh** - Layer on complexity incrementally
4. **Add fibers** - Refine and optimize

By splitting development into minuscule, well-planned iterations, you build a strong foundation and expand complexity over time while keeping refactoring to a minimum.

---

## Core Principles

### 1. Plan File as Single Source of Truth

- Every feature/project/issue has a dedicated `.flow/PLAN.md` file
- Flow manages the plan from the `.flow/` directory in your project root
- The plan file survives across sessions and maintains complete context
- All decisions, brainstorming results, and implementation progress are documented
- AI agents and humans can resume work from any point by reading the plan

**File Structure**:
```
your-project/
├── .flow/
│   ├── PLAN.md              # Flow-managed plan (single source of truth)
│   └── DEVELOPMENT_FRAMEWORK.md (optional - project-specific framework guide)
├── src/
├── tests/
└── ...
```

**Getting Started**:
- **New project**: Use `/flow-blueprint [description]` to create fresh `.flow/PLAN.md`
- **Existing project**: Use `/flow-migrate [file]` to convert existing documentation to Flow format
- Both commands create `.flow/PLAN.md` and take full control of plan management

### 2. Iterative Development Loop

```
PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION → COMPLETE
                   ↓           ↓              ↓
               (repeat)   (subjects)    (action items)
```

### 3. Progressive Disclosure

- Each iteration focuses ONLY on what's needed NOW
- Future complexity is deferred to V2/V3/etc.
- Prevents scope creep and over-engineering

### 4. State Preservation

- Every step updates the plan file with checkboxes (✅ ⏳ 🚧)
- Timestamps and status markers track progress
- Complete audit trail of all decisions

### 5. Minimal Refactoring

- Brainstorm BEFORE implementing to make correct decisions upfront
- Split complex features into small, testable iterations
- Each iteration is complete and stable before moving to next

### 6. Scope Boundary Rule (CRITICAL)

**🚨 NEVER fix out-of-scope issues without explicit user permission.**

When working within **any Flow scope** (Phase/Task/Iteration/Brainstorming/Pre-Implementation Task), if you discover a NEW issue that is NOT part of the current work:

1. **STOP** current work immediately
2. **NOTIFY** user of the new issue discovered
3. **DISCUSS** with user what to do:
   - Add as new brainstorming subject?
   - Create new pre-implementation task?
   - Defer to next iteration?
   - Handle immediately (only if user explicitly approves)?
4. **ONLY** proceed with user's explicit approval

**Examples of scope violations**:
- Working on Pre-Implementation Task 2 (fix validation bug), discover Test 3 has unrelated placeholder parsing issue → **STOP, ask user**
- Implementing Iteration 5 (add error handling), notice Iteration 2 code has typo → **STOP, ask user**
- Resolving brainstorm Subject 3 (API design), realize database schema needs refactoring → **STOP, ask user**

**Why this matters**:
- Prevents scope creep and uncontrolled changes
- Maintains Flow's intentional progression
- Preserves user's ability to prioritize work
- Keeps iterations focused and reviewable
- Avoids "fixing" things that may be intentional or have hidden dependencies

**The only exception**: Fixing issues that are **directly blocking** the current task (e.g., syntax error in file you must modify). Even then, document what you fixed and why.

---

## Framework Structure

### Hierarchy

```
📋 PLAN.md (Feature/Project Plan File)
├── Overview (purpose, goals, scope)
├── Architecture (high-level design, components, dependencies)
├── Testing Strategy (methodology, tooling, verification approach) ⭐ NEW
├── Progress Dashboard (current status, completion %, deferred items)
├── 📊 PHASE (High-level milestone)
│   ├── 📦 TASK (Feature/component to build)
│   │   ├── 🔄 ITERATION (Incremental buildout)
│   │   │   ├── 💭 BRAINSTORMING SESSION
│   │   │   │   ├── Subject 1 (Design decision)
│   │   │   │   ├── Subject 2 (Design decision)
│   │   │   │   └── Subject N...
│   │   │   │       └── Action Items (checkboxes)
│   │   │   └── 🛠️ IMPLEMENTATION
│   │   │       └── Execute action items
│   │   │   └── ✅ VERIFICATION (per Testing Strategy)
│   │   └── ✅ ITERATION COMPLETE
│   └── 🎯 TASK COMPLETE
└── 🏆 PHASE COMPLETE
```

### Testing Strategy Section (REQUIRED)

**Purpose**: Define HOW you verify implementations so AI follows YOUR testing conventions exactly.

**Must Include**:
1. **Methodology**: How you test (simulation, unit tests, TDD, integration, manual QA, etc.)
2. **Location**: Where test files live (directory path)
3. **Naming Convention**: Test file naming pattern (CRITICAL - AI must follow exactly)
4. **When to create**: When to create NEW test files vs. add to existing
5. **When to add**: When to add test cases to existing files
6. **Tooling**: What tools/frameworks you use (Jest, Vitest, custom scripts, etc.)

**Common Approaches**:

- **Simulation-based (per-service pattern)**: Each service has its own orchestration file
  - Example: `scripts/{service}.scripts.ts` (blue.scripts.ts, green.scripts.ts, red.scripts.ts)
  - AI creates `scripts/gold.scripts.ts` if working on new "gold" service
  - AI adds to `scripts/blue.scripts.ts` if file already exists
  - **Convention matters**: `{service}.scripts.ts` NOT `test.{service}.*.ts`

- **Simulation-based (single file)**: All tests in one orchestration file
  - Example: `scripts/run.scripts.ts` handles all services
  - AI adds test cases to existing file, never creates new test files

- **Unit tests after implementation**: Write tests after code works
  - Example: `__tests__/{feature}.test.ts` created after iteration complete
  - AI creates `__tests__/payment-gateway.test.ts` for new features
  - AI adds test cases to existing file if feature already tested

- **TDD (Test-Driven Development)**: Write tests before implementation
  - Example: Red → Green → Refactor cycle
  - AI creates `tests/{feature}.spec.ts` first, then implements to make it pass

- **Integration/E2E focused**: Minimal unit tests, focus on workflows
  - Example: `e2e/{workflow}.spec.ts` for critical user journeys
  - AI creates new E2E test for each major workflow

- **Manual QA only**: No automated tests
  - AI never creates test files, provides manual verification checklist instead

**Why This Matters**:
- **Prevents convention violations**: AI won't create `test.blue.validation.ts` when your pattern is `blue.scripts.ts`
- **Respects file structure**: AI knows WHERE to create test files (scripts/ vs __tests__ vs e2e/)
- **Follows naming patterns**: AI matches YOUR naming convention exactly
- **Knows when to create vs. add**: AI creates new files for new features, adds to existing for enhancements
- **Ensures verification happens at the right time**: During iteration, after, or before (TDD)

**Example 1 - Per-Service Simulation** (like RED project):
```markdown
## Testing Strategy

**Methodology**: Simulation-based orchestration per service

**Approach**:
- Each service has its own orchestration file: `scripts/{service}.scripts.ts`
- **Naming Convention**: `{service}.scripts.ts` (e.g., `blue.scripts.ts`, `green.scripts.ts`, `red.scripts.ts`)
- **Location**: `scripts/` directory
- **When to create**: If `scripts/{service}.scripts.ts` doesn't exist for new service, create it
- **When to add**: If file exists, add new test cases to existing orchestration
- Tests simulate real-world usage patterns (spell generation, validation, etc.)

**Test Execution**:
```bash
bun run scripts/run.scripts.ts           # Run all services
bun run scripts/{service}.scripts.ts      # Run specific service
```

**File Structure**:
```
scripts/
├── run.scripts.ts        # Main orchestration (runs all services)
├── blue.scripts.ts       # Blue service tests
├── green.scripts.ts      # Green service tests
├── red.scripts.ts        # Red service tests
└── gold.scripts.ts       # Gold service tests (create if new service)
```

**IMPORTANT**:
- ❌ Do NOT create `test.{service}.*.ts` files (wrong naming pattern)
- ❌ Do NOT create files outside `scripts/` directory (wrong location)
- ✅ DO follow `{service}.scripts.ts` pattern exactly
- ✅ DO create new `{service}.scripts.ts` for new services
```

**Example 2 - Unit Tests After Implementation**:
```markdown
## Testing Strategy

**Methodology**: Unit tests after implementation using Jest

**Approach**:
- Unit tests created AFTER implementation is verified manually
- **Naming Convention**: `{feature}.test.ts` (e.g., `payment-gateway.test.ts`)
- **Location**: `__tests__/` directory
- **When to create**: After iteration implementation complete and working
- **When to add**: If feature already has test file, add new test cases

**Test Execution**: `npm test`

**IMPORTANT**:
- ✅ Create `__tests__/new-feature.test.ts` for new features
- ✅ Add test cases to `__tests__/existing-feature.test.ts` for enhancements
- ❌ Do NOT create tests before implementation (we're not doing TDD)
```

---

## Development Workflow

### Step 1: Decide What to Work On

Choose the scope:

- **Phase**: Major milestone (e.g., "Core Implementation")
- **Task**: Specific feature/component (e.g., "Implement Green Service")
- **Iteration**: Incremental piece (e.g., "Iteration 1: Tier Generation")

### Step 2: Brainstorm

Break down the iteration into **subjects to discuss**:

- Architecture decisions
- Implementation approach
- Edge cases and constraints
- Data structures
- Algorithm choices

For each subject:

1. Discuss options (Option A, B, C...)
2. Document rationale
3. Make a decision
4. Create **action items** (checkboxes)

### Step 3: Implementation

Work through action items sequentially:

- Check off each item as completed
- Update plan file with results
- Add notes/discoveries during implementation

### Step 4: Mark Complete

- All action items checked → Iteration complete
- All iterations complete → Task complete
- All tasks complete → Phase complete

### Step 5: Repeat

Move to next iteration, applying lessons learned.

---

## Brainstorming Session Pattern

### Structure

```markdown
### **Brainstorming Session - [Topic Name]**

**Subjects to Discuss** (tackle one at a time):

1. ⏳ **Subject Name** - Brief description
2. ⏳ **Subject Name** - Brief description
3. ⏳ **Subject Name** - Brief description
   ...

**Resolved Subjects**:

---

### ✅ **Subject 1: [Name]**

**Decision**: [Your decision here]

**Rationale**:

- Reason 1
- Reason 2
- Reason 3

**Options Considered**:

- **Option A**: Description (✅ CHOSEN / ❌ REJECTED)
- **Option B**: Description (✅ CHOSEN / ❌ REJECTED)

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

---

### ✅ **Subject 2: [Name]**

[Repeat pattern...]
```

### Subject Resolution Types

**Every resolved subject falls into ONE of these types:**

**Type A: Pre-Implementation Task** 🔧
- **When**: Decision requires code changes BEFORE implementing the iteration
- **Examples**: Refactoring, bug fixes, system-wide changes, removing deprecated code
- **Action**: Create new task in "### **Pre-Implementation Tasks:**" section
- **Template**:
  ```markdown
  #### ⏳ Task [N]: [Name] (PENDING)

  **Objective**: [What this accomplishes]

  **Root Cause** (if bug): [Why this is needed]

  **Solution**: [How to fix/implement]

  **Action Items**:
  - [ ] Specific step 1
  - [ ] Specific step 2

  **Files to Modify**:
  - path/to/file.ts (what to change)
  ```

**Type B: Immediate Documentation** 📝
- **When**: Architectural decision with NO code changes yet
- **Examples**: Design patterns, data structure choices, API contracts
- **Action**: Update Architecture/Design sections in PLAN.md NOW
- **Result**: Decision documented, implementation happens during iteration

**Type C: Auto-Resolved** 🔄
- **When**: Subject answered by another subject's decision (cascade effect)
- **Examples**: "If we use Pattern X, then Question Y is answered"
- **Action**: Mark as "Auto-resolved by Subject [N]", explain why
- **Result**: No separate action needed, decision flows from parent subject

**Example from Real Project**:
```markdown
Subject 1 (Architecture): Add `foundational: boolean` property
→ Resolution Type: B (Immediate Documentation)
→ Action: Updated architecture section

Subject 7 (Bug Fix): Conversion placeholder requires 2+ elements
→ Resolution Type: A (Pre-Implementation Task)
→ Action: Created Task 3 with code changes, test cases, files to modify

Subjects 2-5: Element type semantics, validation, etc.
→ Resolution Type: C (Auto-Resolved by Subject 1)
→ Action: Marked as "answered by Subject 1's foundational decision"
```

### Brainstorming Guidelines

1. **One subject at a time** - Don't overwhelm yourself
2. **Document all options** - Even rejected ones (future reference)
3. **Explain rationale** - Why did you choose this approach?
4. **Choose resolution type** - Pre-Implementation Task, Immediate Doc, or Auto-Resolved
5. **Mark resolved** - Use ✅ to track progress
6. **Add subjects dynamically** - New topics can emerge during discussion

### Dynamic Subject Addition

**Subjects are NOT fixed upfront** - you can add new subjects as you work through brainstorming:

```markdown
**Subjects to Discuss**:

1. ✅ **API Design** - RESOLVED
2. 🚧 **Data Structure** - CURRENT (discussing now)
3. ⏳ **Error Handling** - PENDING
4. ⏳ **Type Conversion** - NEW (just added!)
5. ⏳ **Validation Strategy** - NEW (discovered during Subject 2)
```

**When to Add Subjects**:

- During discussion of current subject, you realize another topic needs addressing
- While resolving one subject, dependencies on other decisions become clear
- When analyzing code/reference, new questions arise
- After resolving a subject, implications suggest new topics

**How to Add**:

1. **IMMEDIATELY update PLAN.md**: Add new numbered item to "Subjects to Discuss" list with ⏳ status
2. Mark it as "NEW" or add brief context about why it was added
3. Continue with current subject - don't jump to new one immediately

**IMPORTANT**: Always update the "Subjects to Discuss" list in PLAN.md BEFORE continuing the discussion. This ensures you don't lose track of topics.

**Example**:
```markdown
User: "I now dislike the names... let's think about naming convention"

AI: "Great point! Let me add this as a subject to our brainstorming session first."

[AI updates PLAN.md:]

**Subjects to Discuss**:
1. 🚧 **Placeholder Detection Strategy** - CURRENT
2. ⏳ **Naming Convention** - NEW (emerged during Subject 1 discussion)
3. ⏳ **Handler Registration** (Q2 from Subject 1) - DEFERRED

AI: "Added Subject 2: Naming Convention to the list. Now, back to Subject 1..."
```

### Pre-Implementation Tasks During Brainstorming

**IMPORTANT**: When pre-implementation needs are discovered **during brainstorming**, DOCUMENT them immediately but DO NOT implement them yet.

**Workflow**:

1. **During brainstorming** (while discussing subjects)
2. User identifies pre-implementation need (e.g., "we need to create a validation stub in Blue")
3. **AI adds Pre-Implementation Tasks section** to PLAN.md:
   ```markdown
   ### **Pre-Implementation Tasks:**

   #### ⏳ Task 1: [Description] (PENDING)

   **Objective**: [What this task accomplishes]

   **Action Items**:
   - [ ] Item 1
   - [ ] Item 2
   ```
4. **Continue brainstorming** other subjects
5. **After all subjects resolved** → Complete pre-implementation tasks
6. **Mark pre-tasks as ✅ COMPLETE** with verification notes
7. **Then run `/flow-brainstorm_complete`**

**Example During Brainstorming**:

```markdown
User: "Before we continue, create a pre-implementation task to add a validation
      stub in Blue.validateSlotData() that returns true for now."

AI: "Added pre-implementation task. Continuing with Subject 1..."

### **Pre-Implementation Tasks:**

#### ⏳ Task 1: Create Blue Validation Stub (PENDING)

**Objective**: Add Blue.validateSlotData() method that returns true (placeholder
              for future validation logic)

**Action Items**:
- [ ] Add validateSlotData(slotData: I_SlotData): boolean method to Blue.ts
- [ ] Return true (stub implementation)
- [ ] Add TODO comment for future validation logic
- [ ] Create corresponding iteration in PLAN.md for actual implementation

---

[Continue brainstorming subjects...]
```
4. Address new subjects in order after completing current discussion

**Example Flow**:

```
Discussing Subject 2: Parser Architecture
  → Realize we need to decide on placeholder syntax first
  → Add "Subject 4: Placeholder Syntax Design" to list
  → Finish Subject 2 discussion
  → Move to Subject 3
  → Eventually get to Subject 4
```

**Benefits**:

- Captures insights as they emerge
- Prevents forgetting important topics
- Maintains focus on current subject
- Natural, organic planning process

---

## Implementation Pattern

### Structure

```markdown
### **Implementation - Iteration [N]: [Name]**

**Status**: 🚧 IN PROGRESS / ✅ COMPLETE

**Action Items** (from brainstorming):

- [x] Completed action item
- [x] Completed action item
- [ ] Pending action item

**Implementation Notes**:

[Document discoveries, challenges, solutions during implementation]

**Files Modified**:

- `path/to/file.ts` - Description of changes
- `path/to/file.ts` - Description of changes

**Verification**: [How you verified it works - tests, manual checks, etc.]

---
```

### Implementation Guidelines

1. **Follow action items** - Don't deviate from brainstorming decisions
2. **Check boxes as you go** - Maintain accurate state
3. **Document surprises** - Note anything unexpected
4. **Verify before completing** - Test/validate your work
5. **Update file list** - Track what changed

---

## Version Management

Features can be split into versions:

- **V1**: Minimum viable implementation (simple, functional)
- **V2**: Enhanced implementation (optimizations, edge cases)
- **V3**: Advanced features (rarely needed)

### When to Version

**Use V1 for:**

- Core functionality that must work
- Simple, testable implementations
- Proving the concept

**Defer to V2:**

- Performance optimizations
- Advanced edge cases
- Complex algorithms
- Nice-to-have features

**Mark in Plan:**

```markdown
**V1 Implementation**: [Description]
**V2 Enhancements** (Deferred to Phase 4):

- [ ] Optimization 1
- [ ] Feature 2
```

---

## Status Markers

**CRITICAL**: Status markers are **MANDATORY** at every level (Phase, Task, Iteration, Brainstorm, Subject). They are the ground truth for your project state.

### Marker Reference

| Marker | Meaning          | Usage                                           | Documentation Required       | Verification         |
| ------ | ---------------- | ----------------------------------------------- | ---------------------------- | -------------------- |
| ✅     | Complete         | Finished and verified (frozen, no re-verify)    | Completion date              | Skipped (frozen)     |
| ⏳     | Pending          | Not started yet                                 | None                         | Verified             |
| 🚧     | In Progress      | Currently working on this                       | None                         | Verified             |
| 🎨     | Ready            | Brainstorming done, ready to implement          | None                         | Verified             |
| ❌     | Cancelled        | Decided against (task/iteration/subject)        | **WHY** (mandatory!)         | Verified             |
| 🔮     | Deferred         | Moved to V2/V3/later phase                      | **WHY + WHERE** (mandatory!) | Verified             |

### Required Documentation

**For ❌ CANCELLED items:**

Must include reason for cancellation:

```markdown
##### Iteration 8: Custom Retry Logic ❌

**Status**: CANCELLED
**Reason**: SDK already handles retry logic with exponential backoff. Reimplementing would be redundant and error-prone.
**Cancelled on**: 2025-09-30
```

**For 🔮 DEFERRED items:**

Must include reason AND destination:

```markdown
##### Iteration 10: Name Generation 🔮

**Status**: DEFERRED to Phase 4 (V2)
**Reason**: Requires 124 name components with weighted selection system. Core generation must be proven first.
**Deferred to**: Phase 4, Task 11
**Deferred on**: 2025-10-01
```

### Mandatory Markers

**Every level MUST have a status marker:**

```markdown
### Phase 1: Foundation ✅

**Status**: COMPLETE
**Completed**: 2025-09-30

#### Task 1: Setup & Integration ✅

**Status**: COMPLETE
**Completed**: 2025-09-28

##### Iteration 1: Project Setup ✅

**Status**: COMPLETE
**Completed**: 2025-09-28

### **Brainstorming Session - API Setup** ✅

**Status**: COMPLETE

**Subjects to Discuss**:
1. ✅ **Credential Management** - RESOLVED
2. ❌ **Custom HTTP Client** - REJECTED (SDK is better)
3. 🔮 **Advanced Retry** - DEFERRED to V2
```

### Smart Verification

**Token-efficient validation:**

Commands verify only **active work** (🚧 ⏳ 🎨 ❌ 🔮) and skip completed items (✅):

- ✅ **COMPLETE** items = Verified when completed, now frozen (skipped)
- 🚧 **IN PROGRESS** items = Verify markers match Progress Dashboard
- ⏳ **PENDING** items = Verify markers exist
- ❌ **CANCELLED** items = Verify reason is documented
- 🔮 **DEFERRED** items = Verify reason and destination documented

**Example:**

```
🔍 Verification:
✅ Phase 2 marker: 🚧 IN PROGRESS ✓
✅ Task 5 marker: 🚧 IN PROGRESS ✓
✅ Iteration 6 marker: 🚧 IN PROGRESS ✓

⏭️  Skipped: 15 completed items (verified & frozen)
```

---

## Status Management Best Practices

### Single Source of Truth for Status

**CRITICAL**: Your PLAN.md should have **EXACTLY ONE** authoritative status indicator.

**Where to put status:**
- At the top of the file, in the metadata section
- Format: `**Status**: [Current phase/iteration]`
- Example: `**Status**: Phase 2, Task 5, Iteration 7 - In Progress`

**What NOT to do:**
- ❌ Creating multiple "Progress Tracking" or "Current Status" sections
- ❌ Adding status summaries at the bottom of the file
- ❌ Leaving old status sections when updating to new status

### Maintaining Status in Long-Running Projects

As your project grows (1000+ lines), status management becomes critical:

1. **Update status in-place** - Don't create new status sections, update the existing one at the top
2. **Use status markers** - Let ✅ ⏳ 🚧 markers indicate completion, don't duplicate this info
3. **Archive old summaries** - If you create progress summaries, move them to a "Status History" appendix
4. **Use slash commands** - `/flow-status` dynamically reads your PLAN.md and reports TRUE current state

### Status Section Template

```markdown
**Created**: 2025-10-01
**Status**: Phase 2, Task 5, Iteration 7 - In Progress
**Version**: V1
**Last Updated**: 2025-10-02
```

Update `**Status**` and `**Last Updated**` as you progress. **NEVER** add a second status section.

### Verification

Before starting a new AI session or after a long break:

1. Run `/flow-status` - See computed current state from PLAN.md
2. Run `/flow-verify-plan` - Verify PLAN.md matches actual project files
3. Update the `**Status**` line at top if needed

---

## Progress Dashboard (Required for Complex Projects)

### When to Use

**Required for:**
- ✅ Projects with 10+ iterations across multiple phases
- ✅ V1/V2/V3 version planning with deferred features
- ✅ Long-running development (weeks/months)
- ✅ Large PLAN.md files (2000+ lines)

**Optional for:** Simple 2-3 iteration features (single status line may suffice)

### Purpose

The Progress Dashboard is **your mission control** - a single section at the top of PLAN.md that shows the big picture and points to current work. It works with status markers to create a rigorous progress tracking system:

- **Progress Dashboard** = Always visible pointer + overview (manual)
- **Status Markers** = Ground truth at every level (mandatory)
- **`/flow-status`** = Current position verification (computed, active work only)
- **`/flow-summarize`** = Full structure overview (computed, includes deferred/cancelled)

### Template

Insert this section **after Overview, before Architecture**:

```markdown
## 📋 Progress Dashboard

**Last Updated**: [Date]

**Current Work**:
- **Phase**: Phase 2 - Core Implementation → [Jump](#phase-2-core-implementation)
- **Task**: Task 5 - Error Handling → [Jump](#task-5-error-handling)
- **Iteration**: Iteration 6 - Circuit Breaker → [Jump](#iteration-6-circuit-breaker)

**Completion Status**:
- Phase 1: ✅ 100% | Phase 2: 🚧 75% | Phase 3: ⏳ 0%

**Progress Overview**:
- ✅ **Iteration 1-5**: [Grouped completed items] (verified & frozen)
- 🚧 **Iteration 6**: Circuit Breaker ← **YOU ARE HERE**
- ⏳ **Iteration 7**: Blue Validation
- ⏳ **Iteration 8-9**: [Pending work]
- 🔮 **Iteration 10**: Name Generation (DEFERRED to V2 - complexity)

**V1 Remaining Work**:
1. Complete Iteration 6
2. Implement Iteration 7
3. Implement Iteration 9

**V2 Deferred Items**:
1. Iteration 10: Name Generation (moved - complexity)
2. Task 12: Advanced Features (out of V1 scope)

**Cancelled Items**:
1. Task 8: Custom HTTP Client (REJECTED - SDK is better)

---
```

### Key Elements

1. **Jump links** - Navigate to current work in large files (`[Jump](#phase-2-core-implementation)`)
2. **YOU ARE HERE** - Crystal clear current position
3. **Completion %** - Quick progress view per phase
4. **Grouped completed items** - Token-efficient (marked "verified & frozen")
5. **Deferred/Cancelled tracking** - Explicit scope decisions with reasons

### Positioning in PLAN.md

```markdown
# [Feature] - Development Plan

> **📖 Framework Guide**: See DEVELOPMENT_FRAMEWORK.md

**Created**: [Date]
**Version**: V1

---

## Overview
[Purpose, Goals, Scope]

---

## 📋 Progress Dashboard    ← INSERT HERE (after Overview, before Architecture)

[Dashboard content]

---

## Architecture
[High-level design, components]

---

## Development Plan         ← STATUS MARKERS AT EVERY LEVEL

### Phase 1: Foundation ✅

**Status**: COMPLETE
**Completed**: 2025-09-30

#### Task 1: Setup ✅

**Status**: COMPLETE
...
```

### ⚠️ Avoiding Duplicate Progress Tracking

**IMPORTANT**: The Progress Dashboard is the **ONLY** progress tracking section in your PLAN.md.

**Do NOT create:**
- ❌ Separate "Implementation Tasks" section with current phase/iteration
- ❌ "Current Status" section elsewhere in the file
- ❌ Multiple progress trackers at different locations
- ❌ Status pointers like "Search for 'Current Phase' below" (use jump links instead)

**If migrating an existing plan:**
- `/flow-migrate` and `/flow-update-plan-version` will clean up duplicate sections
- Old progress trackers will be removed
- Status pointers will be converted to jump links: `[Progress Dashboard](#-progress-dashboard)`

**Single Source of Truth:**
- **Progress Dashboard** = Always-visible overview with jump links
- **Status Markers** = Ground truth at every level (✅ ⏳ 🚧 🎨 ❌ 🔮)
- **Commands** = Computed verification (`/flow-status`, `/flow-summarize`)

### Maintaining the Dashboard

**Update triggers:**
- ✅ Completing an iteration
- ✅ Starting new iteration
- ✅ Deferring items to V2 (🔮)
- ✅ Cancelling items (❌)

**Maintenance steps:**
1. **Last Updated** - Change date when modifying
2. **← YOU ARE HERE** - Move to current iteration
3. **Completion %** - Recalculate per phase
4. **Jump links** - Update to current work
5. **Deferred/Cancelled sections** - Add items with reasons

### Verification (Smart & Token-Efficient)

**Hierarchy of truth:**
1. **Status markers** (✅ ⏳ 🚧 🎨 ❌ 🔮) = Ground truth
2. **Progress Dashboard** = Derived from markers (pointer)
3. **Commands** = Verify dashboard matches markers

**Smart verification (skips completed items):**

Commands verify only **active work**:
- 🚧 IN PROGRESS - Verify markers match dashboard
- ⏳ PENDING - Verify markers exist
- ❌ CANCELLED - Verify reason documented
- 🔮 DEFERRED - Verify reason + destination documented
- ✅ **COMPLETE - SKIPPED** (verified when completed, now frozen)

**When conflict:**
- Trust status markers (ground truth)
- Update dashboard to match
- Commands warn about mismatch

### Benefits

1. **Always visible** - No command execution, immediately scannable
2. **Token-efficient** - Completed items marked "verified & frozen" (skip re-verification)
3. **Single location** - Lives in PLAN.md (single source of truth)
4. **Navigate large files** - Jump links to current work (critical for 2000+ line files)
5. **Scope clarity** - Deferred/Cancelled sections show evolution
6. **Session continuity** - New AI sessions see full context
7. **Stakeholder friendly** - Copy/paste for reports

### Real-World Example

From a 3747-line game engine PLAN.md:

```markdown
## 📋 Progress Dashboard

**Last Updated**: 2025-10-02

**Current Work**:
- **Phase**: Phase 2 - Core Implementation → [Jump](#phase-2-core-implementation)
- **Task**: Task 5 - Green Service → [Jump](#task-5-green-service)
- **Iteration**: Iteration 7 - Blue Validation → [Jump](#iteration-7-blue-validation)

**Completion Status**:
- Phase 1: ✅ 100% | Phase 2: 🚧 95% | Phase 3: ⏳ 0%

**Progress Overview**:
- ✅ **Iteration 1-6**: Tier gen, slots, filtering, selection, parsing, integration (verified & frozen)
- 🚧 **Iteration 7**: Blue Validation (input guards) ← **YOU ARE HERE**
- ⏳ **Iteration 9**: Red API Layer (wraps Blue → Green)

**V1 Remaining Work**:
1. Complete Iteration 7 (Blue validation)
2. Implement Iteration 9 (Red wrapper)
3. Phase 3: Testing & iteration

**V2 Deferred Items** (Phase 4):
1. Iteration 8: Name Generation (124 components - complexity)
2. Task 12: 12 new placeholders (conditionals, resources)
3. Task 13: Potency system (stats-based formulas)
4. Task 14: Points & Luck (budget modifiers)
5. Task 15: Database persistence
6. Task 16: Damage variance (±10%)
7. Task 17: Game integration

**Cancelled Items**:
None

---
```

**Why this works:**
- Immediately see 95% done, 1 iteration active
- Jump link goes straight to Iteration 7 (in 3747-line file!)
- Completed items marked "verified & frozen" (commands skip them)
- 7 V2 items explicitly deferred with reasons
- Clear "YOU ARE HERE" + next steps

---

## Common Pitfalls

### Pitfall 1: Multiple Status Sections

**Problem**: In long projects (weeks/months), developers often add "Progress Tracking" sections at the bottom of PLAN.md. Over time, these become stale while the top status is updated, creating conflicting information.

**Example**:
```markdown
# Top of file (line 10):
**Status**: Phase 2, Task 5, Iteration 7 - In Progress

# Bottom of file (line 3600):
## Progress Tracking
Current Phase: Phase 1 - Foundation Setup (COMPLETE ✅)
Next Task: Task 5 - Implement Blue (Validator)
```

**Result**: New AI sessions read the stale bottom section and think you're at Iteration 1 when you're actually at Iteration 7.

**Solution**:
- Maintain single status line at top
- Use `/flow-status` to verify current state
- Archive old progress notes to "Status History (Archive)" section if needed

### Pitfall 2: Confusing Tasks vs Iterations

**Problem**: High-level "Tasks" (e.g., Task 7: Implement Green) don't map 1:1 to "Iterations" (Iteration 7: Red Orchestration). This naming overlap confuses status tracking.

**Example**:
- Task 7 is "Implement Green Service"
- Iteration 7 is "Red Orchestration" (different component!)

**Solution**:
- Use `/flow-status` to see the hierarchy clearly
- Status line should show both: `**Status**: Task 7 (Green Service), Iteration 5 (Template Parsing) - Complete`
- Don't rely on numbers alone; include names for clarity

### Pitfall 3: Not Verifying Status at Session Start

**Problem**: When starting a new AI session or compacting conversation, AI may scan PLAN.md and misinterpret current state (especially in 2000+ line files).

**Solution**:
- **ALWAYS** run `/flow-status` at the start of new AI sessions
- Run `/flow-verify-plan` to ensure PLAN.md matches actual code
- Explicitly state to AI: "We're on Iteration X, here's the context"

---

## Plan File Template

**Complete Example**: See `.flow/EXAMPLE_PLAN.md` for a full working example of a payment gateway integration project showing multiple completed iterations, brainstorming sessions, bug discoveries, and improvements.

### Basic Template Structure

```markdown
# [Feature/Project Name] - Development Plan

**Created**: [Date]
**Status**: [Current phase/iteration]
**Version**: V1

---

## Overview

**Purpose**: [What does this feature/project do?]

**Goals**:

- Goal 1
- Goal 2
- Goal 3

**Scope**: [What's included, what's excluded]

---

## Architecture

**High-Level Design**:
[Brief description of architecture, patterns, key components]

**Key Components**:

1. Component A - Description
2. Component B - Description
3. Component C - Description

**Dependencies**:

- Dependency 1
- Dependency 2

---

## Development Plan

### Phase 1: [Phase Name] ⏳

**Strategy**: [Overall approach for this phase]

**Goal**: [What this phase achieves]

---

#### Task 1: [Task Name] ⏳

**Status**: PENDING
**Purpose**: [What this task accomplishes]

---

##### Iteration 1: [Iteration Name] ⏳

**Status**: PENDING
**Goal**: [What this iteration builds]

---

### **Brainstorming Session - [Topic]**

**Subjects to Discuss**:

1. ⏳ **Subject Name** - Description
2. ⏳ **Subject Name** - Description
3. ⏳ **Subject Name** - Description

**Resolved Subjects**:

---

### ✅ **Subject 1: [Name]**

**Decision**: [Decision here]

**Rationale**:

- Reason 1
- Reason 2

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

---

### **Implementation - Iteration 1**

**Status**: 🚧 IN PROGRESS

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

**Files Modified**:

- `path/to/file.ts` - Changes

**Verification**: [How verified]

---

##### Iteration 2: [Iteration Name] ⏳

[Repeat pattern...]

---

#### Task 2: [Task Name] ⏳

[Repeat pattern...]

---

### Phase 2: [Phase Name] ⏳

[Repeat pattern...]

---

## Testing Strategy

**V1 Testing**:

- [ ] Test case 1
- [ ] Test case 2

**V2 Testing** (Deferred):

- [ ] Advanced test 1
- [ ] Advanced test 2

---

## Future Enhancements (V2+)

**Phase 4: Enhancement & Polish** (FUTURE)

**Deferred Features**:

- [ ] Feature 1
- [ ] Optimization 2
- [ ] Advanced capability 3

---

## Notes & Learnings

**Design Decisions**:

- Decision 1 and why
- Decision 2 and why

**Challenges Encountered**:

- Challenge 1 and solution
- Challenge 2 and solution

**Improvements Over Original** (if refactoring):

- Improvement 1
- Improvement 2

---

## Changelog

**[Date]** - Phase 1, Task 1, Iteration 1 complete

- Implemented X
- Added Y
- Fixed Z

**[Date]** - Brainstorming session for Iteration 2

- Resolved 5 subjects
- Created 12 action items

---
```

---

## Pre-Implementation Pattern

Before starting iteration implementation, identify if preparatory work is needed.

### When to Use Pre-Implementation Tasks

Pre-implementation tasks are preparatory work that must be completed BEFORE the main iteration implementation can begin:

- **Refactoring required** - System needs restructuring before new code
- **System-wide changes** - Updates affecting multiple files (e.g., enum → const conversion)
- **Data structure updates** - Interface/type changes needed across codebase
- **Bug fixes discovered during brainstorming** - Issues found during design that must be fixed first
- **Dependency changes** - Library updates or new dependencies to add
- **Test infrastructure** - Test setup needed before TDD implementation

### How to Document

Add pre-implementation tasks AFTER brainstorming session, BEFORE implementation:

```markdown
### **Pre-Implementation Tasks:**

#### ✅ Task 1: [Description] (COMPLETED)

**Objective**: [What this task accomplishes]

**Changes Made**:

- Change 1
- Change 2

**Verification**: [How verified]

---

#### ⏳ Task 2: [Description] (PENDING)

**Objective**: [What this task accomplishes]

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2

---
```

### Completion Rule

**IMPORTANT**: Mark brainstorming session as complete ONLY after all pre-implementation tasks are done.

**Flow**:

1. Complete brainstorming session → Create pre-tasks (if needed)
2. Complete all pre-tasks → Mark brainstorming ✅ COMPLETE
3. Brainstorming complete → Ready for main iteration implementation

---

## Bugs Discovered Pattern

When analyzing reference implementations or during brainstorming, you may discover bugs in existing code. Document these clearly as part of your iteration planning.

### When to Document Bugs

- **During brainstorming** when analyzing reference code
- **When planning refactoring** work
- **As part of pre-implementation tasks**
- **When the bug discovery changes your design decisions**

### How to Document

Add bugs discovered section during brainstorming, typically BEFORE pre-implementation tasks:

````markdown
### 🐛 **Bugs Discovered in Original Implementation**

#### Bug 1: [Short Description] (Critical/Major/Minor)

**Location**: `path/to/file.ts:line_number`

**Problem**:

```typescript
// ❌ Original code (WRONG):
const result = array[Math.random() * (array.length - 1)];
// Off-by-one error: last element never selected!
```
````

**Fix**:

```typescript
// ✅ Corrected code:
const result = array[Math.random() * array.length];
// Now all elements have equal probability
```

**Impact**: Subtle bias in random selection affecting game balance

**Action**: Add to pre-implementation tasks

---

#### Bug 2: [Short Description]

[Repeat pattern...]

````

### Improvements Over Original Pattern

When rewriting/refactoring existing code, document what you improved:

```markdown
### ✅ **Improvements Over Original**

1. **Bug Fixes**:
   - Fixed random selection off-by-one error
   - Corrected prevention logic (.every → .some)

2. **Performance**:
   - Single-pass filtering (original used 3 loops)
   - O(1) Set lookups instead of O(n) array searches

3. **Code Quality**:
   - Added comprehensive JSDoc comments
   - Removed dead code (unused parameters)
   - Strict TypeScript types (no 'any')

4. **Developer Experience**:
   - Rich error metadata instead of throwing
   - Extensive logging for debugging
   - Public methods for testing

5. **Safety**:
   - Infinite loop protection (max iterations)
   - Weight budget validation
   - Bidirectional constraint checking
````

### Benefits

**Bug Discovery Documentation**:

- Creates audit trail of improvements
- Helps team understand why changes were made
- Prevents reintroducing the same bugs
- Demonstrates thorough analysis

**Improvements Tracking**:

- Shows value of refactoring effort
- Guides future improvements
- Celebrates wins and learnings
- Provides reference for similar work

---

## Best Practices

### 1. Keep Iterations Small

- Target 1-3 days of work per iteration
- Each iteration should be independently testable
- Prefer many small iterations over few large ones

### 2. Brainstorm Before Coding

- ALWAYS brainstorm before implementation
- Document all options, even rejected ones
- Create concrete action items from decisions

### 3. Update the Plan Continuously

- Check boxes as you complete work
- Add notes during implementation
- Document surprises and learnings

### 4. Use Clear Status Markers

- Make it obvious what's done, what's pending, what's in progress
- Use emoji markers consistently (✅ ⏳ 🚧 🎨)

### 5. Defer Complexity

- V1 should be simple and functional
- Mark complex features as V2/V3
- Don't over-engineer early iterations

### 6. Validate Before Completing

- Every iteration should be verified (tests, manual checks, etc.)
- Document verification method
- Don't mark complete until proven working

### 7. Learn and Adapt

- Document challenges and solutions
- Track improvements over original implementations
- Apply learnings to future iterations

### 8. Proactively Update PLAN.md

- When using slash commands, PLAN.md updates happen automatically
- When working manually (without slash commands), AI agents should:
  - **Automatically update PLAN.md** after completing significant milestones (iterations, phases, tasks)
  - **Suggest updates** when test results or implementation details should be documented
  - **Check for staleness** - if implementation diverges from plan, update the plan
- The plan file is the source of truth and must stay synchronized with actual progress

---

## Example: Iteration Lifecycle

### Starting State

```markdown
##### Iteration 4: Affix Selection 🚧 IN PROGRESS

**Brainstorming Session**:
**Subjects to Discuss**:

1. ⏳ Constraint solver algorithm
2. ⏳ Prevention rule validation
3. ⏳ Weight budget handling
```

### During Brainstorming

```markdown
**Subjects to Discuss**:

1. ✅ Constraint solver algorithm
2. 🚧 Prevention rule validation (CURRENT)
3. ⏳ Weight budget handling

**Resolved Subjects**:

### ✅ Subject 1: Constraint solver algorithm

**Decision**: Use greedy selection with backtracking
**Action Items**:

- [ ] Implement main selection loop
- [ ] Add infinite loop protection
- [ ] Create rich metadata for failures
```

### During Implementation

```markdown
**Implementation - Iteration 4**:

**Action Items**:

- [x] Implement main selection loop
- [x] Add infinite loop protection (MAX_ITERATIONS = 1000)
- [ ] Create rich metadata for failures

**Files Modified**:

- `src/services/Green.ts` - Added generateAffixes() method
```

### Completion

```markdown
##### Iteration 4: Affix Selection ✅ COMPLETE

**Implementation Results**:

- 3 methods implemented (196 lines)
- 8 test cases passing
- Weight budget constraint solver working correctly

**Verification**: All 8 tests passed, partial successes expected (constraint solver limiting overpowered combos)
```

---

## Integration with Slash Commands

This framework is designed to work with slash commands that automate plan file updates.

**Prefix**: All commands use `flow-` prefix to prevent conflicts with other frameworks.

**Total Commands**: 24 commands organized into 6 categories

**Design Principles**:
- ✅ **Consistent Naming**: All separators use hyphens (no underscores)
- ✅ **Symmetric Lifecycle**: Every hierarchy level has add → start → complete
- ✅ **Clear Intent**: Suffix indicates action (`-add`, `-start`, `-complete`)
- ✅ **Auto-Update**: All state-changing commands update Progress Dashboard atomically

---

### 1. Plan Initialization (3 commands)

**Use Case**: Start a new project or migrate existing documentation

- `/flow-blueprint [feature-description]` - **START HERE**: Generate initial PLAN.md with skeleton structure (phases/tasks/iterations). AI will ask for reference implementation, testing methodology, and project constraints.
- `/flow-migrate [file-path]` - Migrate existing PRD/PLAN/TODO to Flow format (creates backup, preserves all content)
- `/flow-plan-update` - Update existing PLAN.md to latest Flow framework structure (moves Progress Dashboard, standardizes markers)

---

### 2. Phase Lifecycle (3 commands)

**Use Case**: Manage top-level project milestones (e.g., "Foundation", "Core Implementation", "Testing")

**Symmetric Triplet** (create → start → complete):
- `/flow-phase-add [description]` - Create new phase structure in PLAN.md
- `/flow-phase-start` - Mark current phase as 🚧 IN PROGRESS (when first task starts)
- `/flow-phase-complete` - Mark current phase as ✅ COMPLETE (when all tasks done, auto-advances to next phase)

**Why Symmetric?** Users need explicit control over phase boundaries. "Adding" a phase doesn't mean you're ready to start it.

---

### 3. Task Lifecycle (3 commands)

**Use Case**: Manage work units within a phase (e.g., "Database Schema", "API Endpoints", "Error Handling")

**Symmetric Triplet** (create → start → complete):
- `/flow-task-add [description]` - Create new task structure under current phase
- `/flow-task-start` - Mark current task as 🚧 IN PROGRESS (when first iteration starts)
- `/flow-task-complete` - Mark current task as ✅ COMPLETE (when all iterations done, auto-advances to next task)

**Why Symmetric?** Tasks are work units that need clear start/end boundaries, not just structure.

---

### 4. Iteration Lifecycle (6 commands)

**Use Case**: Build a single feature increment through brainstorming → implementation

**Symmetric Lifecycle** (create → design → build → complete):
- `/flow-iteration-add [description]` - Create new iteration structure under current task

**Brainstorming Phase** (design before code):
- `/flow-brainstorm-start [topic]` - Begin brainstorming session, mark iteration as 🚧 IN PROGRESS (brainstorming)
- `/flow-brainstorm-subject [name]` - Add new subject to discuss during brainstorming
- `/flow-brainstorm-resolve [subject-name]` - Mark subject as resolved with decision (Type A: pre-task, Type B: documentation, Type C: auto-resolved)
- `/flow-brainstorm-complete` - Close brainstorming, mark iteration as 🎨 READY FOR IMPLEMENTATION (only after pre-tasks done)

**Implementation Phase** (build the code):
- `/flow-implement-start` - Begin implementation, mark iteration as 🚧 IN PROGRESS (implementing)
- `/flow-implement-complete` - Mark iteration as ✅ COMPLETE, auto-advance to next iteration

**Why Two Phases?** Flow's core value is "design before code" - brainstorming must be distinct from implementation.

---

### 5. Navigation Commands (3 commands)

**Use Case**: Find your way through the plan, understand what's next

**Consistent Pattern** - `/flow-next-X` shows details about next X in sequence:

- `/flow-next` - **Smart universal navigator**: Analyzes PLAN.md state and suggests appropriate next command
  - "What should I do next?" → Context-aware suggestion
  - If iteration is ⏳ → suggests `/flow-brainstorm-start`
  - If iteration is 🎨 → suggests `/flow-implement-start`
  - If iteration is ✅ → suggests next iteration or `/flow-iteration-add`

- `/flow-next-subject` - **Brainstorming navigator**: Shows next unresolved subject (⏳) in current brainstorming session
  - "What subject should I discuss next?" → Displays subject name + description
  - Specific to brainstorming phase

- `/flow-next-iteration` - **Task navigator**: Shows next pending iteration (⏳) in current task
  - "What iteration should I work on next?" → Displays iteration goal + approach
  - Helps user understand upcoming work

**Relationship**: Work together - run `/flow-next` for suggestion → run `/flow-next-iteration` for details

---

### 6. Status & Validation (5 commands)

**Use Case**: Understand project state, verify accuracy, manage context

- `/flow-status` - Show current position (phase → task → iteration → status) + verify Progress Dashboard consistency
  - Smart verification: skips ✅ COMPLETE items (verified & frozen), only checks active work
  - Suggests next action based on current status

- `/flow-summarize` - Generate high-level overview of entire project structure (all phases/tasks/iterations)
  - Bird's eye view with completion percentages
  - Compact format showing completed vs pending work
  - Useful for status reports and V1/V2 planning

- `/flow-verify-plan` - Verify PLAN.md is synchronized with actual codebase state
  - Checks if completed action items actually exist in code
  - Identifies unreported work (modified files not in PLAN)
  - Run before compacting or starting new session

- `/flow-compact` - Generate comprehensive context transfer report for new AI session
  - Zero context loss handoff
  - Includes decisions, progress, challenges, next steps
  - Critical for conversation continuity

- `/flow-rollback` - Undo last change to PLAN.md (limited to one step)
  - Emergency undo for accidental changes
  - Uses changelog to identify last change

---

## Command Usage Flow

**Typical workflow for a new iteration**:

```
1. /flow-iteration-add "Feature name"
2. /flow-brainstorm-start "Feature design"
3. /flow-brainstorm-subject "Architecture decision"
4. /flow-brainstorm-resolve "Architecture decision"
   (repeat subjects as needed)
5. Complete pre-implementation tasks (if any from Type A resolutions)
6. /flow-brainstorm-complete
7. /flow-implement-start
8. Work through action items, check off as complete
9. /flow-implement-complete
10. /flow-status (verify and move to next iteration)
```

**Helper commands at any time**:
- `/flow-status` - Where am I?
- `/flow-next` - What should I do?
- `/flow-next-iteration` - What's coming next?

---

## Command Design Rationale

**Why 24 commands instead of fewer?**
- Explicit is better than implicit - users want clear control
- Symmetric naming is predictable and discoverable
- Each command has single responsibility (no overloading)

**Why hyphens instead of underscores?**
- Standard in CLI tools (kubectl, docker, gh, npm)
- Consistent with existing Flow commands
- Easier to type and read

**Why `-add` suffix for structure commands?**
- Makes intent crystal clear ("I'm creating new structure, not starting work")
- Distinguishes from `-start` (begin work) and `-complete` (finish work)
- Eliminates confusion about command purpose

**Why auto-update Progress Dashboard?**
- Dashboard is "mission control" - must NEVER be stale
- Manual updates lead to inconsistency
- Real-time state is core Flow promise

---

See `.claude/commands/` for complete slash command implementations.

---

## Summary

This framework provides:

✅ **Structure** - Clear hierarchy from phases to action items
✅ **Context** - Plan file preserves all decisions and progress
✅ **Flexibility** - Iterations can be any size, versions defer complexity
✅ **Traceability** - Complete audit trail of what/why/how
✅ **Resumability** - Anyone (human or AI) can pick up where you left off
✅ **Quality** - Brainstorming before coding reduces refactoring
✅ **Simplicity** - Simple loop: brainstorm → implement → complete → repeat

By following this framework, you build complex features incrementally with minimal refactoring, complete documentation, and clear progress tracking.

---

**Version**: 1.0.9
**Last Updated**: 2025-10-02
FRAMEWORK_DATA_EOF
}

get_example_content() {
  cat <<'EXAMPLE_DATA_EOF'
# Payment Gateway Integration - Development Plan

> **📖 Framework Guide**: See DEVELOPMENT_FRAMEWORK.md for complete methodology and patterns used in this plan
>
> **🎯 Purpose**: This is a reference example showing the Flow framework in action - demonstrating brainstorming sessions, iterations, pre-implementation tasks, bug discoveries, and state tracking

**Created**: 2025-10-01
**Version**: V1
**Plan Location**: `.flow/PLAN.md` (managed by Flow)

---

## Overview

**Purpose**: Integrate a third-party payment gateway (MockPay) into our e-commerce platform to enable secure online transactions.

**Goals**:
- Enable credit card payments through MockPay API
- Implement webhook handling for payment status updates
- Add payment retry logic for failed transactions
- Ensure PCI compliance for sensitive data handling

**Scope**:
- **Included**: MockPay integration, basic error handling, webhook system, transaction logging
- **Excluded**: Multiple payment providers (V2), saved payment methods (V2), subscription billing (V3)

---

## 📋 Progress Dashboard

**Last Updated**: 2025-10-01

**Current Work**:
- **Phase**: Phase 1 - Foundation → [Jump](#phase-1-foundation-)
- **Task**: Task 1 - Setup & API Integration → [Jump](#task-1-setup--api-integration-)
- **Iteration**: Iteration 2 - Basic Payment Flow → [Jump](#iteration-2-basic-payment-flow-)

**Completion Status**:
- Phase 1: 🚧 50% | Phase 2: ⏳ 0% | Phase 3: ⏳ 0%

**Progress Overview**:
- ✅ **Iteration 1**: Project Setup & SDK Integration (verified & frozen)
- 🚧 **Iteration 2**: Basic Payment Flow ← **YOU ARE HERE**
- ⏳ **Iteration 3-5**: Webhook system, error handling, testing

**V1 Remaining Work**:
1. Complete Iteration 2 (basic payment flow)
2. Implement Iteration 3 (webhook system)
3. Implement Iteration 4 (error handling)
4. Phase 2: Advanced features
5. Phase 3: Testing & polish

**V2 Deferred Items**:
1. Task 6: Multiple Payment Providers (complexity - abstraction layer needed)
2. Task 7: Saved Payment Methods (out of V1 scope - security considerations)
3. Task 8: Subscription Billing (V3 - recurring payments infrastructure)

**Cancelled Items**:
None

---

## Architecture

**High-Level Design**:
- Service-oriented architecture with dedicated `PaymentService`
- Webhook processor as separate background job
- Transaction state machine for payment lifecycle management
- Event-driven notifications for payment status changes

**Key Components**:
1. **PaymentService** - Core payment processing logic
2. **MockPayAdapter** - Third-party API integration layer
3. **WebhookProcessor** - Handles async payment notifications
4. **TransactionRepository** - Persists payment records
5. **PaymentEventEmitter** - Publishes payment events to message bus

**Dependencies**:
- MockPay Node.js SDK (v3.2.1)
- Express.js for webhook endpoints
- Redis for webhook deduplication
- PostgreSQL for transaction storage

---

## Testing Strategy

**Methodology**: Integration tests + Manual QA

**Approach**:
- **Integration Tests**: Created after each iteration using Jest
- **Location**: `tests/integration/payment/` directory
- **Naming Convention**: `{feature}.integration.test.ts` (e.g., `payment-creation.integration.test.ts`)
- **When to create**: After iteration implementation complete and working, if test file doesn't exist
- **When to add**: If test file already exists for the feature, add new test cases to existing file
- **Coverage**: Focus on happy path + critical error cases (insufficient funds, network errors, webhook failures)
- **Manual QA**: Final end-to-end verification in staging environment before deployment

**Test Execution**:
```bash
npm run test:integration                 # Run all integration tests
npm run test:integration:payment         # Payment tests only
```

**File Structure**:
```
tests/integration/payment/
├── payment-creation.integration.test.ts       # Payment creation tests
├── webhook-handling.integration.test.ts       # Webhook tests
└── payment-retry.integration.test.ts          # Retry logic tests (create if new feature)
```

**Verification Per Iteration**:
Each iteration's "Verification" section will include:
1. Integration test file created (if new feature) or updated (if enhancement)
2. Test cases passing (list specific scenarios)
3. Manual QA checklist (if applicable)

**IMPORTANT**:
- ✅ Create `tests/integration/payment/new-feature.integration.test.ts` for new features
- ✅ Add test cases to existing files for enhancements to existing features
- ❌ Do NOT create tests before implementation (we write tests after code works)
- ❌ Do NOT create unit tests (focus on integration tests only)

**Why This Approach**:
- Integration tests catch real API interaction issues
- Writing tests after implementation allows for faster prototyping
- Manual QA ensures user experience quality before production

---

## Development Plan

### Phase 1: Foundation 🚧

**Status**: IN PROGRESS
**Started**: 2025-10-01
**Completed**: (in progress)

**Strategy**: Set up core infrastructure and basic payment flow

**Goal**: Enable simple payment processing without advanced features

---

#### Task 1: Setup & API Integration ✅

**Status**: COMPLETE
**Completed**: 2025-10-01
**Purpose**: Establish connection to MockPay and implement basic payment creation

---

##### Iteration 1: Project Setup & SDK Integration ✅

**Status**: COMPLETE
**Completed**: 2025-10-01
**Goal**: Install dependencies and configure MockPay credentials

---

### **Brainstorming Session - API Setup** ✅

**Status**: COMPLETE

**Subjects to Discuss**:

1. ✅ **Credential Management** - RESOLVED
2. ✅ **SDK vs Raw HTTP** - RESOLVED
3. ✅ **Environment Configuration** - RESOLVED
4. ❌ **Custom HTTP Client** - REJECTED (SDK is sufficient)

**Resolved Subjects**:

---

### ✅ **Subject 1: Credential Management**

**Decision**: Use environment variables with .env file + secret manager in production

**Rationale**:
- Industry standard approach (12-factor app)
- Easy to rotate credentials without code changes
- Prevents accidental commits of secrets to git
- Integrates well with deployment pipelines

**Options Considered**:
- **Option A**: Hardcoded in config files ❌ REJECTED (security risk)
- **Option B**: Environment variables ✅ CHOSEN
- **Option C**: Database configuration ❌ REJECTED (chicken-egg problem for DB credentials)

**Action Items**:
- [x] Add `MOCKPAY_API_KEY` and `MOCKPAY_SECRET` to .env.example
- [x] Create .env file and add to .gitignore
- [x] Document credential setup in README.md
- [x] Add validation on startup to ensure credentials are present

---

### ✅ **Subject 2: SDK vs Raw HTTP**

**Decision**: Use official MockPay SDK for V1, abstract behind adapter pattern

**Rationale**:
- SDK handles authentication, retries, and rate limiting automatically
- Reduces development time for V1
- Adapter pattern allows swapping to custom HTTP client later if needed
- SDK is well-maintained (last updated 2 weeks ago)

**Options Considered**:
- **Option A**: Raw HTTP with axios ❌ REJECTED (reinventing the wheel)
- **Option B**: Official SDK with adapter pattern ✅ CHOSEN
- **Option C**: Third-party wrapper library ❌ REJECTED (adds extra dependency)

**Action Items**:
- [x] Install `@mockpay/node-sdk@3.2.1`
- [x] Create `MockPayAdapter` class implementing `PaymentGatewayInterface`
- [x] Add TypeScript types for adapter methods
- [x] Write unit tests for adapter initialization

---

### ✅ **Subject 3: Environment Configuration**

**Decision**: Use NODE_ENV with separate .env files per environment

**Rationale**:
- Clear separation of concerns
- Standard Node.js convention
- Easy to understand for new developers
- Works well with CI/CD pipelines

**Action Items**:
- [x] Create .env.development, .env.staging, .env.production templates
- [x] Add dotenv-flow package for automatic env file loading
- [x] Document environment setup in CONTRIBUTING.md

---

### ❌ **Subject 4: Custom HTTP Client**

**Status**: REJECTED

**Reason**: Building custom HTTP client would duplicate functionality already provided by MockPay SDK. SDK handles authentication, retry logic with exponential backoff, rate limiting, and request signing automatically. Reimplementing these features would be time-consuming and error-prone.

**Decision**: Use MockPay SDK (Subject 2) instead. If custom HTTP implementation is needed later (e.g., for performance optimization or multi-provider abstraction), it can be added in V2 behind the existing adapter interface.

**Rejected on**: 2025-10-01

---

### **Implementation - Iteration 1** ✅

**Status**: COMPLETE
**Completed**: 2025-10-01

**Action Items**:
- [x] Add MOCKPAY_API_KEY and MOCKPAY_SECRET to .env.example
- [x] Create .env file and add to .gitignore
- [x] Document credential setup in README.md
- [x] Add validation on startup to ensure credentials are present
- [x] Install @mockpay/node-sdk@3.2.1
- [x] Create MockPayAdapter class implementing PaymentGatewayInterface
- [x] Add TypeScript types for adapter methods
- [x] Write unit tests for adapter initialization
- [x] Create .env.development, .env.staging, .env.production templates
- [x] Add dotenv-flow package for automatic env file loading
- [x] Document environment setup in CONTRIBUTING.md

**Implementation Notes**:

Discovered that MockPay SDK has a sandbox mode that can be enabled via flag, added `MOCKPAY_SANDBOX=true` to development environment. This will prevent accidental charges during testing.

Also added a health check endpoint `/api/payment/health` that verifies API connectivity without making actual requests.

**Files Modified**:
- `package.json` - Added mockpay SDK and dotenv-flow dependencies
- `src/config/mockpay.ts` - Created configuration loader with validation
- `src/adapters/MockPayAdapter.ts` - Implemented adapter class (127 lines)
- `src/types/PaymentGateway.ts` - Defined interface for payment gateways
- `tests/unit/MockPayAdapter.test.ts` - Added 8 test cases
- `.env.example` - Documented required environment variables
- `.gitignore` - Added .env* to ignore list
- `README.md` - Added setup instructions
- `CONTRIBUTING.md` - Documented environment configuration

**Verification**: All 8 unit tests passing. Successfully connected to MockPay sandbox environment and retrieved account details.

**Completed**: 2025-10-01

---

##### Iteration 2: Payment Creation Flow 🚧 IN PROGRESS

**Status**: IN PROGRESS
**Goal**: Implement API endpoints and service methods to create payment intents

---

### **Brainstorming Session - Payment Flow Design**

**Subjects to Discuss**:

1. ✅ **API Endpoint Structure** - RESTful design for payment operations
2. ✅ **Payment State Machine** - Lifecycle management (pending → processing → complete)
3. 🚧 **Error Handling Strategy** - How to handle API failures gracefully (CURRENT)
4. ⏳ **Idempotency Keys** - Preventing duplicate charges

**Resolved Subjects**:

---

### ✅ **Subject 1: API Endpoint Structure**

**Decision**: Use REST with POST /api/payments to create payment intents

**Rationale**:
- Standard RESTful convention (POST = create resource)
- Returns payment intent ID that frontend can use with SDK
- Separation of concerns: backend creates intent, frontend confirms
- Aligns with MockPay's recommended integration pattern

**Options Considered**:
- **Option A**: Single endpoint `/api/pay` that does everything ❌ REJECTED (too much coupling)
- **Option B**: POST `/api/payments` to create intent, PUT `/api/payments/:id/confirm` to complete ✅ CHOSEN
- **Option C**: GraphQL mutation ❌ REJECTED (overkill for V1)

**Action Items**:
- [x] Define OpenAPI spec for POST /api/payments
- [x] Create Express router for payment endpoints
- [x] Add request validation middleware (amount, currency, metadata)
- [x] Implement PaymentService.createPaymentIntent() method

---

### ✅ **Subject 2: Payment State Machine**

**Decision**: Use enum-based state machine with explicit transitions

**Rationale**:
- Makes valid state transitions explicit and enforceable
- Easier to debug payment issues by examining state history
- Prevents invalid state transitions (e.g., pending → refunded without complete)
- Foundation for future workflow features (partial refunds, disputes)

**States**: `PENDING → PROCESSING → COMPLETED | FAILED | CANCELLED`

**Transitions**:
```
PENDING → PROCESSING (payment initiated)
PROCESSING → COMPLETED (payment succeeded)
PROCESSING → FAILED (payment declined)
PENDING → CANCELLED (user cancelled)
COMPLETED → REFUNDING → REFUNDED (future V2)
```

**Action Items**:
- [x] Create PaymentStatus enum with all states
- [x] Define state transition validation function
- [x] Add created_at, updated_at, status_changed_at timestamps
- [x] Create database migration for payment_transactions table

---

### 🚧 **Subject 3: Error Handling Strategy** (CURRENT)

**Decision**: [To be resolved]

**Discussion in progress...**

Options being considered:
- **Option A**: Return generic errors to frontend, log details server-side
- **Option B**: Return detailed error codes that frontend can map to user messages
- **Option C**: Return both error code + safe message

Need to decide:
- How much detail to expose to frontend?
- What error codes do we need? (INSUFFICIENT_FUNDS, CARD_DECLINED, NETWORK_ERROR, etc.)
- Should we retry automatically or let user retry?

---

### **Pre-Implementation Tasks:**

#### ✅ Task 1: Refactor Config Module (COMPLETED)

**Objective**: Current config module doesn't support nested configuration objects. Need to refactor before adding payment config.

**Changes Made**:
- Migrated from flat key-value config to hierarchical structure
- Updated all existing services to use new config.get() API
- Added TypeScript interfaces for type-safe config access
- Updated 23 test files to use new config structure

**Verification**: All existing tests passing (187/187). No breaking changes in other services.

---

#### ⏳ Task 2: Add Request ID Middleware (PENDING)

**Objective**: Need request ID tracking for debugging payment flows across services

**Action Items**:
- [ ] Install express-request-id package
- [ ] Add middleware to Express app
- [ ] Update logger to include request ID in all log entries
- [ ] Update existing payment logging to use request ID

---

### **Implementation - Iteration 2**

**Status**: 🚧 IN PROGRESS

**Action Items**:
- [x] Define OpenAPI spec for POST /api/payments
- [x] Create Express router for payment endpoints
- [x] Add request validation middleware
- [x] Implement PaymentService.createPaymentIntent() method
- [x] Create PaymentStatus enum
- [x] Define state transition validation function
- [x] Add timestamps to transaction model
- [x] Create database migration
- [ ] Resolve error handling strategy
- [ ] Implement error handling in service layer
- [ ] Add integration tests for payment creation
- [ ] Update API documentation

**Implementation Notes**:

Created basic payment creation flow. Currently works for happy path (successful payment creation). Need to finalize error handling strategy before implementing failure cases.

**🚨 Scope Boundary Example** (Discovery during implementation):

While implementing payment validation middleware, I discovered that the existing `UserAuth.validateToken()` function has a bug - it doesn't check token expiration correctly.

**What I did**:
1. **STOPPED** implementation immediately
2. **NOTIFIED** user: "Found bug in UserAuth.validateToken() - doesn't check expiration. This is NOT part of Iteration 2 (payment flow). Should I: (A) Add as new brainstorming subject for next iteration, (B) Create pre-implementation task, (C) Fix now?"
3. **WAITED** for user decision
4. User chose: "Create pre-implementation task - we need it fixed before webhooks (Iteration 3)"
5. **CREATED** Pre-Implementation Task 3: "Fix UserAuth Token Expiration Bug"

**Why this matters**: If I had "helpfully" fixed the auth bug immediately, it would have:
- Added untracked changes to this iteration
- Made code review confusing ("why are auth changes in payment PR?")
- Potentially broken authentication for other services
- Violated Flow's principle of intentional, scoped changes

**Result**: Bug documented, will be fixed in proper scope, Iteration 2 stays focused on payment flow.

**Files Modified**:
- `src/routes/payment.routes.ts` - Payment API routes (78 lines)
- `src/services/PaymentService.ts` - Core service logic (143 lines, partial)
- `src/types/PaymentStatus.ts` - State machine enum and validation
- `migrations/002_create_payment_transactions.sql` - Database schema
- `docs/api/openapi.yaml` - API specification

**Verification**: Manual testing in Postman shows successful payment creation. Automated tests pending error handling decisions.

---

##### Iteration 3: Error Handling & Validation ⏳

**Status**: PENDING
**Goal**: Implement comprehensive error handling for payment failures

---

#### Task 2: Webhook Integration ⏳

**Status**: PENDING
**Purpose**: Handle asynchronous payment status updates from MockPay

---

##### Iteration 1: Webhook Endpoint & Signature Verification ⏳

**Status**: PENDING
**Goal**: Create secure webhook receiver endpoint

---

##### Iteration 2: Webhook Processing & Event Emission ⏳

**Status**: PENDING
**Goal**: Process webhook payloads and emit internal events

---

##### Iteration 3: Webhook Retry & Deduplication ⏳

**Status**: PENDING
**Goal**: Handle webhook delivery guarantees and prevent duplicate processing

---

### Phase 2: Core Implementation ⏳

**Strategy**: Build out remaining payment features and edge cases

**Goal**: Production-ready payment system with monitoring and logging

---

#### Task 1: Transaction Logging & Audit Trail ⏳

**Status**: PENDING
**Purpose**: Complete audit trail of all payment operations for compliance

---

#### Task 2: Payment Retry Logic ⏳

**Status**: PENDING
**Purpose**: Automatic retry for transient failures

---

### Phase 3: Testing & Validation ⏳

**Strategy**: Comprehensive testing across all scenarios

**Goal**: Confidence in production deployment

---

#### Task 1: Integration Tests ⏳

**Status**: PENDING
**Purpose**: End-to-end tests with MockPay sandbox

---

#### Task 2: Load Testing ⏳

**Status**: PENDING
**Purpose**: Verify system handles production traffic volumes

---

### Phase 4: Enhancement & Polish 🔮 FUTURE

**Strategy**: V2 features and optimizations

**Goal**: Advanced payment features for better UX

**Deferred Tasks**:
- Multiple payment provider support (Stripe, PayPal)
- Saved payment methods / tokenization
- Recurring billing / subscriptions
- Partial refunds
- Payment disputes handling
- Advanced fraud detection

---

## Testing Strategy

**V1 Testing**:
- [x] Unit tests for adapter layer (8 tests)
- [x] Unit tests for state machine (5 tests)
- [ ] Integration tests for payment creation flow
- [ ] Integration tests for webhook processing
- [ ] Manual testing with MockPay test cards
- [ ] Security audit of credential handling

**V2 Testing** (Deferred):
- [ ] Load tests (1000 concurrent payments)
- [ ] Chaos engineering tests (simulate API downtime)
- [ ] PCI compliance validation

---

## Future Enhancements (V2+)

**Phase 4: Enhancement & Polish** (FUTURE)

**Deferred Features**:
- [ ] Multi-provider support (Stripe, PayPal, etc.)
- [ ] Saved payment methods with tokenization
- [ ] Subscription billing engine
- [ ] Partial and split refunds
- [ ] Payment dispute management
- [ ] ML-based fraud detection
- [ ] Apple Pay / Google Pay integration
- [ ] International payment methods (Alipay, WeChat Pay)

---

## Notes & Learnings

**Design Decisions**:
- **Adapter pattern for gateway**: Allows swapping payment providers in V2 without rewriting business logic
- **State machine for payments**: Explicit transitions prevent invalid states and make debugging easier
- **Sandbox mode by default**: Discovered during implementation, prevents accidental charges in dev

**Challenges Encountered**:
- **Config refactoring needed**: Had to refactor config module before adding payment config (added as pre-implementation task)
- **MockPay SDK quirks**: SDK requires explicit sandbox flag, not documented clearly in their main guide

**Improvements Over Original** (if refactoring):
- N/A - This is a new feature implementation

---

## Changelog

**2025-10-01** - Phase 1, Task 1, Iteration 1 complete
- Implemented MockPay SDK integration
- Created adapter pattern for payment gateway
- Set up environment configuration
- Added 8 unit tests for adapter layer
- Discovered sandbox mode feature

**2025-10-01** - Phase 1, Task 1, Iteration 2 in progress
- Started brainstorming session for payment flow
- Resolved API endpoint structure (RESTful)
- Resolved payment state machine design
- Created database schema migration
- Completed pre-implementation task: config refactoring
- Currently resolving error handling strategy
- Implemented basic payment creation endpoint (happy path only)

---

**Next Steps**:
- Complete brainstorming for error handling strategy
- Finish Iteration 2 implementation
- Move to Iteration 3: Error handling & validation
EXAMPLE_DATA_EOF
}

deploy_commands() {
  local target_dir="$1"
  local force="$2"
  local success_count=0

  # If force mode, clean up deprecated commands first
  if [ "$force" = true ]; then
    echo -e "${CYAN}🧹 Cleaning deprecated commands...${NC}"
    for deprecated_cmd in "${DEPRECATED_COMMANDS[@]}"; do
      local deprecated_file="$target_dir/${deprecated_cmd}.md"
      if [ -f "$deprecated_file" ]; then
        rm -f "$deprecated_file"
        echo -e "${YELLOW}🗑️  Removed deprecated: ${deprecated_cmd}.md${NC}"
      fi
    done
    echo ""
  fi

  for cmd in "${COMMANDS[@]}"; do
    local cmd_file="$target_dir/${cmd}.md"

    # If force mode, delete existing file first to ensure clean write
    if [ "$force" = true ] && [ -f "$cmd_file" ]; then
      rm -f "$cmd_file"
    fi

    [ -f "$cmd_file" ] && [ "$force" = false ] && { echo -e "${YELLOW}⏭️  Skip ${cmd}.md${NC}"; continue; }

    local content=$(extract_command "$cmd")
    [ -z "$content" ] && { echo -e "${RED}❌ Failed ${cmd}${NC}"; continue; }

    echo "$content" > "$cmd_file" && { echo -e "${GREEN}✅ ${cmd}.md${NC}"; ((success_count++)); } || echo -e "${RED}❌ ${cmd}.md${NC}"
  done

  echo "$success_count"
}

deploy_framework() {
  local target_dir="$1"
  local force="$2"
  local framework_file="$target_dir/DEVELOPMENT_FRAMEWORK.md"
  local example_file="$target_dir/EXAMPLE_PLAN.md"

  # If force mode, delete existing files first to ensure clean write
  if [ "$force" = true ]; then
    [ -f "$framework_file" ] && rm -f "$framework_file"
    [ -f "$example_file" ] && rm -f "$example_file"
  fi

  # Deploy framework guide
  if [ -f "$framework_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip DEVELOPMENT_FRAMEWORK.md${NC}"
  else
    get_framework_content > "$framework_file" && echo -e "${GREEN}✅ DEVELOPMENT_FRAMEWORK.md${NC}" || { echo -e "${RED}❌ Framework${NC}"; return 1; }
  fi

  # Deploy example plan
  if [ -f "$example_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip EXAMPLE_PLAN.md${NC}"
  else
    get_example_content > "$example_file" && echo -e "${GREEN}✅ EXAMPLE_PLAN.md${NC}" || { echo -e "${RED}❌ Example${NC}"; return 1; }
  fi

  return 0
}

validate() {
  local commands_dir="$1"
  local flow_dir="$2"
  local valid=true

  echo -e "\n${CYAN}🔍 Validating...${NC}\n"

  # Check framework
  [ ! -f "$flow_dir/DEVELOPMENT_FRAMEWORK.md" ] && { echo -e "${RED}❌ Framework missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Framework${NC}"

  # Check example
  [ ! -f "$flow_dir/EXAMPLE_PLAN.md" ] && { echo -e "${RED}❌ Example missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Example${NC}"

  # Check commands
  local count=0
  for cmd in "${COMMANDS[@]}"; do
    [ -f "$commands_dir/${cmd}.md" ] && ((count++))
  done

  echo -e "${GREEN}✅ Commands: $count/${#COMMANDS[@]}${NC}"
  [ "$count" -eq 0 ] && { echo -e "${RED}❌ No commands${NC}"; valid=false; }

  [ "$valid" = true ]
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) FORCE=true; shift;;
      --version|-v) print_version; exit 0;;
      --help|-h) print_help; exit 0;;
      *) echo -e "${RED}Unknown: $1${NC}"; print_help; exit 1;;
    esac
  done

  echo -e "\n${BLUE}🚀 Flow Framework v$FLOW_VERSION${NC}\n"
  echo -e "Target Project: ${BLUE}$(pwd)${NC}"
  echo -e "Force: $([ "$FORCE" = true ] && echo "${GREEN}Yes${NC}" || echo "${RED}No${NC}")"
  echo -e "Mode: ${CYAN}Self-contained${NC}\n"

  local commands_dir="$(pwd)/.claude/commands"
  local flow_dir="$(pwd)/.flow"

  # Create directories
  mkdir -p "$commands_dir" || { echo -e "${RED}❌ mkdir .claude/commands failed${NC}"; exit 1; }
  mkdir -p "$flow_dir" || { echo -e "${RED}❌ mkdir .flow failed${NC}"; exit 1; }
  echo -e "${BLUE}📁 Created directories${NC}\n"

  # Deploy slash commands
  echo -e "${BLUE}📦 Installing slash commands...${NC}\n"
  local count=$(deploy_commands "$commands_dir" "$FORCE")

  # Deploy framework docs
  echo -e "\n${BLUE}📚 Installing framework documentation...${NC}\n"
  deploy_framework "$flow_dir" "$FORCE"

  # Validate
  if validate "$commands_dir" "$flow_dir"; then
    echo ""
    echo "=================================================="
    echo -e "${GREEN}✅ Flow Framework Installed!${NC}\n"
    echo -e "${CYAN}📂 Structure:${NC}"
    echo "   .claude/commands/       (20 slash commands)"
    echo "   .flow/                  (framework docs)"
    echo "     ├── DEVELOPMENT_FRAMEWORK.md"
    echo "     └── EXAMPLE_PLAN.md"
    echo ""
    echo -e "${CYAN}🚀 Next Steps:${NC}"
    echo "   1. Restart Claude Code (if running)"
    echo "   2. Run: /flow-blueprint <your-feature-name>"
    echo "   3. Read: .flow/DEVELOPMENT_FRAMEWORK.md"
    echo "   4. Reference: .flow/EXAMPLE_PLAN.md"
    echo ""
    echo "💡 Share this script - it's self-contained!"
    echo "=================================================="
    echo ""
    exit 0
  else
    echo ""
    echo -e "${YELLOW}⚠️  Deployment completed with warnings${NC}"
    echo ""
    exit 1
  fi
}

main "$@"
