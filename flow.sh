#!/usr/bin/env bash

################################################################################
# Flow Framework Deployment Script
#
# Self-contained script with all framework content embedded.
# Distribute this single file to install the Flow framework.
#
# Generated by build-standalone.sh
################################################################################

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

COMMANDS=(
  "flow-blueprint" "flow-phase" "flow-task" "flow-iteration"
  "flow-brainstorm_start" "flow-brainstorm_subject" "flow-brainstorm_resolve" "flow-brainstorm_complete"
  "flow-implement_start" "flow-implement_complete"
  "flow-status" "flow-next" "flow-next-subject" "flow-next-iteration" "flow-rollback"
)

FORCE=false

print_help() {
  cat <<EOF

Flow Framework Deployment Script

USAGE:
  ./flow.sh [OPTIONS]

OPTIONS:
  --force, -f       Overwrite existing files
  --help, -h        Show this help

DEPLOYMENT STRUCTURE:
  .claude/commands/          Slash commands (15 files)
  .flow/                     Framework documentation
    ├── DEVELOPMENT_FRAMEWORK.md
    └── EXAMPLE_PLAN.md

This script is SELF-CONTAINED - no external files needed!

EOF
}

extract_command() {
  local cmd="$1"
  local marker="## /${cmd}"
  awk -v marker="$marker" '
    $0 ~ marker {found=1; next}
    found && /^```markdown$/ {inside=1; next}
    found && inside && /^```$/ {exit}
    found && inside {print}
  ' <<'COMMANDS_DATA_EOF'
# Flow Framework - Slash Commands

This file contains all slash command definitions for the Flow framework. Copy these to `.claude/commands/` when ready to use.

---

## Command Guidelines

**IMPORTANT**: Every command must:

1. **Read the framework guide** at the start to understand patterns and structure
2. **Find and parse PLAN.md** to understand current state
3. **Follow framework patterns exactly** (status markers, section structure, etc.)
4. **Update PLAN.md** according to framework conventions
5. **Provide clear next steps** to the user

**Framework Location**: `DEVELOPMENT_FRAMEWORK.md` (searches in: `.claude/`, project root, or `~/.claude/flow/`)

**Status Markers** (use consistently):
- ✅ Complete
- ⏳ Pending
- 🚧 In Progress
- 🎨 Ready for Implementation
- ❌ Rejected
- 🔮 Future/Deferred

---

## /flow-blueprint

**File**: `flow-blueprint.md`

```markdown
You are executing the `/flow-blueprint` command from the Flow framework.

**Purpose**: Generate initial PLAN.md file with skeleton structure for a new feature/project/bug/issue.

**Instructions**:

1. **Read the framework guide**:
   - Search for DEVELOPMENT_FRAMEWORK.md in these locations (in order):
     - `.claude/DEVELOPMENT_FRAMEWORK.md`
     - `./DEVELOPMENT_FRAMEWORK.md` (project root)
     - `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
   - Read the first found location
   - Understand the hierarchy: PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION
   - Study the plan file template section
   - Note the status markers and section structure

2. **Analyze the feature request**: `$ARGUMENTS`

3. **Check for reference implementation**:
   - If user mentioned a reference path in arguments, use it
   - Otherwise, ask: "Do you have a reference implementation I should analyze? (Provide path or say 'no')"
   - If reference provided, read and analyze it to inform the planning

4. **Generate PLAN.md** in current directory following the framework template:
   - **Overview section**: Purpose, goals, scope
   - **Architecture section**: High-level design, key components
   - **Development Plan**:
     - Estimate 2-4 phases (Foundation, Core Implementation, Testing, Enhancement/Polish)
     - For each phase: 1-5 tasks
     - For each task: 2-10 iterations (high-level names only)
     - Mark everything as ⏳ PENDING
     - Add placeholder brainstorming sessions (empty subject lists)

5. **Depth**: Medium detail
   - Phase names and strategies
   - Task names and purposes
   - Iteration names only (no brainstorming subjects yet)

6. **Confirm to user**:
   - "Created PLAN.md with [X] phases, [Y] tasks, [Z] iterations"
   - "Use `/flow-status` to see current state"
   - "Use `/flow-brainstorm_start [topic]` to begin first iteration"

**Output**: Create PLAN.md file and confirm creation to user.
```

---

## /flow-phase

**File**: `flow-phase.md`

```markdown
You are executing the `/flow-phase` command from the Flow framework.

**Purpose**: Add a new phase to the current PLAN.md file.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: PLAN.md (current project)

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Verify framework understanding**: Know that phases are top-level milestones (e.g., "Foundation", "Core Implementation", "Testing")

2. **Parse arguments**: `$ARGUMENTS` = phase description

3. **Add new phase section**:
   ```markdown
   ### Phase [N]: [$ARGUMENTS] ⏳

   **Strategy**: [Ask user or infer from description]

   **Goal**: [What this phase achieves]

   ---
   ```

4. **Update PLAN.md**: Append new phase to Development Plan section

5. **Confirm to user**: "Added Phase [N]: [$ARGUMENTS] to PLAN.md"

**Output**: Update PLAN.md with new phase.
```

---

## /flow-task

**File**: `flow-task.md`

```markdown
You are executing the `/flow-task` command from the Flow framework.

**Purpose**: Add a new task to the current phase in PLAN.md.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: PLAN.md (current project)

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse arguments**: `$ARGUMENTS` = task description

3. **Find current phase**: Look for last phase marked ⏳ or 🚧

4. **Add new task section**:
   ```markdown
   #### Task [N]: [$ARGUMENTS] ⏳

   **Status**: PENDING
   **Purpose**: [What this task accomplishes]

   ---
   ```

5. **Update PLAN.md**: Append task under current phase

6. **Confirm to user**: "Added Task [N]: [$ARGUMENTS] to current phase"

**Output**: Update PLAN.md with new task.
```

---

## /flow-iteration

**File**: `flow-iteration.md`

```markdown
You are executing the `/flow-iteration` command from the Flow framework.

**Purpose**: Add a new iteration to the current task in PLAN.md.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse arguments**: `$ARGUMENTS` = iteration description

3. **Find current task**: Look for last task marked ⏳ or 🚧

4. **Add new iteration section**:
   ```markdown
   ##### Iteration [N]: [$ARGUMENTS] ⏳

   **Status**: PENDING
   **Goal**: [What this iteration builds]

   ---
   ```

5. **Update PLAN.md**: Append iteration under current task

6. **Confirm to user**: "Added Iteration [N]: [$ARGUMENTS] to current task. Use `/flow-brainstorm_start [topic]` to begin."

**Output**: Update PLAN.md with new iteration.
```

---

## /flow-brainstorm_start

**File**: `flow-brainstorm_start.md`

```markdown
You are executing the `/flow-brainstorm_start` command from the Flow framework.

**Purpose**: Begin a brainstorming session for the current iteration.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: PLAN.md (current project)
- **Framework Pattern**: See "Brainstorming Session Pattern" section in framework guide

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse arguments**: `$ARGUMENTS` = brainstorming topic

3. **Find current iteration**: Look for last iteration marked ⏳ or 🚧

4. **Update iteration status**: Change to 🚧 IN PROGRESS

5. **Add brainstorming section**:
   ```markdown
   ### **Brainstorming Session - [$ARGUMENTS]**

   **Subjects to Discuss** (tackle one at a time):

   1. ⏳ [Suggest first subject based on iteration goal]

   **Resolved Subjects**:

   ---
   ```

6. **Suggest first subject**: Based on iteration name/goal, suggest an initial subject to discuss

7. **Confirm to user**: "Started brainstorming session: [$ARGUMENTS]. First subject: [subject name]. Use `/flow-brainstorm_subject [name]` to add more subjects."

**Output**: Update PLAN.md with brainstorming section and status change.
```

---

## /flow-brainstorm_subject

**File**: `flow-brainstorm_subject.md`

```markdown
You are executing the `/flow-brainstorm_subject` command from the Flow framework.

**Purpose**: Add a new subject to the current brainstorming session.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse arguments**: `$ARGUMENTS` = subject name and optional brief description

3. **Find current brainstorming session**: Look for "Subjects to Discuss" section

4. **Add subject to list**:
   - Count existing subjects
   - Append: `[N]. ⏳ **[$ARGUMENTS]** - [Brief description if provided]`

5. **Update PLAN.md**: Add subject to "Subjects to Discuss" list

6. **Confirm to user**: "Added Subject [N]: [$ARGUMENTS] to brainstorming session."

**Output**: Update PLAN.md with new subject.
```

---

## /flow-brainstorm_resolve

**File**: `flow-brainstorm_resolve.md`

```markdown
You are executing the `/flow-brainstorm_resolve` command from the Flow framework.

**Purpose**: Mark a brainstorming subject as resolved with a decision.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse arguments**: `$ARGUMENTS` = subject name/number

3. **Find subject**:
   - If number provided, find subject [N]
   - If name provided, find matching subject
   - Default: Find first ⏳ subject (not yet resolved)

4. **Update subject status**: Change ⏳ to ✅ in "Subjects to Discuss" list

5. **Prompt user for details**:
   - "What decision did you make for this subject?"
   - "What's the rationale? (comma-separated reasons)"
   - "What action items resulted? (comma-separated, or 'none')"

6. **Add resolution section** under "Resolved Subjects":
   ```markdown
   ### ✅ **Subject [N]: [Name]**

   **Decision**: [User's decision]

   **Rationale**:
   - [Reason 1]
   - [Reason 2]

   **Action Items**:
   - [ ] [Action item 1]
   - [ ] [Action item 2]

   ---
   ```

7. **Update PLAN.md**: Update subject status and add resolution section

8. **Confirm to user**: "Resolved Subject [N]: [Name]. Use `/flow-brainstorm_subject` to add more, or `/flow-brainstorm_complete` when done."

**Output**: Update PLAN.md with resolved subject.
```

---

## /flow-brainstorm_complete

**File**: `flow-brainstorm_complete.md`

```markdown
You are executing the `/flow-brainstorm_complete` command from the Flow framework.

**Purpose**: Close the current brainstorming session (only after pre-implementation tasks are done).

**IMPORTANT**: Pre-implementation tasks should be documented IN PLAN.md during brainstorming, then completed BEFORE running this command.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Verify all subjects resolved**: Check "Subjects to Discuss" - all should be ✅

3. **Check for pre-implementation tasks**:
   - Look for "### **Pre-Implementation Tasks:**" section in PLAN.md
   - If found:
     - Check if all pre-tasks are marked ✅ COMPLETE
     - If any are ⏳ PENDING or 🚧 IN PROGRESS:
       "Pre-implementation tasks exist but are not complete. Complete them first, then run this command again."
     - If all are ✅ COMPLETE: Proceed to step 4
   - If not found:
     - Ask user: "Are there any pre-implementation tasks that need to be completed before starting the main implementation? (Refactoring, system-wide changes, bug fixes discovered during brainstorming, etc.)"
     - If yes: "Please document pre-implementation tasks in PLAN.md first (see framework guide), complete them, then run this command again."
     - If no: Proceed to step 4

4. **Update iteration status**: Change from 🚧 to 🎨 READY FOR IMPLEMENTATION

5. **Add note**: "**Status**: All brainstorming complete, pre-implementation tasks done, ready for implementation"

6. **Confirm to user**: "Brainstorming session complete. Iteration is now 🎨 READY FOR IMPLEMENTATION. Use `/flow-implement_start` to begin."

**Output**: Update PLAN.md with brainstorming completion status.
```

---

## /flow-implement_start

**File**: `flow-implement_start.md`

```markdown
You are executing the `/flow-implement_start` command from the Flow framework.

**Purpose**: Begin implementation phase for the current iteration.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: PLAN.md (current project)
- **Framework Pattern**: See "Implementation Pattern" section in framework guide
- **Prerequisite**: Brainstorming must be ✅ COMPLETE and all pre-implementation tasks done

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Find current iteration**: Look for iteration marked 🎨 READY FOR IMPLEMENTATION

3. **Verify readiness**:
   - Brainstorming should be marked ✅ COMPLETE
   - All pre-implementation tasks should be ✅ COMPLETE
   - If not ready: Warn user and ask to complete brainstorming first

4. **Update iteration status**: Change from 🎨 to 🚧 IN PROGRESS

5. **Create implementation section**:
   ```markdown
   ### **Implementation - Iteration [N]: [Name]**

   **Status**: 🚧 IN PROGRESS

   **Action Items** (from brainstorming):

   [Copy all unchecked action items from resolved subjects]

   **Implementation Notes**:

   [Leave blank for user to fill during implementation]

   **Files Modified**:

   [Leave blank - will be filled as work progresses]

   **Verification**: [Leave blank - how work will be verified]

   ---
   ```

6. **Confirm to user**: "Implementation started for Iteration [N]. Work through action items and check them off as you complete them. Use `/flow-implement_complete` when done."

**Output**: Update PLAN.md with implementation section and status change.
```

---

## /flow-implement_complete

**File**: `flow-implement_complete.md`

```markdown
You are executing the `/flow-implement_complete` command from the Flow framework.

**Purpose**: Mark the current iteration as complete.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Find current iteration**: Look for iteration marked 🚧 IN PROGRESS

3. **Verify completion**:
   - Check all action items are ✅ checked
   - If unchecked items remain: Ask user "There are unchecked action items. Are you sure you want to mark complete? (yes/no)"

4. **Prompt for verification notes**:
   - "How did you verify this iteration works? (tests, manual checks, etc.)"

5. **Update iteration status**: Change from 🚧 to ✅ COMPLETE

6. **Update implementation section**:
   - Add verification notes
   - Add timestamp

7. **Add completion summary**:
   ```markdown
   **Implementation Results**:
   - [Summarize what was built]
   - [List key accomplishments]

   **Verification**: [User's verification method]

   **Completed**: [Date]
   ```

8. **Check if task/phase complete**:
   - If all iterations in task complete → Mark task ✅
   - If all tasks in phase complete → Mark phase ✅

9. **Confirm to user**: "Iteration [N] marked complete! Use `/flow-iteration [description]` to start next iteration, or `/flow-status` to see current state."

**Output**: Update PLAN.md with completion status and summary.
```

---

## /flow-status

**File**: `flow-status.md`

```markdown
You are executing the `/flow-status` command from the Flow framework.

**Purpose**: Show current position in the plan.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Parse PLAN.md** to extract:
   - Current phase (last phase with ⏳ or 🚧 or 🎨)
   - Current task (last task with ⏳ or 🚧 or 🎨)
   - Current iteration (last iteration with ⏳ or 🚧 or 🎨)
   - Current status emoji and state

3. **Display hierarchy**:
   ```
   📋 Current Status:

   Phase [N]: [Name] [Status]
     └─ Task [N]: [Name] [Status]
         └─ Iteration [N]: [Name] [Status]

   Next Action: [Suggest next command based on status]
   ```

4. **Suggest next action**:
   - If ⏳ PENDING → "Use `/flow-brainstorm_start [topic]` to begin"
   - If 🚧 IN PROGRESS (brainstorming) → "Continue resolving subjects with `/flow-brainstorm_resolve`"
   - If 🎨 READY → "Use `/flow-implement_start` to begin implementation"
   - If 🚧 IN PROGRESS (implementing) → "Work through action items, use `/flow-implement_complete` when done"
   - If ✅ COMPLETE → "Use `/flow-iteration [description]` to start next iteration"

5. **Show progress summary**:
   - Count completed vs total iterations
   - Count completed vs total tasks
   - Show percentage complete

**Output**: Display current status and suggest next action.
```

---

## /flow-next-subject

**File**: `flow-next-subject.md`

```markdown
You are executing the `/flow-next-subject` command from the Flow framework.

**Purpose**: Move to the next unresolved subject in the current brainstorming session.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Find current brainstorming session**: Look for "Subjects to Discuss" section

3. **Find first unresolved subject**: Look for first ⏳ subject in the list

4. **If found**:
   - Display subject name and description
   - Ask: "Ready to resolve this subject? Use `/flow-brainstorm_resolve [subject-name]`"

5. **If all resolved**:
   - Notify: "All subjects resolved! Use `/flow-brainstorm_complete` to finish brainstorming."

6. **Show progress**: "[N] of [Total] subjects resolved"

**Output**: Show next subject to work on.
```

---

## /flow-next-iteration

**File**: `flow-next-iteration.md`

```markdown
You are executing the `/flow-next-iteration` command from the Flow framework.

**Purpose**: Move to the next iteration in the plan.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Find current iteration**: Look for last iteration with any active status (⏳ 🚧 🎨 ✅)

3. **Check if current iteration is complete**:
   - If not ✅ COMPLETE: "Current iteration not complete. Finish it first or use `/flow-iteration` to create a new one."
   - If ✅ COMPLETE: Proceed

4. **Look for next iteration in plan**:
   - Check if there's a next iteration already defined (⏳ PENDING)
   - If found: Display iteration name and ask "Ready to start Iteration [N]: [Name]? Use `/flow-brainstorm_start [topic]`"
   - If not found: "No next iteration defined. Use `/flow-iteration [description]` to create one."

5. **Show progress**: "Iteration [N] of [Total] complete"

**Output**: Show next iteration or prompt to create one.
```

---

## /flow-next

**File**: `flow-next.md`

```markdown
You are executing the `/flow-next` command from the Flow framework.

**Purpose**: Auto-detect current context and suggest the next logical step.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Determine current context**:
   - Check current iteration status (⏳ 🚧 🎨 ✅)
   - Check if in brainstorming session (look for "Subjects to Discuss")
   - Check if in implementation (look for "Action Items")

3. **Suggest next command based on context**:

   **If in brainstorming (🚧)**:
   - "Use `/flow-next-subject` to see next subject to resolve"
   - OR "Use `/flow-brainstorm_complete` if all subjects done"

   **If ready for implementation (🎨)**:
   - "Use `/flow-implement_start` to begin implementation"

   **If implementing (🚧)**:
   - Show unchecked action items count
   - "Complete action items and use `/flow-implement_complete` when done"

   **If iteration complete (✅)**:
   - "Use `/flow-next-iteration` to move to next iteration"

   **If pending (⏳)**:
   - "Use `/flow-brainstorm_start [topic]` to begin this iteration"

4. **Show current status summary**: Brief summary of where you are

**Output**: Suggest appropriate next command based on context.
```

---

## /flow-rollback

**File**: `flow-rollback.md`

```markdown
You are executing the `/flow-rollback` command from the Flow framework.

**Purpose**: Undo the last change made to PLAN.md.

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Check if rollback is possible**:
   - Look for "Changelog" section at bottom of PLAN.md
   - If no recent changes logged: "No recent changes to rollback."

3. **Identify last change**:
   - Parse last entry in Changelog
   - Determine what was changed (phase added, task marked complete, etc.)

4. **Ask for confirmation**:
   - "Last change: [Description of change]. Rollback? (yes/no)"

5. **If confirmed, revert change**:
   - Remove last added section, OR
   - Change status marker back to previous state, OR
   - Uncheck last checked checkbox

6. **Update Changelog**: Add rollback entry

7. **Confirm to user**: "Rolled back: [Description of change]"

**Limitation**: Can only rollback one step at a time. For major reverts, manually edit PLAN.md.

**Output**: Revert last change in PLAN.md.
```

---

## /flow-verify-plan

**File**: `flow-verify-plan.md`

```markdown
You are executing the `/flow-verify-plan` command from the Flow framework.

**Purpose**: Verify that PLAN.md is synchronized with the actual project state.

**Context**:
- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working File**: PLAN.md (current project)
- **Use case**: Run before starting new AI session or compacting conversation to ensure context is accurate

**Instructions**:

1. **Find PLAN.md**: Look in current directory, traverse up if needed

2. **Find current iteration**: Look for iteration marked 🚧 IN PROGRESS or 🎨 READY FOR IMPLEMENTATION

3. **Read current implementation section**:
   - Find "Implementation - Iteration [N]" section
   - Identify all action items
   - Note which items are marked as ✅ complete

4. **Verify claimed completions against actual project state**:
   - For each ✅ completed action item, check if it actually exists:
     - "Create UserAuth.ts" → Verify file exists
     - "Add login endpoint" → Search for login endpoint in code
     - "Update database schema" → Check schema files
   - List any discrepancies found

5. **Check for unreported work**:
   - Look for modified files that aren't mentioned in PLAN.md
   - Check git status (if available) for uncommitted changes
   - Identify files that were changed but not documented

6. **Report findings**:
   ```
   📋 Plan Verification Results:

   ✅ Verified Complete:
   - [List action items that are correctly marked complete]

   ❌ Discrepancies Found:
   - [List action items marked complete but evidence not found]

   📝 Unreported Work:
   - [List files changed but not mentioned in PLAN.md]

   Status: [SYNCHRONIZED / NEEDS UPDATE]
   ```

7. **If discrepancies found**:
   - Ask user: "PLAN.md is out of sync with project state. Update PLAN.md now? (yes/no)"
   - If yes: Update PLAN.md to reflect actual state:
     - Uncheck items that aren't actually done
     - Add notes about files modified
     - Update status markers if needed
   - If no: "Review discrepancies above and update PLAN.md manually."

8. **If synchronized**:
   - "PLAN.md is synchronized with project state. Ready to continue work."

**Manual alternative**:
- Review PLAN.md action items manually
- Check each completed item exists in codebase
- Use `git status` and `git diff` to verify changes
- Update PLAN.md to match reality

**Output**: Verification report and optional PLAN.md updates.
```

---

## Installation Instructions

To use these commands:

1. **Copy individual command files** to `.claude/commands/`:
   ```bash
   mkdir -p .claude/commands
   # Copy each command section above into separate .md files
   # Example: flow-blueprint.md, flow-phase.md, etc.
   ```

2. **Or use the copy-paste method**:
   - Copy the content between the code blocks for each command
   - Create corresponding `.md` files in `.claude/commands/`
   - File names should match command names (e.g., `flow-blueprint.md`)

3. **Test with `/help`**: Run `/help` in Claude Code to see your new commands listed

---

## Command Execution Flow

```
/flow-blueprint
    ↓
Creates PLAN.md with skeleton
    ↓
/flow-brainstorm_start
    ↓
/flow-brainstorm_subject (repeat as needed)
    ↓
/flow-brainstorm_resolve (for each subject)
    ↓
Complete pre-implementation tasks (if any)
    ↓
/flow-brainstorm_complete
    ↓
/flow-implement_start
    ↓
Work through action items (check them off)
    ↓
/flow-implement_complete
    ↓
Repeat for next iteration
```

**Helper commands** available at any time:
- `/flow-status` - Check current position
- `/flow-next` - Auto-advance to next step
- `/flow-rollback` - Undo last change
- `/flow-phase`, `/flow-task`, `/flow-iteration` - Add structure as needed

---

**Version**: 1.0
**Last Updated**: 2025-10-01
COMMANDS_DATA_EOF
}

get_framework_content() {
  cat <<'FRAMEWORK_DATA_EOF'
**Version**: 1.0

# Domain-Driven Design with Agile Iterative Philosophy

**A spec-driven iterative development framework for building complex features with minimal refactoring.**

---

## Philosophy

This framework combines **Domain-Driven Design** principles with an **Agile iterative approach** to software development. The core analogy is building the human body:

1. **Skeleton first** - Create the basic structure and foundational components
2. **Add veins** - Implement core data flow and connections
3. **Add flesh** - Layer on complexity incrementally
4. **Add fibers** - Refine and optimize

By splitting development into minuscule, well-planned iterations, you build a strong foundation and expand complexity over time while keeping refactoring to a minimum.

---

## Core Principles

### 1. Plan File as Single Source of Truth

- Every feature/project/issue has a dedicated `PLAN.md` file
- The plan file survives across sessions and maintains complete context
- All decisions, brainstorming results, and implementation progress are documented
- AI agents and humans can resume work from any point by reading the plan

### 2. Iterative Development Loop

```
PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION → COMPLETE
                   ↓           ↓              ↓
               (repeat)   (subjects)    (action items)
```

### 3. Progressive Disclosure

- Each iteration focuses ONLY on what's needed NOW
- Future complexity is deferred to V2/V3/etc.
- Prevents scope creep and over-engineering

### 4. State Preservation

- Every step updates the plan file with checkboxes (✅ ⏳ 🚧)
- Timestamps and status markers track progress
- Complete audit trail of all decisions

### 5. Minimal Refactoring

- Brainstorm BEFORE implementing to make correct decisions upfront
- Split complex features into small, testable iterations
- Each iteration is complete and stable before moving to next

---

## Framework Structure

### Hierarchy

```
📋 PLAN.md (Feature/Project Plan File)
├── 📊 PHASE (High-level milestone)
│   ├── 📦 TASK (Feature/component to build)
│   │   ├── 🔄 ITERATION (Incremental buildout)
│   │   │   ├── 💭 BRAINSTORMING SESSION
│   │   │   │   ├── Subject 1 (Design decision)
│   │   │   │   ├── Subject 2 (Design decision)
│   │   │   │   └── Subject N...
│   │   │   │       └── Action Items (checkboxes)
│   │   │   └── 🛠️ IMPLEMENTATION
│   │   │       └── Execute action items
│   │   └── ✅ ITERATION COMPLETE
│   └── 🎯 TASK COMPLETE
└── 🏆 PHASE COMPLETE
```

---

## Development Workflow

### Step 1: Decide What to Work On

Choose the scope:

- **Phase**: Major milestone (e.g., "Core Implementation")
- **Task**: Specific feature/component (e.g., "Implement Green Service")
- **Iteration**: Incremental piece (e.g., "Iteration 1: Tier Generation")

### Step 2: Brainstorm

Break down the iteration into **subjects to discuss**:

- Architecture decisions
- Implementation approach
- Edge cases and constraints
- Data structures
- Algorithm choices

For each subject:

1. Discuss options (Option A, B, C...)
2. Document rationale
3. Make a decision
4. Create **action items** (checkboxes)

### Step 3: Implementation

Work through action items sequentially:

- Check off each item as completed
- Update plan file with results
- Add notes/discoveries during implementation

### Step 4: Mark Complete

- All action items checked → Iteration complete
- All iterations complete → Task complete
- All tasks complete → Phase complete

### Step 5: Repeat

Move to next iteration, applying lessons learned.

---

## Brainstorming Session Pattern

### Structure

```markdown
### **Brainstorming Session - [Topic Name]**

**Subjects to Discuss** (tackle one at a time):

1. ⏳ **Subject Name** - Brief description
2. ⏳ **Subject Name** - Brief description
3. ⏳ **Subject Name** - Brief description
   ...

**Resolved Subjects**:

---

### ✅ **Subject 1: [Name]**

**Decision**: [Your decision here]

**Rationale**:

- Reason 1
- Reason 2
- Reason 3

**Options Considered**:

- **Option A**: Description (✅ CHOSEN / ❌ REJECTED)
- **Option B**: Description (✅ CHOSEN / ❌ REJECTED)

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

---

### ✅ **Subject 2: [Name]**

[Repeat pattern...]
```

### Brainstorming Guidelines

1. **One subject at a time** - Don't overwhelm yourself
2. **Document all options** - Even rejected ones (future reference)
3. **Explain rationale** - Why did you choose this approach?
4. **Create concrete action items** - Turn decisions into work
5. **Mark resolved** - Use ✅ to track progress
6. **Add subjects dynamically** - New topics can emerge during discussion

### Dynamic Subject Addition

**Subjects are NOT fixed upfront** - you can add new subjects as you work through brainstorming:

```markdown
**Subjects to Discuss**:

1. ✅ **API Design** - RESOLVED
2. 🚧 **Data Structure** - CURRENT (discussing now)
3. ⏳ **Error Handling** - PENDING
4. ⏳ **Type Conversion** - NEW (just added!)
5. ⏳ **Validation Strategy** - NEW (discovered during Subject 2)
```

**When to Add Subjects**:

- During discussion of current subject, you realize another topic needs addressing
- While resolving one subject, dependencies on other decisions become clear
- When analyzing code/reference, new questions arise
- After resolving a subject, implications suggest new topics

**How to Add**:

1. **IMMEDIATELY update PLAN.md**: Add new numbered item to "Subjects to Discuss" list with ⏳ status
2. Mark it as "NEW" or add brief context about why it was added
3. Continue with current subject - don't jump to new one immediately

**IMPORTANT**: Always update the "Subjects to Discuss" list in PLAN.md BEFORE continuing the discussion. This ensures you don't lose track of topics.

**Example**:
```markdown
User: "I now dislike the names... let's think about naming convention"

AI: "Great point! Let me add this as a subject to our brainstorming session first."

[AI updates PLAN.md:]

**Subjects to Discuss**:
1. 🚧 **Placeholder Detection Strategy** - CURRENT
2. ⏳ **Naming Convention** - NEW (emerged during Subject 1 discussion)
3. ⏳ **Handler Registration** (Q2 from Subject 1) - DEFERRED

AI: "Added Subject 2: Naming Convention to the list. Now, back to Subject 1..."
```

### Pre-Implementation Tasks During Brainstorming

**IMPORTANT**: When pre-implementation needs are discovered **during brainstorming**, DOCUMENT them immediately but DO NOT implement them yet.

**Workflow**:

1. **During brainstorming** (while discussing subjects)
2. User identifies pre-implementation need (e.g., "we need to create a validation stub in Blue")
3. **AI adds Pre-Implementation Tasks section** to PLAN.md:
   ```markdown
   ### **Pre-Implementation Tasks:**

   #### ⏳ Task 1: [Description] (PENDING)

   **Objective**: [What this task accomplishes]

   **Action Items**:
   - [ ] Item 1
   - [ ] Item 2
   ```
4. **Continue brainstorming** other subjects
5. **After all subjects resolved** → Complete pre-implementation tasks
6. **Mark pre-tasks as ✅ COMPLETE** with verification notes
7. **Then run `/flow-brainstorm_complete`**

**Example During Brainstorming**:

```markdown
User: "Before we continue, create a pre-implementation task to add a validation
      stub in Blue.validateSlotData() that returns true for now."

AI: "Added pre-implementation task. Continuing with Subject 1..."

### **Pre-Implementation Tasks:**

#### ⏳ Task 1: Create Blue Validation Stub (PENDING)

**Objective**: Add Blue.validateSlotData() method that returns true (placeholder
              for future validation logic)

**Action Items**:
- [ ] Add validateSlotData(slotData: I_SlotData): boolean method to Blue.ts
- [ ] Return true (stub implementation)
- [ ] Add TODO comment for future validation logic
- [ ] Create corresponding iteration in PLAN.md for actual implementation

---

[Continue brainstorming subjects...]
```
4. Address new subjects in order after completing current discussion

**Example Flow**:

```
Discussing Subject 2: Parser Architecture
  → Realize we need to decide on placeholder syntax first
  → Add "Subject 4: Placeholder Syntax Design" to list
  → Finish Subject 2 discussion
  → Move to Subject 3
  → Eventually get to Subject 4
```

**Benefits**:

- Captures insights as they emerge
- Prevents forgetting important topics
- Maintains focus on current subject
- Natural, organic planning process

---

## Implementation Pattern

### Structure

```markdown
### **Implementation - Iteration [N]: [Name]**

**Status**: 🚧 IN PROGRESS / ✅ COMPLETE

**Action Items** (from brainstorming):

- [x] Completed action item
- [x] Completed action item
- [ ] Pending action item

**Implementation Notes**:

[Document discoveries, challenges, solutions during implementation]

**Files Modified**:

- `path/to/file.ts` - Description of changes
- `path/to/file.ts` - Description of changes

**Verification**: [How you verified it works - tests, manual checks, etc.]

---
```

### Implementation Guidelines

1. **Follow action items** - Don't deviate from brainstorming decisions
2. **Check boxes as you go** - Maintain accurate state
3. **Document surprises** - Note anything unexpected
4. **Verify before completing** - Test/validate your work
5. **Update file list** - Track what changed

---

## Version Management

Features can be split into versions:

- **V1**: Minimum viable implementation (simple, functional)
- **V2**: Enhanced implementation (optimizations, edge cases)
- **V3**: Advanced features (rarely needed)

### When to Version

**Use V1 for:**

- Core functionality that must work
- Simple, testable implementations
- Proving the concept

**Defer to V2:**

- Performance optimizations
- Advanced edge cases
- Complex algorithms
- Nice-to-have features

**Mark in Plan:**

```markdown
**V1 Implementation**: [Description]
**V2 Enhancements** (Deferred to Phase 4):

- [ ] Optimization 1
- [ ] Feature 2
```

---

## Status Markers

Use these consistently throughout the plan file:

| Marker | Meaning     | Usage                                      |
| ------ | ----------- | ------------------------------------------ |
| ✅     | Complete    | Finished tasks, iterations, subjects       |
| ⏳     | Pending     | Not started yet                            |
| 🚧     | In Progress | Currently working on this                  |
| 🎨     | Ready       | Brainstorming complete, ready to implement |
| ❌     | Rejected    | Options/approaches not chosen              |
| 🔮     | Future      | Deferred to V2/V3/later phase              |

---

## Plan File Template

**Complete Example**: See `.flow/EXAMPLE_PLAN.md` for a full working example of a payment gateway integration project showing multiple completed iterations, brainstorming sessions, bug discoveries, and improvements.

### Basic Template Structure

```markdown
# [Feature/Project Name] - Development Plan

**Created**: [Date]
**Status**: [Current phase/iteration]
**Version**: V1

---

## Overview

**Purpose**: [What does this feature/project do?]

**Goals**:

- Goal 1
- Goal 2
- Goal 3

**Scope**: [What's included, what's excluded]

---

## Architecture

**High-Level Design**:
[Brief description of architecture, patterns, key components]

**Key Components**:

1. Component A - Description
2. Component B - Description
3. Component C - Description

**Dependencies**:

- Dependency 1
- Dependency 2

---

## Development Plan

### Phase 1: [Phase Name] ⏳

**Strategy**: [Overall approach for this phase]

**Goal**: [What this phase achieves]

---

#### Task 1: [Task Name] ⏳

**Status**: PENDING
**Purpose**: [What this task accomplishes]

---

##### Iteration 1: [Iteration Name] ⏳

**Status**: PENDING
**Goal**: [What this iteration builds]

---

### **Brainstorming Session - [Topic]**

**Subjects to Discuss**:

1. ⏳ **Subject Name** - Description
2. ⏳ **Subject Name** - Description
3. ⏳ **Subject Name** - Description

**Resolved Subjects**:

---

### ✅ **Subject 1: [Name]**

**Decision**: [Decision here]

**Rationale**:

- Reason 1
- Reason 2

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

---

### **Implementation - Iteration 1**

**Status**: 🚧 IN PROGRESS

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2
- [ ] Action item 3

**Files Modified**:

- `path/to/file.ts` - Changes

**Verification**: [How verified]

---

##### Iteration 2: [Iteration Name] ⏳

[Repeat pattern...]

---

#### Task 2: [Task Name] ⏳

[Repeat pattern...]

---

### Phase 2: [Phase Name] ⏳

[Repeat pattern...]

---

## Testing Strategy

**V1 Testing**:

- [ ] Test case 1
- [ ] Test case 2

**V2 Testing** (Deferred):

- [ ] Advanced test 1
- [ ] Advanced test 2

---

## Future Enhancements (V2+)

**Phase 4: Enhancement & Polish** (FUTURE)

**Deferred Features**:

- [ ] Feature 1
- [ ] Optimization 2
- [ ] Advanced capability 3

---

## Notes & Learnings

**Design Decisions**:

- Decision 1 and why
- Decision 2 and why

**Challenges Encountered**:

- Challenge 1 and solution
- Challenge 2 and solution

**Improvements Over Original** (if refactoring):

- Improvement 1
- Improvement 2

---

## Changelog

**[Date]** - Phase 1, Task 1, Iteration 1 complete

- Implemented X
- Added Y
- Fixed Z

**[Date]** - Brainstorming session for Iteration 2

- Resolved 5 subjects
- Created 12 action items

---
```

---

## Pre-Implementation Pattern

Before starting iteration implementation, identify if preparatory work is needed.

### When to Use Pre-Implementation Tasks

Pre-implementation tasks are preparatory work that must be completed BEFORE the main iteration implementation can begin:

- **Refactoring required** - System needs restructuring before new code
- **System-wide changes** - Updates affecting multiple files (e.g., enum → const conversion)
- **Data structure updates** - Interface/type changes needed across codebase
- **Bug fixes discovered during brainstorming** - Issues found during design that must be fixed first
- **Dependency changes** - Library updates or new dependencies to add
- **Test infrastructure** - Test setup needed before TDD implementation

### How to Document

Add pre-implementation tasks AFTER brainstorming session, BEFORE implementation:

```markdown
### **Pre-Implementation Tasks:**

#### ✅ Task 1: [Description] (COMPLETED)

**Objective**: [What this task accomplishes]

**Changes Made**:

- Change 1
- Change 2

**Verification**: [How verified]

---

#### ⏳ Task 2: [Description] (PENDING)

**Objective**: [What this task accomplishes]

**Action Items**:

- [ ] Action item 1
- [ ] Action item 2

---
```

### Completion Rule

**IMPORTANT**: Mark brainstorming session as complete ONLY after all pre-implementation tasks are done.

**Flow**:

1. Complete brainstorming session → Create pre-tasks (if needed)
2. Complete all pre-tasks → Mark brainstorming ✅ COMPLETE
3. Brainstorming complete → Ready for main iteration implementation

---

## Bugs Discovered Pattern

When analyzing reference implementations or during brainstorming, you may discover bugs in existing code. Document these clearly as part of your iteration planning.

### When to Document Bugs

- **During brainstorming** when analyzing reference code
- **When planning refactoring** work
- **As part of pre-implementation tasks**
- **When the bug discovery changes your design decisions**

### How to Document

Add bugs discovered section during brainstorming, typically BEFORE pre-implementation tasks:

````markdown
### 🐛 **Bugs Discovered in Original Implementation**

#### Bug 1: [Short Description] (Critical/Major/Minor)

**Location**: `path/to/file.ts:line_number`

**Problem**:

```typescript
// ❌ Original code (WRONG):
const result = array[Math.random() * (array.length - 1)];
// Off-by-one error: last element never selected!
```
````

**Fix**:

```typescript
// ✅ Corrected code:
const result = array[Math.random() * array.length];
// Now all elements have equal probability
```

**Impact**: Subtle bias in random selection affecting game balance

**Action**: Add to pre-implementation tasks

---

#### Bug 2: [Short Description]

[Repeat pattern...]

````

### Improvements Over Original Pattern

When rewriting/refactoring existing code, document what you improved:

```markdown
### ✅ **Improvements Over Original**

1. **Bug Fixes**:
   - Fixed random selection off-by-one error
   - Corrected prevention logic (.every → .some)

2. **Performance**:
   - Single-pass filtering (original used 3 loops)
   - O(1) Set lookups instead of O(n) array searches

3. **Code Quality**:
   - Added comprehensive JSDoc comments
   - Removed dead code (unused parameters)
   - Strict TypeScript types (no 'any')

4. **Developer Experience**:
   - Rich error metadata instead of throwing
   - Extensive logging for debugging
   - Public methods for testing

5. **Safety**:
   - Infinite loop protection (max iterations)
   - Weight budget validation
   - Bidirectional constraint checking
````

### Benefits

**Bug Discovery Documentation**:

- Creates audit trail of improvements
- Helps team understand why changes were made
- Prevents reintroducing the same bugs
- Demonstrates thorough analysis

**Improvements Tracking**:

- Shows value of refactoring effort
- Guides future improvements
- Celebrates wins and learnings
- Provides reference for similar work

---

## Best Practices

### 1. Keep Iterations Small

- Target 1-3 days of work per iteration
- Each iteration should be independently testable
- Prefer many small iterations over few large ones

### 2. Brainstorm Before Coding

- ALWAYS brainstorm before implementation
- Document all options, even rejected ones
- Create concrete action items from decisions

### 3. Update the Plan Continuously

- Check boxes as you complete work
- Add notes during implementation
- Document surprises and learnings

### 4. Use Clear Status Markers

- Make it obvious what's done, what's pending, what's in progress
- Use emoji markers consistently (✅ ⏳ 🚧 🎨)

### 5. Defer Complexity

- V1 should be simple and functional
- Mark complex features as V2/V3
- Don't over-engineer early iterations

### 6. Validate Before Completing

- Every iteration should be verified (tests, manual checks, etc.)
- Document verification method
- Don't mark complete until proven working

### 7. Learn and Adapt

- Document challenges and solutions
- Track improvements over original implementations
- Apply learnings to future iterations

### 8. Proactively Update PLAN.md

- When using slash commands, PLAN.md updates happen automatically
- When working manually (without slash commands), AI agents should:
  - **Automatically update PLAN.md** after completing significant milestones (iterations, phases, tasks)
  - **Suggest updates** when test results or implementation details should be documented
  - **Check for staleness** - if implementation diverges from plan, update the plan
- The plan file is the source of truth and must stay synchronized with actual progress

---

## Example: Iteration Lifecycle

### Starting State

```markdown
##### Iteration 4: Affix Selection 🚧 IN PROGRESS

**Brainstorming Session**:
**Subjects to Discuss**:

1. ⏳ Constraint solver algorithm
2. ⏳ Prevention rule validation
3. ⏳ Weight budget handling
```

### During Brainstorming

```markdown
**Subjects to Discuss**:

1. ✅ Constraint solver algorithm
2. 🚧 Prevention rule validation (CURRENT)
3. ⏳ Weight budget handling

**Resolved Subjects**:

### ✅ Subject 1: Constraint solver algorithm

**Decision**: Use greedy selection with backtracking
**Action Items**:

- [ ] Implement main selection loop
- [ ] Add infinite loop protection
- [ ] Create rich metadata for failures
```

### During Implementation

```markdown
**Implementation - Iteration 4**:

**Action Items**:

- [x] Implement main selection loop
- [x] Add infinite loop protection (MAX_ITERATIONS = 1000)
- [ ] Create rich metadata for failures

**Files Modified**:

- `src/services/Green.ts` - Added generateAffixes() method
```

### Completion

```markdown
##### Iteration 4: Affix Selection ✅ COMPLETE

**Implementation Results**:

- 3 methods implemented (196 lines)
- 8 test cases passing
- Weight budget constraint solver working correctly

**Verification**: All 8 tests passed, partial successes expected (constraint solver limiting overpowered combos)
```

---

## Integration with Slash Commands

This framework is designed to work with slash commands that automate plan file updates.

**Prefix**: All commands use `flow-` prefix to prevent conflicts with other frameworks.

### Initial Planning

- `/flow-blueprint [feature-description]` - **START HERE**: Generate initial PLAN.md with skeleton structure (phases/tasks/iterations). AI will ask for reference implementation if not provided.

### Structure Commands

- `/flow-phase [description]` - Start new phase
- `/flow-task [description]` - Start new task within current phase
- `/flow-iteration [description]` - Start new iteration within current task

### Brainstorming Workflow

- `/flow-brainstorm_start [topic]` - Begin brainstorming session for current iteration
- `/flow-brainstorm_subject [name]` - Add new subject to discuss
- `/flow-brainstorm_resolve [subject-name]` - Mark subject as resolved with decision
- `/flow-brainstorm_complete` - Close brainstorming (only after pre-tasks done)

### Implementation Workflow

- `/flow-implement_start` - Begin implementation phase
- `/flow-implement_complete` - Mark current iteration complete

### Navigation & State

- `/flow-status` - Show current position in plan (phase → task → iteration → status)
- `/flow-next` - Auto-detect context and suggest next command (smart helper)
- `/flow-next-subject` - Move to next unresolved brainstorming subject
- `/flow-next-iteration` - Move to next iteration in plan
- `/flow-rollback` - Undo last change to plan file

See `.claude/commands/` for slash command implementations.

---

## Summary

This framework provides:

✅ **Structure** - Clear hierarchy from phases to action items
✅ **Context** - Plan file preserves all decisions and progress
✅ **Flexibility** - Iterations can be any size, versions defer complexity
✅ **Traceability** - Complete audit trail of what/why/how
✅ **Resumability** - Anyone (human or AI) can pick up where you left off
✅ **Quality** - Brainstorming before coding reduces refactoring
✅ **Simplicity** - Simple loop: brainstorm → implement → complete → repeat

By following this framework, you build complex features incrementally with minimal refactoring, complete documentation, and clear progress tracking.

---

**Version**: 1.0
**Last Updated**: 2025-10-01
FRAMEWORK_DATA_EOF
}

get_example_content() {
  cat <<'EXAMPLE_DATA_EOF'
# Payment Gateway Integration - Development Plan

> **📖 Framework Guide**: See `.flow/DEVELOPMENT_FRAMEWORK.md` for complete methodology and patterns used in this plan
> **🎯 Purpose**: This is a reference example showing the Flow framework in action - demonstrating brainstorming sessions, iterations, pre-implementation tasks, bug discoveries, and state tracking

**Created**: 2025-10-01
**Status**: Phase 1, Task 1, Iteration 2 - In Progress
**Version**: V1

---

## Overview

**Purpose**: Integrate a third-party payment gateway (MockPay) into our e-commerce platform to enable secure online transactions.

**Goals**:
- Enable credit card payments through MockPay API
- Implement webhook handling for payment status updates
- Add payment retry logic for failed transactions
- Ensure PCI compliance for sensitive data handling

**Scope**:
- **Included**: MockPay integration, basic error handling, webhook system, transaction logging
- **Excluded**: Multiple payment providers (V2), saved payment methods (V2), subscription billing (V3)

---

## Architecture

**High-Level Design**:
- Service-oriented architecture with dedicated `PaymentService`
- Webhook processor as separate background job
- Transaction state machine for payment lifecycle management
- Event-driven notifications for payment status changes

**Key Components**:
1. **PaymentService** - Core payment processing logic
2. **MockPayAdapter** - Third-party API integration layer
3. **WebhookProcessor** - Handles async payment notifications
4. **TransactionRepository** - Persists payment records
5. **PaymentEventEmitter** - Publishes payment events to message bus

**Dependencies**:
- MockPay Node.js SDK (v3.2.1)
- Express.js for webhook endpoints
- Redis for webhook deduplication
- PostgreSQL for transaction storage

---

## Development Plan

### Phase 1: Foundation ✅

**Strategy**: Set up core infrastructure and basic payment flow

**Goal**: Enable simple payment processing without advanced features

---

#### Task 1: Setup & API Integration ✅

**Status**: COMPLETE
**Purpose**: Establish connection to MockPay and implement basic payment creation

---

##### Iteration 1: Project Setup & SDK Integration ✅

**Status**: COMPLETE
**Goal**: Install dependencies and configure MockPay credentials

---

### **Brainstorming Session - API Setup**

**Subjects to Discuss**:

1. ✅ **Credential Management** - How to securely store API keys
2. ✅ **SDK vs Raw HTTP** - Whether to use official SDK or custom implementation
3. ✅ **Environment Configuration** - Strategy for dev/staging/prod environments

**Resolved Subjects**:

---

### ✅ **Subject 1: Credential Management**

**Decision**: Use environment variables with .env file + secret manager in production

**Rationale**:
- Industry standard approach (12-factor app)
- Easy to rotate credentials without code changes
- Prevents accidental commits of secrets to git
- Integrates well with deployment pipelines

**Options Considered**:
- **Option A**: Hardcoded in config files ❌ REJECTED (security risk)
- **Option B**: Environment variables ✅ CHOSEN
- **Option C**: Database configuration ❌ REJECTED (chicken-egg problem for DB credentials)

**Action Items**:
- [x] Add `MOCKPAY_API_KEY` and `MOCKPAY_SECRET` to .env.example
- [x] Create .env file and add to .gitignore
- [x] Document credential setup in README.md
- [x] Add validation on startup to ensure credentials are present

---

### ✅ **Subject 2: SDK vs Raw HTTP**

**Decision**: Use official MockPay SDK for V1, abstract behind adapter pattern

**Rationale**:
- SDK handles authentication, retries, and rate limiting automatically
- Reduces development time for V1
- Adapter pattern allows swapping to custom HTTP client later if needed
- SDK is well-maintained (last updated 2 weeks ago)

**Options Considered**:
- **Option A**: Raw HTTP with axios ❌ REJECTED (reinventing the wheel)
- **Option B**: Official SDK with adapter pattern ✅ CHOSEN
- **Option C**: Third-party wrapper library ❌ REJECTED (adds extra dependency)

**Action Items**:
- [x] Install `@mockpay/node-sdk@3.2.1`
- [x] Create `MockPayAdapter` class implementing `PaymentGatewayInterface`
- [x] Add TypeScript types for adapter methods
- [x] Write unit tests for adapter initialization

---

### ✅ **Subject 3: Environment Configuration**

**Decision**: Use NODE_ENV with separate .env files per environment

**Rationale**:
- Clear separation of concerns
- Standard Node.js convention
- Easy to understand for new developers
- Works well with CI/CD pipelines

**Action Items**:
- [x] Create .env.development, .env.staging, .env.production templates
- [x] Add dotenv-flow package for automatic env file loading
- [x] Document environment setup in CONTRIBUTING.md

---

### **Implementation - Iteration 1**

**Status**: ✅ COMPLETE

**Action Items**:
- [x] Add MOCKPAY_API_KEY and MOCKPAY_SECRET to .env.example
- [x] Create .env file and add to .gitignore
- [x] Document credential setup in README.md
- [x] Add validation on startup to ensure credentials are present
- [x] Install @mockpay/node-sdk@3.2.1
- [x] Create MockPayAdapter class implementing PaymentGatewayInterface
- [x] Add TypeScript types for adapter methods
- [x] Write unit tests for adapter initialization
- [x] Create .env.development, .env.staging, .env.production templates
- [x] Add dotenv-flow package for automatic env file loading
- [x] Document environment setup in CONTRIBUTING.md

**Implementation Notes**:

Discovered that MockPay SDK has a sandbox mode that can be enabled via flag, added `MOCKPAY_SANDBOX=true` to development environment. This will prevent accidental charges during testing.

Also added a health check endpoint `/api/payment/health` that verifies API connectivity without making actual requests.

**Files Modified**:
- `package.json` - Added mockpay SDK and dotenv-flow dependencies
- `src/config/mockpay.ts` - Created configuration loader with validation
- `src/adapters/MockPayAdapter.ts` - Implemented adapter class (127 lines)
- `src/types/PaymentGateway.ts` - Defined interface for payment gateways
- `tests/unit/MockPayAdapter.test.ts` - Added 8 test cases
- `.env.example` - Documented required environment variables
- `.gitignore` - Added .env* to ignore list
- `README.md` - Added setup instructions
- `CONTRIBUTING.md` - Documented environment configuration

**Verification**: All 8 unit tests passing. Successfully connected to MockPay sandbox environment and retrieved account details.

**Completed**: 2025-10-01

---

##### Iteration 2: Payment Creation Flow 🚧 IN PROGRESS

**Status**: IN PROGRESS
**Goal**: Implement API endpoints and service methods to create payment intents

---

### **Brainstorming Session - Payment Flow Design**

**Subjects to Discuss**:

1. ✅ **API Endpoint Structure** - RESTful design for payment operations
2. ✅ **Payment State Machine** - Lifecycle management (pending → processing → complete)
3. 🚧 **Error Handling Strategy** - How to handle API failures gracefully (CURRENT)
4. ⏳ **Idempotency Keys** - Preventing duplicate charges

**Resolved Subjects**:

---

### ✅ **Subject 1: API Endpoint Structure**

**Decision**: Use REST with POST /api/payments to create payment intents

**Rationale**:
- Standard RESTful convention (POST = create resource)
- Returns payment intent ID that frontend can use with SDK
- Separation of concerns: backend creates intent, frontend confirms
- Aligns with MockPay's recommended integration pattern

**Options Considered**:
- **Option A**: Single endpoint `/api/pay` that does everything ❌ REJECTED (too much coupling)
- **Option B**: POST `/api/payments` to create intent, PUT `/api/payments/:id/confirm` to complete ✅ CHOSEN
- **Option C**: GraphQL mutation ❌ REJECTED (overkill for V1)

**Action Items**:
- [x] Define OpenAPI spec for POST /api/payments
- [x] Create Express router for payment endpoints
- [x] Add request validation middleware (amount, currency, metadata)
- [x] Implement PaymentService.createPaymentIntent() method

---

### ✅ **Subject 2: Payment State Machine**

**Decision**: Use enum-based state machine with explicit transitions

**Rationale**:
- Makes valid state transitions explicit and enforceable
- Easier to debug payment issues by examining state history
- Prevents invalid state transitions (e.g., pending → refunded without complete)
- Foundation for future workflow features (partial refunds, disputes)

**States**: `PENDING → PROCESSING → COMPLETED | FAILED | CANCELLED`

**Transitions**:
```
PENDING → PROCESSING (payment initiated)
PROCESSING → COMPLETED (payment succeeded)
PROCESSING → FAILED (payment declined)
PENDING → CANCELLED (user cancelled)
COMPLETED → REFUNDING → REFUNDED (future V2)
```

**Action Items**:
- [x] Create PaymentStatus enum with all states
- [x] Define state transition validation function
- [x] Add created_at, updated_at, status_changed_at timestamps
- [x] Create database migration for payment_transactions table

---

### 🚧 **Subject 3: Error Handling Strategy** (CURRENT)

**Decision**: [To be resolved]

**Discussion in progress...**

Options being considered:
- **Option A**: Return generic errors to frontend, log details server-side
- **Option B**: Return detailed error codes that frontend can map to user messages
- **Option C**: Return both error code + safe message

Need to decide:
- How much detail to expose to frontend?
- What error codes do we need? (INSUFFICIENT_FUNDS, CARD_DECLINED, NETWORK_ERROR, etc.)
- Should we retry automatically or let user retry?

---

### **Pre-Implementation Tasks:**

#### ✅ Task 1: Refactor Config Module (COMPLETED)

**Objective**: Current config module doesn't support nested configuration objects. Need to refactor before adding payment config.

**Changes Made**:
- Migrated from flat key-value config to hierarchical structure
- Updated all existing services to use new config.get() API
- Added TypeScript interfaces for type-safe config access
- Updated 23 test files to use new config structure

**Verification**: All existing tests passing (187/187). No breaking changes in other services.

---

#### ⏳ Task 2: Add Request ID Middleware (PENDING)

**Objective**: Need request ID tracking for debugging payment flows across services

**Action Items**:
- [ ] Install express-request-id package
- [ ] Add middleware to Express app
- [ ] Update logger to include request ID in all log entries
- [ ] Update existing payment logging to use request ID

---

### **Implementation - Iteration 2**

**Status**: 🚧 IN PROGRESS

**Action Items**:
- [x] Define OpenAPI spec for POST /api/payments
- [x] Create Express router for payment endpoints
- [x] Add request validation middleware
- [x] Implement PaymentService.createPaymentIntent() method
- [x] Create PaymentStatus enum
- [x] Define state transition validation function
- [x] Add timestamps to transaction model
- [x] Create database migration
- [ ] Resolve error handling strategy
- [ ] Implement error handling in service layer
- [ ] Add integration tests for payment creation
- [ ] Update API documentation

**Implementation Notes**:

Created basic payment creation flow. Currently works for happy path (successful payment creation). Need to finalize error handling strategy before implementing failure cases.

**Files Modified**:
- `src/routes/payment.routes.ts` - Payment API routes (78 lines)
- `src/services/PaymentService.ts` - Core service logic (143 lines, partial)
- `src/types/PaymentStatus.ts` - State machine enum and validation
- `migrations/002_create_payment_transactions.sql` - Database schema
- `docs/api/openapi.yaml` - API specification

**Verification**: Manual testing in Postman shows successful payment creation. Automated tests pending error handling decisions.

---

##### Iteration 3: Error Handling & Validation ⏳

**Status**: PENDING
**Goal**: Implement comprehensive error handling for payment failures

---

#### Task 2: Webhook Integration ⏳

**Status**: PENDING
**Purpose**: Handle asynchronous payment status updates from MockPay

---

##### Iteration 1: Webhook Endpoint & Signature Verification ⏳

**Status**: PENDING
**Goal**: Create secure webhook receiver endpoint

---

##### Iteration 2: Webhook Processing & Event Emission ⏳

**Status**: PENDING
**Goal**: Process webhook payloads and emit internal events

---

##### Iteration 3: Webhook Retry & Deduplication ⏳

**Status**: PENDING
**Goal**: Handle webhook delivery guarantees and prevent duplicate processing

---

### Phase 2: Core Implementation ⏳

**Strategy**: Build out remaining payment features and edge cases

**Goal**: Production-ready payment system with monitoring and logging

---

#### Task 1: Transaction Logging & Audit Trail ⏳

**Status**: PENDING
**Purpose**: Complete audit trail of all payment operations for compliance

---

#### Task 2: Payment Retry Logic ⏳

**Status**: PENDING
**Purpose**: Automatic retry for transient failures

---

### Phase 3: Testing & Validation ⏳

**Strategy**: Comprehensive testing across all scenarios

**Goal**: Confidence in production deployment

---

#### Task 1: Integration Tests ⏳

**Status**: PENDING
**Purpose**: End-to-end tests with MockPay sandbox

---

#### Task 2: Load Testing ⏳

**Status**: PENDING
**Purpose**: Verify system handles production traffic volumes

---

### Phase 4: Enhancement & Polish 🔮 FUTURE

**Strategy**: V2 features and optimizations

**Goal**: Advanced payment features for better UX

**Deferred Tasks**:
- Multiple payment provider support (Stripe, PayPal)
- Saved payment methods / tokenization
- Recurring billing / subscriptions
- Partial refunds
- Payment disputes handling
- Advanced fraud detection

---

## Testing Strategy

**V1 Testing**:
- [x] Unit tests for adapter layer (8 tests)
- [x] Unit tests for state machine (5 tests)
- [ ] Integration tests for payment creation flow
- [ ] Integration tests for webhook processing
- [ ] Manual testing with MockPay test cards
- [ ] Security audit of credential handling

**V2 Testing** (Deferred):
- [ ] Load tests (1000 concurrent payments)
- [ ] Chaos engineering tests (simulate API downtime)
- [ ] PCI compliance validation

---

## Future Enhancements (V2+)

**Phase 4: Enhancement & Polish** (FUTURE)

**Deferred Features**:
- [ ] Multi-provider support (Stripe, PayPal, etc.)
- [ ] Saved payment methods with tokenization
- [ ] Subscription billing engine
- [ ] Partial and split refunds
- [ ] Payment dispute management
- [ ] ML-based fraud detection
- [ ] Apple Pay / Google Pay integration
- [ ] International payment methods (Alipay, WeChat Pay)

---

## Notes & Learnings

**Design Decisions**:
- **Adapter pattern for gateway**: Allows swapping payment providers in V2 without rewriting business logic
- **State machine for payments**: Explicit transitions prevent invalid states and make debugging easier
- **Sandbox mode by default**: Discovered during implementation, prevents accidental charges in dev

**Challenges Encountered**:
- **Config refactoring needed**: Had to refactor config module before adding payment config (added as pre-implementation task)
- **MockPay SDK quirks**: SDK requires explicit sandbox flag, not documented clearly in their main guide

**Improvements Over Original** (if refactoring):
- N/A - This is a new feature implementation

---

## Changelog

**2025-10-01** - Phase 1, Task 1, Iteration 1 complete
- Implemented MockPay SDK integration
- Created adapter pattern for payment gateway
- Set up environment configuration
- Added 8 unit tests for adapter layer
- Discovered sandbox mode feature

**2025-10-01** - Phase 1, Task 1, Iteration 2 in progress
- Started brainstorming session for payment flow
- Resolved API endpoint structure (RESTful)
- Resolved payment state machine design
- Created database schema migration
- Completed pre-implementation task: config refactoring
- Currently resolving error handling strategy
- Implemented basic payment creation endpoint (happy path only)

---

**Next Steps**:
- Complete brainstorming for error handling strategy
- Finish Iteration 2 implementation
- Move to Iteration 3: Error handling & validation
EXAMPLE_DATA_EOF
}

deploy_commands() {
  local target_dir="$1"
  local force="$2"
  local success_count=0

  for cmd in "${COMMANDS[@]}"; do
    local cmd_file="$target_dir/${cmd}.md"
    [ -f "$cmd_file" ] && [ "$force" = false ] && { echo -e "${YELLOW}⏭️  Skip ${cmd}.md${NC}"; continue; }

    local content=$(extract_command "$cmd")
    [ -z "$content" ] && { echo -e "${RED}❌ Failed ${cmd}${NC}"; continue; }

    echo "$content" > "$cmd_file" && { echo -e "${GREEN}✅ ${cmd}.md${NC}"; ((success_count++)); } || echo -e "${RED}❌ ${cmd}.md${NC}"
  done

  echo "$success_count"
}

deploy_framework() {
  local target_dir="$1"
  local force="$2"
  local framework_file="$target_dir/DEVELOPMENT_FRAMEWORK.md"
  local example_file="$target_dir/EXAMPLE_PLAN.md"

  # Deploy framework guide
  if [ -f "$framework_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip DEVELOPMENT_FRAMEWORK.md${NC}"
  else
    get_framework_content > "$framework_file" && echo -e "${GREEN}✅ DEVELOPMENT_FRAMEWORK.md${NC}" || { echo -e "${RED}❌ Framework${NC}"; return 1; }
  fi

  # Deploy example plan
  if [ -f "$example_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip EXAMPLE_PLAN.md${NC}"
  else
    get_example_content > "$example_file" && echo -e "${GREEN}✅ EXAMPLE_PLAN.md${NC}" || { echo -e "${RED}❌ Example${NC}"; return 1; }
  fi

  return 0
}

validate() {
  local commands_dir="$1"
  local flow_dir="$2"
  local valid=true

  echo -e "\n${CYAN}🔍 Validating...${NC}\n"

  # Check framework
  [ ! -f "$flow_dir/DEVELOPMENT_FRAMEWORK.md" ] && { echo -e "${RED}❌ Framework missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Framework${NC}"

  # Check example
  [ ! -f "$flow_dir/EXAMPLE_PLAN.md" ] && { echo -e "${RED}❌ Example missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Example${NC}"

  # Check commands
  local count=0
  for cmd in "${COMMANDS[@]}"; do
    [ -f "$commands_dir/${cmd}.md" ] && ((count++))
  done

  echo -e "${GREEN}✅ Commands: $count/${#COMMANDS[@]}${NC}"
  [ "$count" -eq 0 ] && { echo -e "${RED}❌ No commands${NC}"; valid=false; }

  [ "$valid" = true ]
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) FORCE=true; shift;;
      --help|-h) print_help; exit 0;;
      *) echo -e "${RED}Unknown: $1${NC}"; print_help; exit 1;;
    esac
  done

  echo -e "\n${BLUE}🚀 Flow Framework${NC}\n"
  echo -e "Target Project: ${BLUE}$(pwd)${NC}"
  echo -e "Force: $([ "$FORCE" = true ] && echo "${GREEN}Yes${NC}" || echo "${RED}No${NC}")"
  echo -e "Mode: ${CYAN}Self-contained${NC}\n"

  local commands_dir="$(pwd)/.claude/commands"
  local flow_dir="$(pwd)/.flow"

  # Create directories
  mkdir -p "$commands_dir" || { echo -e "${RED}❌ mkdir .claude/commands failed${NC}"; exit 1; }
  mkdir -p "$flow_dir" || { echo -e "${RED}❌ mkdir .flow failed${NC}"; exit 1; }
  echo -e "${BLUE}📁 Created directories${NC}\n"

  # Deploy slash commands
  echo -e "${BLUE}📦 Installing slash commands...${NC}\n"
  local count=$(deploy_commands "$commands_dir" "$FORCE")

  # Deploy framework docs
  echo -e "\n${BLUE}📚 Installing framework documentation...${NC}\n"
  deploy_framework "$flow_dir" "$FORCE"

  # Validate
  if validate "$commands_dir" "$flow_dir"; then
    echo ""
    echo "=================================================="
    echo -e "${GREEN}✅ Flow Framework Installed!${NC}\n"
    echo -e "${CYAN}📂 Structure:${NC}"
    echo "   .claude/commands/       (15 slash commands)"
    echo "   .flow/                  (framework docs)"
    echo "     ├── DEVELOPMENT_FRAMEWORK.md"
    echo "     └── EXAMPLE_PLAN.md"
    echo ""
    echo -e "${CYAN}🚀 Next Steps:${NC}"
    echo "   1. Restart Claude Code (if running)"
    echo "   2. Run: /flow-blueprint <your-feature-name>"
    echo "   3. Read: .flow/DEVELOPMENT_FRAMEWORK.md"
    echo "   4. Reference: .flow/EXAMPLE_PLAN.md"
    echo ""
    echo "💡 Share this script - it's self-contained!"
    echo "=================================================="
    echo ""
    exit 0
  else
    echo ""
    echo -e "${YELLOW}⚠️  Deployment completed with warnings${NC}"
    echo ""
    exit 1
  fi
}

main "$@"
