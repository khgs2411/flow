#!/usr/bin/env bash

################################################################################
# Flow Framework Deployment Script
#
# Self-contained script with all framework content embedded.
# Distribute this single file to install the Flow framework.
#
# Version: 1.2.17
# Generated by build-standalone.sh
################################################################################

set -e

FLOW_VERSION="1.2.17"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

COMMANDS=(
  # Plan Initialization (4 commands)
  "flow-blueprint" "flow-migrate" "flow-plan-update" "flow-plan-split"
  # Phase Lifecycle (3 commands)
  "flow-phase-add" "flow-phase-start" "flow-phase-complete"
  # Task Lifecycle (3 commands)
  "flow-task-add" "flow-task-start" "flow-task-complete"
  # Iteration Lifecycle (6 commands: add, start, subject, review, complete, implement-start, implement-complete = 7 total)
  "flow-iteration-add"
  "flow-brainstorm-start" "flow-brainstorm-subject" "flow-brainstorm-review" "flow-brainstorm-complete"
  "flow-implement-start" "flow-implement-complete"
  # Navigation (3 commands)
  "flow-next" "flow-next-subject" "flow-next-iteration"
  # Status & Validation (5 commands)
  "flow-status" "flow-summarize" "flow-verify-plan" "flow-compact" "flow-rollback"
  # Backlog Management (3 commands)
  "flow-backlog-add" "flow-backlog-view" "flow-backlog-pull"
)

# Deprecated commands (renamed/removed in v1.0.11+) - cleaned up during --force
DEPRECATED_COMMANDS=(
  "flow-phase" "flow-task" "flow-iteration"
  "flow-brainstorm_start" "flow-brainstorm_subject" "flow-brainstorm_resolve" "flow-brainstorm_complete"
  "flow-implement_start" "flow-implement_complete"
  "flow-update-plan-version"
  "flow-brainstorm-resolve"  # Removed in v1.0.12 - redundant command
)

FORCE=false

print_help() {
  cat <<EOF

Flow Framework Deployment Script v$FLOW_VERSION

USAGE:
  ./flow.sh [OPTIONS]

OPTIONS:
  --force, -f       Overwrite existing files
  --version, -v     Show version information
  --help, -h        Show this help

DEPLOYMENT STRUCTURE:
  .claude/commands/          Slash commands (\${#COMMANDS[@]} files)
  .flow/framework/           AI reference files (read-only for user)
    ├── DEVELOPMENT_FRAMEWORK.md
    └── examples/

This script is SELF-CONTAINED - no external files needed!

EOF
}

print_version() {
  cat <<EOF
Flow Framework v$FLOW_VERSION

A spec-driven iterative development methodology combining
Domain-Driven Design principles with Agile philosophy.

Created by: Liad Goren
Repository: https://github.com/khgs2411/flow
License: Open for personal and commercial use

EOF
}

extract_command() {
  local cmd="$1"
  local marker="## /${cmd}$"
  awk -v marker="$marker" '
    $0 ~ marker {found=1; next}
    found && /^```markdown$/ {inside=1; next}
    found && inside && /^```$/ {exit}
    found && inside {print}
  ' <<'COMMANDS_DATA_EOF'
# Flow Framework - Slash Commands File.

This file contains all slash command definitions for the Flow framework. Copy these to `.claude/commands/` when ready to use.

---

## Command Guidelines

**IMPORTANT**: Every command must:

1. **Read the framework guide** at the start to understand patterns and structure
2. **Find and parse .flow/PLAN.md** to understand current state
3. **Follow framework patterns exactly** (status markers, section structure, etc.)
4. **Update .flow/PLAN.md** according to framework conventions
5. **Provide clear next steps** to the user

**File Locations**:

- **Plan File**: `.flow/PLAN.md` (Flow manages the plan from this directory)
- **Framework Guide**: Search in order:
  1. `.flow/framework/DEVELOPMENT_FRAMEWORK.md` (primary - in user's project)
  2. `.claude/DEVELOPMENT_FRAMEWORK.md` (project root)
  3. `./DEVELOPMENT_FRAMEWORK.md` (project root)
  4. `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
- **Examples**: `.flow/framework/examples/` (reference files for AI to learn from)

**Finding PLAN.md** (all commands except `/flow-blueprint` and `/flow-migrate`):

- Primary location: `.flow/PLAN.md`
- If not found, search project root and traverse up
- If still not found: Suggest `/flow-blueprint` (new project) or `/flow-migrate` (existing docs)

**Status Markers** (use consistently):

- ✅ Complete
- ⏳ Pending
- 🚧 In Progress
- 🎨 Ready for Implementation
- ❌ Cancelled
- 🔮 Deferred

**Tool Usage for Pattern Matching**:

When commands instruct you to "Find", "Look for", or "Locate" patterns in PLAN.md:

- **Use Grep tool** for:

  - Simple pattern existence checks (does pattern exist?)
  - Counting occurrences (`grep -c`)
  - Reading specific sections with context (`grep -A`, `-B`, `-C`)
  - Examples: Finding phase markers, checking status, locating sections

- **Use awk** ONLY for:

  - Extracting content between two patterns (range extraction)
  - Example: `awk '/start_pattern/,/end_pattern/ {print}'`

- **Prefer Grep over awk** for simple tasks - it's more efficient and clearer

**Examples**:

```bash
# ✅ GOOD - Use Grep for pattern checking
grep "^### Phase 4:" PLAN.md
grep -c "^#### ⏳ Task" PLAN.md
grep -A 2 "^## 📋 Progress Dashboard" PLAN.md

# ✅ GOOD - Use awk for range extraction
awk '/^##### Iteration 5:/,/^#####[^#]|^####[^#]/ {print}' PLAN.md
awk '/\*\*Subjects to Discuss\*\*:/,/\*\*Resolved Subjects\*\*:/ {print}' PLAN.md

# ❌ BAD - Don't use awk for simple existence checks
awk '/^### Phase 4:/ {print}' PLAN.md  # Use grep instead
```

---

## /flow-blueprint

**File**: `flow-blueprint.md`

```markdown
---
description: Create new multi-file Flow project structure from scratch
---

You are executing the `/flow-blueprint` command from the Flow framework.

**Purpose**: Create a brand new multi-file Flow project structure from scratch.

**🔴 REQUIRED: Read Framework Quick Reference & Templates First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-600 (Quick Reference section) - if not already in context
- **Read file templates**: DEVELOPMENT_FRAMEWORK.md lines 2101-2600 (DASHBOARD.md, PLAN.md, task-N.md templates)
- **Read examples**: `.flow/framework/examples/` directory for real-world examples

**Multi-File Architecture**: This command creates:
- `DASHBOARD.md` - Progress tracking (single source of truth, user's main workspace)
- `PLAN.md` - Static context (overview, architecture, scope)
- `phase-N/` directories (if enough info provided)
- `phase-N/task-M.md` files (if enough info provided)

**IMPORTANT**: This command ALWAYS creates fresh files, overwriting any existing. Use `/flow-migrate` to convert existing docs or `/flow-plan-update` to migrate old single-file plans.

**💡 TIP FOR USERS**: Provide rich context! The more details you provide upfront, the better the plan.

**Good example** (explicit tasks = creates phase directories + task files):
```
/flow-blueprint "WebSocket Chat App

1. Create Bun.js web server with Express
2. Implement Socket.IO for real-time messaging  
3. Build frontend app to communicate with WebSocket server

Testing: Simulation-based per service"
```

**Minimal example** (AI will ask follow-up questions, may only create DASHBOARD + PLAN):
```
/flow-blueprint "websocket server"
```

**Instructions**:

1. **INPUT VALIDATION** (Run BEFORE reading framework):

   **Step 1: Quick Scan**:
   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "❌ Missing project description. Provide at least a project name or brief description."
     STOP
   ```

   **Step 2: Detect Blueprint Mode**:

   **Mode A: SUGGEST Structure** (User wants AI to design)
   - Trigger: NO explicit structure markers in $ARGUMENTS
   - Examples: "websocket server", "user auth system"
   - Behavior: Ask questions, generate suggested structure

   **Mode B: CREATE Explicit Structure** (User designed it)
   - Trigger: Contains numbered lists, "Phase N:", "Task N:", or bullet structure
   - Examples: 
     - "1. server, 2. socket.io, 3. frontend"  
     - "Phase 1: Foundation\n- Task 1: Setup\nPhase 2: Implementation"
   - Behavior: Honor user's structure exactly (with [TBD] for missing metadata)

   **Step 3: Semantic Check** (Mode A only):
   - If too vague ("help", "project", "thing"):
     ```
     "🤔 Need more context. What are you building? Examples:
     - 'WebSocket chat server with Socket.IO'
     - 'User authentication system with JWT'
     
     Or provide explicit structure:
     1. [First step]
     2. [Second step]
     3. [Third step]"
     ```

   **Step 4: Dry-Run Preview** (Mode B only):
   - Parse structure and show what will be created:
     ```
     "📋 Detected explicit structure. I will create:
     
     Phase 1: Bun.js Web Server ⏳
       - phase-1/task-1.md (Create Express server)
     
     Phase 2: Socket.IO Implementation ⏳  
       - phase-2/task-1.md (Implement real-time messaging)
     
     Phase 3: Frontend App ⏳
       - phase-3/task-1.md (Build WebSocket client)
     
     Also creating: DASHBOARD.md, PLAN.md
     
     Proceed? (yes/no)"
     ```

2. **Read framework guide AND examples** (after validation):
   - Search for DEVELOPMENT_FRAMEWORK.md (`.flow/`, `.claude/`, `./`, `~/.claude/flow/`)
   - Search for examples in `.flow/framework/examples/` (DASHBOARD.md, PLAN.md, task files)
   - Read to understand:
     - Multi-file structure (DASHBOARD vs PLAN vs task files)
     - File templates
     - Required sections
     - Status markers

3. **Analyze feature request** (Mode-specific):

   **If Mode A (SUGGEST)**:
   - Extract: requirements, constraints, references, testing
   - If minimal context, prepare to ask questions

   **If Mode B (CREATE)**:
   - Parse structure (phases/tasks from numbered lists or explicit markers)
   - Extract metadata if provided
   - Use [TBD] for missing metadata

4. **Gather information** (Mode A only):

   a. **Reference implementations**:
      - If mentioned in args, read and analyze
      - Otherwise ask: "Reference implementation to analyze? (path or 'no')"

   b. **Testing methodology**:
      - If provided in args, use directly
      - Otherwise ask:
        ```
        "How do you prefer to verify implementations?
        - Simulation-based (per-service): scripts/{service}.scripts.ts
        - Unit tests: Jest/Vitest after implementation
        - TDD: Tests before implementation
        - Manual QA: No automated tests
        - Custom: Describe your approach
        
        Also tell me:
        - Test file naming? (e.g., {service}.scripts.ts, {feature}.test.ts)
        - Test file location? (e.g., scripts/, __tests__/, tests/)
        - When to create NEW vs add to existing?"
        ```

   c. **Estimate phase/task structure** (Mode A only):
      - Based on requirements, estimate phases needed
      - Ask: "I'm thinking X phases: [list]. Does this structure make sense? Any changes?"

   d. **Ask about Key Decisions** (IMPORTANT - human-in-loop):
      - If you identify design decisions during structure creation, **ASK USER IMMEDIATELY**:
        ```
        "I identified a decision point: [question]"
        "- Option A: [description]"
        "- Option B: [description]"
        "Your choice? (or say 'decide later' to add to Key Decisions section)"
        ```
      - **If user chooses**: Document choice in PLAN.md Architecture section or relevant file
      - **If user says "decide later"**: Add to DASHBOARD.md Key Decisions section as unresolved
      - **DO NOT** create unresolved Key Decisions without asking user first
      - Examples of decisions to ask about:
        - Version numbering (v1.X.0 vs v2.0.0)
        - Architecture patterns (REST vs GraphQL, SQL vs NoSQL)
        - Testing approach (if not already gathered in step 4b)
        - Deployment strategy (if relevant to project)

5. **Determine what files to create**:

   **ALWAYS CREATE**:
   - `DASHBOARD.md` (required - single source of truth for progress)
   - `PLAN.md` (required - static context)

   **CREATE phase-N/ directories + task files IF**:
   - Mode B (explicit structure) → Always create
   - Mode A with rich context (clear tasks identified) → Create
   - Mode A with minimal context → Don't create yet (user adds with /flow-phase-add later)

6. **Generate files**:

   a. **Create DASHBOARD.md**:
      - Use template from DEVELOPMENT_FRAMEWORK.md lines 2102-2200
      - Fill in project name, purpose
      - Current Work: Set to Phase 1, Task 1, Iteration 1 (if phases created) OR "No phases yet" (if not)
      - Progress Overview: List all phases/tasks created (or empty if none)
      - Completion Status: 0% initially
      - Next Actions: "Use /flow-phase-add to add first phase" OR "Use /flow-phase-start to begin"
      - Last Updated: Current timestamp

   b. **Create PLAN.md**:
      - Use template from DEVELOPMENT_FRAMEWORK.md lines 2232-2321
      - Include (MINIMAL - no assumptions):
        - Header with purpose
        - Overview (Purpose, Goals - text format NO checklists, Scope V1 only)
        - Architecture (high-level system context if info provided)
        - DO/DON'T Guidelines
        - Notes & Learnings (empty initially)
      - **DO NOT INCLUDE** (unless user explicitly requests):
        - V2/V3 Scope sections
        - Testing Strategy section (user decides during brainstorming)
        - Development Phases section
        - Future Enhancements section

   c. **Create phase-N/ directories** (if applicable):
      - Create one directory per phase
      - Naming: `phase-1/`, `phase-2/`, etc.

   d. **Create phase-N/task-M.md files** (if applicable):
      - Use template from DEVELOPMENT_FRAMEWORK.md lines 2383-2472 (task with iterations)
      - **ALL tasks have iterations** (no standalone tasks)
      - Fill in:
        - Task name and purpose
        - Phase link back to DASHBOARD.md
        - Status: ⏳ PENDING initially
        - Task Overview with "Why This Task"
        - Dependencies (if known)
        - At least 1 iteration per task (with placeholder goal)
        - Task Notes section (empty initially)

7. **Verify completeness** (self-check):
   - [ ] DASHBOARD.md created with all required sections?
   - [ ] PLAN.md created with minimal required sections (no assumptions)?
   - [ ] phase-N/ directories created (if applicable)?
   - [ ] phase-N/task-M.md files created with iterations (if applicable)?
   - [ ] DASHBOARD.md Current Work points to correct location?

8. **Confirm to user**:

   **If Mode A (SUGGEST) with phases created**:
   ```
   "✨ Created multi-file Flow project structure:

   📂 Files Created:
   - DASHBOARD.md (your main workspace - single source of truth)
   - PLAN.md (static context - minimal assumptions)
   - phase-1/ with [X] task files (all with iterations)
   - phase-2/ with [Y] task files (all with iterations)
   
   📊 Structure: [X] phases, [Y] tasks, [Z] iterations
   
   🎯 Next Steps:
   - Use `/flow-status` to see current state
   - Use `/flow-phase-start` to begin Phase 1
   - Use `/flow-brainstorm-start` when ready to design first iteration"
   ```

   **If Mode A (SUGGEST) without phases** (minimal context):
   ```
   "✨ Created initial Flow project structure:

   📂 Files Created:
   - DASHBOARD.md (your main workspace)
   - PLAN.md (static context - V1 scope only)
   
   📝 Note: No phases created yet (need more context)
   
   🎯 Next Steps:
   - Use `/flow-phase-add "Phase Name"` to add your first phase
   - Then use `/flow-task-add "Task Name"` to add tasks
   - Or re-run `/flow-blueprint` with more detailed requirements"
   ```

   **If Mode B (CREATE)**:
   ```
   "✨ Created multi-file Flow project from your explicit structure:

   📂 Files Created:
   - DASHBOARD.md (single source of truth)
   - PLAN.md (minimal assumptions)
   - phase-1/ → [X] tasks (all with iterations)
   - phase-2/ → [Y] tasks (all with iterations)
   - phase-3/ → [Z] tasks (all with iterations)
   
   📊 Structure: [X] phases, [Y] tasks (as you specified)
   📝 [TBD] placeholders: [list sections with [TBD]]
   
   🎯 Next Steps:
   - Use `/flow-status` to see current state
   - Refine [TBD] sections during brainstorming
   - Use `/flow-phase-start` to begin work"
   ```

**Output**: Create multi-file Flow project structure and confirm to user.
## /flow-migrate

**File**: `flow-migrate.md`

```markdown
---
description: Migrate existing PRD/PLAN/TODO to Flow's .flow/PLAN.md format
---

You are executing the `/flow-migrate` command from the Flow framework.

**Purpose**: Migrate existing project documentation (PLAN.md, TODO.md, etc.) to Flow's multi-file format (DASHBOARD.md, PLAN.md, phase-N/task-M.md files).

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Multi-File Architecture, File Templates, Task Structure Rules, Status Markers
- **Deep dive if needed**: Read lines 2101-2600 for File Templates using Read(offset=2101, limit=500)

**Multi-File Architecture**: This command creates:
- `DASHBOARD.md` - Progress tracking (single source of truth)
- `PLAN.md` - Static context (overview, architecture, scope)
- `phase-N/` directories
- `phase-N/task-M.md` files for each task (all with iterations)
- `BACKLOG.md` - Deferred tasks (if applicable)

**Framework Reference**: This command requires framework knowledge to convert existing docs to Flow's multi-file structure. See Quick Reference guide above for essential patterns.

**IMPORTANT**: This command ALWAYS creates fresh Flow files, overwriting any existing multi-file structure. It reads your current documentation and converts it to multi-file Flow format.

**Instructions**:

1. **Read the framework guide AND examples** ⚠️ CRITICAL:

   - **Read DEVELOPMENT_FRAMEWORK.md lines 1-353** (Quick Reference)
   - **Read DEVELOPMENT_FRAMEWORK.md lines 2101-2600** (File Templates)
   - **Read framework/examples/** directory to see multi-file structure:
     - `framework/examples/DASHBOARD.md` - Dashboard format
     - `framework/examples/PLAN.md` - Static plan format
     - `framework/examples/phase-1/task-1.md` - Standalone task example
     - `framework/examples/phase-2/task-3.md` - Task with iterations example
   - **Understand**:
     - Multi-file hierarchy: DASHBOARD.md + PLAN.md + phase-N/task-M.md
     - Flow's hierarchy: PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION
     - All status markers (✅ ⏳ 🚧 🎨 ❌ 🔮 🎯)

2. **Discover existing documentation**:

   - Check if user provided path in `$ARGUMENTS`
   - Otherwise, search project root for common files (in order):
     - `PRD.md` (common in TaskMaster AI, Spec-Kit)
     - `PLAN.md`
     - `TODO.md`
     - `DEVELOPMENT.md`
     - `ROADMAP.md`
     - `TASKS.md`
   - If multiple found, list them and ask: "Found [X] files. Which should I migrate? (number or path)"
   - If none found, ask: "No plan files found. Provide path to file you want to migrate, or use `/flow-blueprint` to start fresh."

3. **Read and analyze source file**:

   - Read entire source file
   - Detect structure type:
     - **STRUCTURED** (Path A): Has phases/tasks/iterations or similar hierarchy
     - **FLAT_LIST** (Path B): Simple todo list or numbered items
     - **UNSTRUCTURED** (Path C): Free-form notes, ideas, design docs
   - Extract key information:
     - Project context/purpose
     - Existing work completed
     - Current status/position
     - Remaining work
     - Architecture/design notes
     - V1/V2 splits (if mentioned)
     - Deferred items
     - Cancelled items

4. **Create backup**:

   - Copy source file: `[original].pre-flow-backup-$(date +%Y-%m-%d-%H%M%S)`
   - Confirm: "✅ Backed up [original] to [backup]"

5. **Generate multi-file Flow structure** based on detected structure (ALWAYS overwrites if exists):

   **Multi-File Generation Process**:
   - Create `DASHBOARD.md` with progress tracking (single source of truth)
   - Create `PLAN.md` with overview, architecture, scope (minimal assumptions)
   - Create `phase-N/` directories for each phase
   - Create `phase-N/task-M.md` files for each task (all with iterations)
   - Create `BACKLOG.md` if deferred items exist

   **Path A - STRUCTURED** (already has phases/tasks):

   - Keep existing hierarchy
   - **CRITICAL**: Use framework/examples/ directory as reference for all files
   - **Create DASHBOARD.md** (use framework/examples/DASHBOARD.md as template):
     - "📍 Current Work" section with current phase/task/iteration
     - "📊 Progress Overview" with all phases and tasks
     - "📈 Completion Status" with percentages
   - **Create PLAN.md** (use framework/examples/PLAN.md as template):
     - Overview section with Purpose, Goals (text only, no checklists), Scope (V1 only unless user specifies V2)
     - Architecture section with system context (high-level, not prescriptive)
     - DO/DON'T Guidelines section
     - Notes & Learnings section
   - **Create phase-N/ directories** for each phase
   - **Create task files** (use framework/examples/phase-2/task-3.md as template):
     - Task overview
     - Iterations with brainstorming sessions
     - Pre-implementation tasks (if applicable)
     - Implementation sections
     ```markdown
     > **📖 Framework Guide**: See DEVELOPMENT_FRAMEWORK.md for complete methodology and patterns used in this plan
     >
     > **🎯 Purpose**: [Brief description of what this plan covers - extract from existing docs]

     **Created**: [Original date if available]
     **Version**: V1
     **Plan Location**: `.flow/PLAN.md` (managed by Flow)
     ```
   - **Add/enhance Progress Dashboard section** (after Overview, before Architecture):
     - Follow EXAMPLE_PLAN.md lines 29-62 format exactly
     - Include: Last Updated, Current Work (with jump links), Completion Status, Progress Overview
     - **Ensure iteration lists are expanded** (read DEVELOPMENT_FRAMEWORK.md lines 2555-2567 for format)
     - **Remove duplicate progress sections** (search for patterns like "Current Phase:", "Implementation Tasks", old progress trackers)
     - **Update status pointers** (change "Search for 'Current Phase' below" to jump link to Progress Dashboard)
   - **Add Testing Strategy section** if missing (see EXAMPLE_PLAN.md lines 87-129):
     - Ask user about testing methodology if not clear from existing docs
     - Include all required fields: Methodology, Location, Naming, When to create, When to add
   - **Add Changelog section** if missing (see EXAMPLE_PLAN.md lines 544-549):
     - Populate with existing completion dates if available
     - Format: `**YYYY-MM-DD**: - ✅ [Iteration X]: [description]`
   - **Identify redundant framework docs** (ask user if sections like "Brainstorming Framework" should be removed since Flow provides this)
   - Standardize status markers (✅ ⏳ 🚧 🎨 ❌ 🔮)
   - Add jump links to Progress Dashboard
   - Preserve all content, decisions, and context
   - Reformat sections to match Flow template
   - Report: "Enhanced existing structure (preserved [X] phases, [Y] tasks, [Z] iterations, added Progress Dashboard, Testing Strategy, Changelog, removed [N] duplicate sections)"

   **Path B - FLAT_LIST** (todos/bullets):

   - Ask: "Group items into phases? (Y/n)"
   - If yes, intelligently group related items
   - If no, create single phase with items as iterations
   - **CRITICAL**: Use EXAMPLE_PLAN.md as reference for all sections
   - **Add framework reference header** (copy format from EXAMPLE_PLAN.md lines 1-11)
   - **Add Progress Dashboard** (follow EXAMPLE_PLAN.md lines 29-62)
   - **Add Testing Strategy section** (ask user about methodology, see EXAMPLE_PLAN.md lines 87-129)
   - **Add Changelog section** (see EXAMPLE_PLAN.md lines 544-549)
   - Convert items to Flow iteration format
   - Add placeholder brainstorming sessions
   - Mark completed items as ✅, pending as ⏳
   - Report: "Converted flat list to Flow structure ([X] phases, [Y] tasks, [Z] iterations, added Progress Dashboard, Testing Strategy, Changelog)"

   **Path C - UNSTRUCTURED** (notes):

   - Extract key concepts and features mentioned
   - **CRITICAL**: Use EXAMPLE_PLAN.md as reference for all sections
   - **Create Framework reference header** (copy format from EXAMPLE_PLAN.md lines 1-11)
   - Create Overview section from notes
   - Create Architecture section if design mentioned
   - **Create Progress Dashboard** (minimal - project just starting, see EXAMPLE_PLAN.md lines 29-62)
   - **Create Testing Strategy section** (ask user about methodology, see EXAMPLE_PLAN.md lines 87-129)
   - **Create Changelog section** with initial entry (see EXAMPLE_PLAN.md lines 544-549)
   - Create initial brainstorming session with subjects from notes
   - Mark everything as ⏳ PENDING
   - Report: "Created Flow plan from notes (extracted [X] key concepts as brainstorming subjects, added all required sections)"

6. **Add standard Flow sections** (all paths):

   - **Framework reference header** (follow EXAMPLE_PLAN.md lines 1-11)
   - Progress Dashboard (follow EXAMPLE_PLAN.md lines 29-62)
   - Testing Strategy (follow EXAMPLE_PLAN.md lines 87-129)
   - Changelog (follow EXAMPLE_PLAN.md lines 544-549)
   - Development Plan with proper hierarchy
   - Status markers at every level

7. **Smart content preservation**:

   - NEVER discard user's original content
   - Preserve all decisions, rationale, context
   - Preserve code examples, file paths, references
   - Preserve completion status and dates
   - Enhance with Flow formatting, don't replace

8. **Verify completeness before saving** ⚠️ CRITICAL SELF-CHECK:
   - [ ] Framework reference header present (with 🎯 Purpose line)?
   - [ ] Overview section present?
   - [ ] Progress Dashboard present (NOT optional - REQUIRED)?
   - [ ] Testing Strategy section present (ask user if missing)?
   - [ ] Changelog section present?
   - [ ] Development Plan with phases/tasks/iterations?
   - [ ] All iteration lists expanded (NOT "(X iterations total)")?
   - [ ] All original content preserved?
   - **If any checkbox is unchecked, review EXAMPLE_PLAN.md again and add missing section**

9. **Confirm to user**:
```

✨ Migration complete!

📂 Source: [original file path]
💾 Backup: [backup file path]
🎯 Output: Multi-file Flow structure created

**Files Created**:
- DASHBOARD.md - Progress tracking dashboard
- PLAN.md - Static overview and architecture
- phase-1/ → phase-N/ - Phase directories
- phase-N/task-M.md - Individual task files
- CHANGELOG.md - Historical record
- BACKLOG.md - Deferred tasks (if applicable)

Migration type: [STRUCTURED/FLAT_LIST/UNSTRUCTURED]
Changes: + Created [X] phase directories + Created [Y] task files + Migrated [Z] iterations + Preserved all decisions and context

Next steps:
1. Review: /flow-status
2. Verify structure: ls .flow/
3. Start using Flow: /flow-brainstorm-start [topic]

📂 Flow is now managing this project from .flow/ multi-file structure

```

10. **Handle edge cases**:
 - If source file is empty: Suggest `/flow-blueprint` instead
 - If source file is already Flow-compliant: Mention it's already compatible, migrate anyway
 - If can't determine structure: Default to Path C (unstructured)
 - If migration fails: Keep backup safe, report error, suggest manual approach

**Output**: Create multi-file Flow structure (DASHBOARD.md, PLAN.md, phase-N/task-M.md files) from existing documentation, create backup, confirm migration to user.
```

---

## /flow-plan-update

**File**: `flow-plan-update.md`

```markdown
---
description: Update existing plan to match latest Flow framework structure
---

You are executing the `/flow-plan-update` command from the Flow framework.

**Purpose**: Update an existing multi-file Flow structure to match the latest framework patterns.

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Multi-File Architecture, File Templates
- **Deep dive if needed**: Read lines 2101-2600 for File Templates using Read(offset=2101, limit=500)

**Multi-File Architecture**: This command updates:
- `DASHBOARD.md` - Ensures correct format and sections
- `PLAN.md` - Ensures correct format and sections
- `phase-N/task-M.md` files - Ensures correct format
- Adds missing files (CHANGELOG.md, BACKLOG.md if needed)

**IMPORTANT**: This command updates your current multi-file structure to match framework changes (e.g., new dashboard sections, status markers, structural improvements).

**Instructions**:

1. **Read the framework guide**:
   - Read DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference)
   - Read DEVELOPMENT_FRAMEWORK.md lines 2101-2600 (File Templates)
   - Read framework/examples/ directory for current format

2. **Read current structure**:
   - Read `DASHBOARD.md`
   - Read `PLAN.md`
   - List phase directories: `ls .flow/phase-*/`
   - Sample task files: Read a few `phase-N/task-M.md` files

3. **Create backups**:
   - Create `.flow/backup-$(date +%Y-%m-%d-%H%M%S)/` directory
   - Copy all current files to backup directory
   - Confirm: "✅ Backed up current structure to [backup]"

4. **Update files to match current templates**:

   **DASHBOARD.md**:
   - Ensure "📍 Current Work" section exists and is current
   - Ensure "📊 Progress Overview" section exists with all phases
   - Ensure "📈 Completion Status" section exists with percentages
   - Update "Last Updated" timestamp

   **PLAN.md**:
   - Ensure Overview section exists (Purpose, Scope with V1/V2 split)
   - Ensure Architecture section exists
   - Ensure Testing Strategy section exists
   - Ensure Development Phases section exists (high-level only)
   - NO detailed tasks in PLAN.md (those go in task files)

   **Task Files** (`phase-N/task-M.md`):
   - Ensure each has Task Overview section
   - Ensure each has Iterations section
   - Ensure brainstorming sessions are properly formatted
   - Ensure status markers are correct (✅ ⏳ 🚧 🎨 ❌ 🔮)

   **Missing Files**:
   - Create CHANGELOG.md if missing
   - Create BACKLOG.md if deferred tasks exist

5. **Report changes**:

   Compare user's PLAN.md against these patterns and identify what needs updating:

   **✅ CORRECT PATTERNS (v1.2.1+)**:

   **A. Section Order**:
   1. Title + Framework Reference header
   2. Overview (Purpose, Goals, Scope)
   3. Progress Dashboard (after Overview, before Architecture)
   4. Architecture
   5. Testing Strategy
   6. Development Plan (Phases → Tasks → Iterations)
   7. Changelog

   **B. Implementation Section Pattern** (NO ACTION ITEM DUPLICATION):
   ```markdown
   ### **Implementation - Iteration [N]: [Name]**

   **Status**: 🚧 IN PROGRESS

   **Action Items**: See resolved subjects above (Type 2/D items)

   **Implementation Notes**:
   [Document progress, discoveries, challenges]

   **Files Modified**:
   - `path/to/file.ts` - Description

   **Verification**: [How verified]
   ```

   **C. Progress Dashboard Jump Links**:
   ```markdown
   **Current Work**:
   - **Phase**: [Phase 2 - Core Implementation](#phase-2-core-implementation-)
   - **Task**: [Task 5 - Error Handling](#task-5-error-handling-)
   - **Iteration**: [Iteration 6 - Circuit Breaker](#iteration-6-circuit-breaker-) 🚧 IN PROGRESS
   ```

   **D. Iteration Lists** (EXPANDED, not collapsed):
   ```markdown
   - 🚧 **Task 23**: Refactor Architecture (3/3 iterations)
     - ✅ **Iteration 1**: Separate Concerns - COMPLETE
     - ⏳ **Iteration 2**: Extract Logic - PENDING
     - ⏳ **Iteration 3**: Optimize - PENDING
   ```

   **E. Status Markers**: ✅ ⏳ 🚧 🎨 ❌ 🔮 (standardized)

   ---

   **❌ DEPRECATED PATTERNS (pre-v1.2.1)**:

   **A. Duplicated Action Items** (REMOVE):
   ```markdown
   ### ✅ Subject 1: Feature X
   **Action Items**:
   - [ ] Item 1
   - [ ] Item 2

   ### **Implementation - Iteration 1**
   **Action Items** (from brainstorming):  ← DUPLICATE! REMOVE THIS
   - [ ] Item 1
   - [ ] Item 2
   ```
   **FIX**: Replace Implementation action items with "See resolved subjects above"

   **B. Collapsed Iteration Lists** (EXPAND):
   ```markdown
   - 🚧 Task 23: Architecture (3 iterations total)  ← WRONG!
   ```
   **FIX**: Expand to show all iterations as sub-bullets

   **C. Duplicate Progress Sections** (REMOVE):
   - Old "Current Phase" headers scattered throughout
   - Multiple "Implementation Tasks" trackers
   - Redundant status summaries
   **FIX**: Single Progress Dashboard after Overview

   **D. Text-based Status Pointers** (REPLACE):
   ```markdown
   Current work: Search for "Current Phase" below  ← WRONG!
   ```
   **FIX**: Use jump links: `[Progress Dashboard](#-progress-dashboard)`

   **E. Missing Testing Strategy Section** (ADD):
   **FIX**: Add Testing Strategy section (see EXAMPLE_PLAN.md lines 87-129)

6. **Present analysis to user**:

   **DO NOT automatically make changes**. Instead, present findings:

   ```markdown
   ## 📋 Plan Structure Analysis

   I've compared your PLAN.md against the latest Flow framework (v1.2.1).

   **✅ Already Correct**:
   - [List patterns that match current framework]

   **❌ Needs Updates**:

   1. **Action Item Duplication** (Found in X iterations)
      - Problem: Implementation sections duplicate action items from subjects
      - Fix: Replace with "See resolved subjects above"
      - Saves: ~600-1000 tokens per iteration

   2. **Progress Dashboard Location** (if applicable)
      - Problem: Dashboard is [location]
      - Fix: Move to after Overview, before Architecture

   3. **[Other issues found]**
      - Problem: [description]
      - Fix: [what needs to change]

   **Recommendation**: Should I update your PLAN.md to fix these issues?
   - I'll create a backup first
   - All content will be preserved
   - Only structure/formatting changes
   ```

7. **If user approves, update plan structure** (preserve ALL content):

   **Create backup first**:
   - Copy: `.flow/PLAN.md.version-update-backup-$(date +%Y-%m-%d-%H%M%S)`

   **Apply fixes** based on analysis from step 5:
   - Fix action item duplication (replace with references)
   - Move Progress Dashboard to correct location
   - Remove duplicate progress sections
   - Update status pointers to jump links
   - Add missing sections (Testing Strategy, Changelog)
   - Expand collapsed iteration lists
   - Standardize status markers

   **Preserve ALL**:
   - Decisions and rationale
   - Brainstorming subjects and resolutions
   - Implementation notes
   - Completion dates
   - Bug discoveries
   - Code examples

8. **Verify consistency**:

   - Check Progress Dashboard matches status markers
   - Verify all sections follow framework structure
   - Ensure no content was lost

6. **Confirm to user**:
```

✨ Multi-file structure updated to match latest Flow framework!

💾 Backup: .flow/backup-[timestamp]/
🎯 Updated: All Flow files

**Files Updated**:
- DASHBOARD.md - Updated sections and format
- PLAN.md - Updated sections and format
- phase-N/task-M.md - Updated [X] task files
- Created missing files (if applicable)

Changes made:
+ Updated dashboard sections
+ Ensured all files match current templates
+ Standardized status markers
+ Fixed [N] formatting issues
+ Created [Y] missing files

Next steps:
1. Review changes: diff -r [backup] .flow/
2. Verify: /flow-status
3. Continue work: /flow-next

All your content preserved - only structure enhanced.

```

7. **Handle edge cases**:
- If `.flow/DASHBOARD.md` doesn't exist: Suggest `/flow-blueprint` or `/flow-migrate`
- If structure already matches latest: Report "Already up to date!"
- If can't determine what to update: Ask user for clarification

**Output**: Update all Flow files to latest framework structure, create backup, confirm changes to user.
```

---

## /flow-phase-add

**File**: `flow-phase-add.md`

```markdown
---
description: Add a new phase directory and update dashboard
---

You are executing the `/flow-phase-add` command from the Flow framework.

**Purpose**: Add a new phase to the project by creating a phase directory and updating DASHBOARD.md.

**🟢 NO FRAMEWORK READING REQUIRED - Simple structure creation**

**Multi-File Architecture**: This command:
- Creates `phase-N/` directory
- Updates `DASHBOARD.md` with new phase
- Updates `PLAN.md` Development Phases section

**Instructions**:

1. **INPUT VALIDATION**:

   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "❌ Missing phase name. Example: /flow-phase-add 'Testing and QA'"
     STOP
   ```

   Accept even minimal input like "Testing" - will use [TBD] for missing metadata.

2. **Find .flow/DASHBOARD.md**:
   ```bash
   Primary location: .flow/DASHBOARD.md

   If not found:
     Suggest: "Run /flow-blueprint first to create project structure"
   ```

3. **Read DASHBOARD.md**:
   - Count existing phases to determine next phase number
   - Example: If "Phase 1" and "Phase 2" exist, new phase is "Phase 3"

4. **Parse arguments and infer metadata**:

   From `$ARGUMENTS`, extract or infer:
   - **Phase name**: Use $ARGUMENTS directly
   - **Strategy**: Try to infer from name:
     - "Foundation" → "Setup and establish core architecture"
     - "Implementation" / "Core" → "Build main features and functionality"
     - "Testing" / "QA" → "Comprehensive testing and quality assurance"
     - "Polish" / "Enhancement" → "Refinement and optimization"
     - Can't infer → "[TBD] - Define during phase start"
   - **Goal**: Try to infer from name:
     - "Foundation" → "Establish solid project foundation"
     - "Implementation" → "Complete core feature set"
     - "Testing" → "Ensure production-ready quality"
     - Can't infer → "[TBD] - Define during phase start"

5. **Create phase directory**:
   ```bash
   mkdir .flow/phase-N/

   # Where N = next phase number (e.g., phase-3/)
   ```

6. **Update DASHBOARD.md**:

   Add to "📊 Progress Overview" section:
   ```markdown
   ### Phase [N]: [Phase Name] ⏳ PENDING

   **Goal**: [Inferred or [TBD]]
   **Status**: Not started

   (No tasks yet - use /flow-task-add to add tasks)
   ```

   Update "📈 Completion Status" section:
   - Increment phase count
   - Add phase to breakdown (0% complete initially)

7. **Update PLAN.md**:

   Add to "Development Phases" section:
   ```markdown
   ### Phase [N]: [Phase Name] ⏳

   **Strategy**: [Inferred or [TBD]]
   **Goal**: [Inferred or [TBD]]

   **Tasks**: See [phase-N/](phase-N/) directory for detailed task files
   ```

8. **Update DASHBOARD.md timestamp**:
   - Update "Last Updated" to current timestamp

9. **Confirm to user**:
   ```
   "✅ Added Phase [N]: [Phase Name]

   📂 Created: .flow/phase-N/ directory
   📝 Updated: DASHBOARD.md, PLAN.md

   [If used [TBD]:]
   📝 Used [TBD] placeholders for: [Strategy/Goal]
   💡 Refine these during phase start

   🎯 Next Steps:
   - Use `/flow-task-add "Task Name"` to add tasks to this phase
   - Use `/flow-phase-start` when ready to begin work"
   ```

**Output**: Create phase-N/ directory and update DASHBOARD.md + PLAN.md with new phase.

```

---

## /flow-phase-start

**File**: `flow-phase-start.md`

```markdown
---
description: Mark current phase as in progress
---

You are executing the `/flow-phase-start` command from the Flow framework.

**Purpose**: Mark the current phase as 🚧 IN PROGRESS (when first task starts).

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**
- State transition (⏳ PENDING → 🚧 IN PROGRESS)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 567-613 for lifecycle context

**Multi-File Architecture**: This command:
- Updates `DASHBOARD.md` phase status
- No changes to PLAN.md or task files

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this phase that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📊 Progress Overview" section
   - Locate first ⏳ PENDING phase

2. **Update phase status in dashboard**:
   - Change phase marker from ⏳ PENDING to 🚧 IN PROGRESS
   - Example:
     ```markdown
     ### Phase 2: Core Implementation ⏳ PENDING
     ```
     Becomes:
     ```markdown
     ### Phase 2: Core Implementation 🚧 IN PROGRESS
     ```

3. **Update "📍 Current Work" section**:
   - Set current phase to the phase just started
   - Clear task/iteration (no current work yet)
   ```markdown
   ## 📍 Current Work
   - **Phase**: [Phase 2 - Core Implementation](phase-2/)
   - **Task**: None yet - use `/flow-task-add [name]` to create first task
   ```

4. **Update "Last Updated" timestamp** at top of dashboard

5. **Confirm to user**:
   ```
   ✅ Started Phase [N]: [Name]

   Next steps:
   - Use `/flow-task-add [name]` to create tasks in this phase
   - Or use `/flow-blueprint` if you want to regenerate the plan structure
   ```

**Output**: Updated `DASHBOARD.md` with phase status change.
```

---

## /flow-phase-complete

**File**: `flow-phase-complete.md`

```markdown
---
description: Mark current phase as complete
---

You are executing the `/flow-phase-complete` command from the Flow framework.

**Purpose**: Mark the current phase as ✅ COMPLETE (when all tasks done).

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**

- State transition (🚧 IN PROGRESS → ✅ COMPLETE)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 567-613 for completion criteria

**Multi-File Architecture**: This command:
- Updates `DASHBOARD.md` phase status
- No changes to PLAN.md or task files

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📊 Progress Overview" section
   - Locate current phase marked 🚧 IN PROGRESS

2. **Verify all tasks complete** in dashboard:
   - Check that all tasks in this phase are marked ✅ COMPLETE
   - If incomplete tasks found:
     ```
     ❌ Cannot complete phase - incomplete tasks found:
     - Task 3: API Integration (🚧 IN PROGRESS)
     - Task 5: Webhook Handler (⏳ PENDING)

     Complete all tasks first or mark them as ❌ CANCELLED / 🔮 DEFERRED.
     ```

3. **Update phase status in dashboard**:
   - Change phase marker from 🚧 IN PROGRESS to ✅ COMPLETE
   - Example:
     ```markdown
     ### Phase 2: Core Implementation 🚧 IN PROGRESS
     ```
     Becomes:
     ```markdown
     ### Phase 2: Core Implementation ✅ COMPLETE
     ```

4. **Update "📍 Current Work" section**:
   - **If next phase exists**: Advance to next phase (⏳ PENDING)
     ```markdown
     ## 📍 Current Work
     - **Phase**: [Phase 3 - Testing & Hardening](phase-3/) ⏳ PENDING
     - **Task**: None yet - use `/flow-phase-start` to begin this phase
     ```
   - **If no next phase**: Mark project complete
     ```markdown
     ## 📍 Current Work
     - **Status**: 🎉 All phases complete!
     - **Next**: Consider archiving or planning V2
     ```

5. **Update completion percentages**:
   - Recalculate phase percentages
   - Update "📈 Completion Status" section
   - Update overall project percentage

6. **Update "Last Updated" timestamp** at top of dashboard

7. **Confirm to user**:
   ```
   ✅ Completed Phase [N]: [Name]

   **What's Next**:
   - **Next phase exists?** → Use `/flow-phase-start` to begin Phase [N+1]: [Name]
   - **All phases complete?** → Project finished! 🎉 Use `/flow-summarize` to review
   ```

**Output**: Updated `DASHBOARD.md` with phase completion and next steps.
```

---

## /flow-task-add

**File**: `flow-task-add.md`

```markdown
---
description: Create a new task file in current phase directory
---

You are executing the `/flow-task-add` command from the Flow framework.

**Purpose**: Create a new task file in the current phase directory and update DASHBOARD.md.

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-600 (Quick Reference) - if not already in context
- **Focus on**: Task Structure Rules (lines 164-223) - ALL tasks have iterations
- **Read task template**: Lines 2383-2472 for task file template (with iterations)

**Multi-File Architecture**: This command:
- Creates `phase-N/task-M.md` file
- Updates `DASHBOARD.md` with new task
- Optionally updates `PLAN.md` if phase description needs updating

**Instructions**:

1. **INPUT VALIDATION**:

   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "❌ Missing task name. Example: /flow-task-add 'User Authentication'"
     STOP
   ```

   Accept minimal input - will use [TBD] for missing metadata.

2. **Read DASHBOARD.md**:
   - Find current phase from "📍 Current Work" section
   - Count existing tasks in current phase to determine next task number
   - Example: If phase-2/ has task-1.md and task-2.md, new task is task-3.md

3. **Parse arguments and infer metadata**:

   From `$ARGUMENTS`, extract or infer:
   - **Task name**: Use $ARGUMENTS directly
   - **Purpose**: Try to infer:
     - "User Authentication" → "Implement user authentication system"
     - "API Design" → "Design and document API endpoints"
     - "Database Schema" → "Design and implement database schema"
     - "Testing" → "Implement testing infrastructure"
     - Can't infer → "[TBD] - Define during task start"
   - **Task structure**: ALL tasks have iterations (no standalone tasks)
     - Simple tasks → 1-2 iterations with direct action items
     - Complex tasks → Multiple iterations with brainstorming
     - Always create with at least 1 iteration

4. **Create task file**:

   Create `phase-N/task-M.md` using template from DEVELOPMENT_FRAMEWORK.md:

   ```markdown
   # Task [M]: [Task Name]

   **Status**: ⏳ PENDING
   **Phase**: [Phase N - Name](../DASHBOARD.md#phase-N-name)
   **Purpose**: [Inferred or [TBD]]

   ---

   ## Task Overview

   [Brief description based on task name]

   **Why This Task**: [TBD] - Define during task start or brainstorming

   [If complex task - add Dependencies section:]
   **Dependencies**:
   - **Requires**: [TBD]
   - **Blocks**: [TBD]

   ---

   ## Iterations

   ### ⏳ Iteration 1: [TBD]

   **Goal**: [TBD] - Define during brainstorming or task start

   **Status**: ⏳ PENDING

   ---

   #### Action Items

   - [ ] [TBD] - Define during brainstorming or add directly

   ---

   ## Task Notes

   **Discoveries**: (To be filled during work)

   **Decisions**: (To be filled during work)

   **References**: (Add relevant code/docs here)
   ```

5. **Update DASHBOARD.md**:

   Add to current phase in "📊 Progress Overview" section:
   ```markdown
   - ⏳ **Task [M]**: [Task Name]
   ```

   Update "📈 Completion Status":
   - Increment task count for current phase
   - Update phase completion percentage

   Update "🎯 Next Actions" if this is the first task:
   - "Use /flow-task-start to begin Task [M]"

6. **Update DASHBOARD.md timestamp**:
   - Update "Last Updated" to current timestamp

7. **Confirm to user**:
   ```
   "✅ Created Task [M]: [Task Name]

   📂 Created: .flow/phase-N/task-M.md
   📝 Updated: DASHBOARD.md

   [If used [TBD]:]
   📝 Used [TBD] placeholders for: [Purpose/Action Items/Iterations]
   💡 Refine during task start or brainstorming

   🎯 Next Steps:
   - Use `/flow-task-start` to begin work on this task
   - Use `/flow-iteration-add` to add more iterations (if needed)
   - Use `/flow-brainstorm-start` when ready to design"
   ```

**Output**: Create phase-N/task-M.md file and update DASHBOARD.md.

```

---

## /flow-task-start

**File**: `flow-task-start.md`

```markdown
---
description: Mark current task as in progress
---

You are executing the `/flow-task-start` command from the Flow framework.

**Purpose**: Mark the current task as 🚧 IN PROGRESS (when first iteration starts).

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**
- State transition (⏳ PENDING → 🚧 IN PROGRESS)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 567-613 for lifecycle context

**Multi-File Architecture**: This command:
- Updates task status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` current work section
- Auto-starts parent phase if needed

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this task that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📊 Progress Overview" section
   - Locate current phase (🚧 IN PROGRESS or ⏳ PENDING)
   - Find next ⏳ PENDING task in that phase

2. **Determine target task**:
   - Use first ⏳ PENDING task in current phase
   - Extract phase number N and task number M

3. **Update task file** (`phase-N/task-M.md`):
   - Change task status at top of file:
     ```markdown
     **Status**: ⏳ PENDING
     ```
     Becomes:
     ```markdown
     **Status**: 🚧 IN PROGRESS
     ```

4. **Update parent phase status** (if needed):
   - If phase is ⏳ PENDING: Change to 🚧 IN PROGRESS in DASHBOARD.md
   - If phase already 🚧 IN PROGRESS: Skip this step

5. **Update DASHBOARD.md**:

   a. **Update "📍 Current Work" section**:
      ```markdown
      ## 📍 Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: None yet - use `/flow-iteration-add` or `/flow-brainstorm-start`
      ```

   b. **Update task status in "📊 Progress Overview"**:
      - Change task marker from ⏳ to 🚧
      - Example:
        ```markdown
        - ⏳ **Task 3**: API Integration (0/4 iterations)
        ```
        Becomes:
        ```markdown
        - 🚧 **Task 3**: API Integration (0/4 iterations) ← CURRENT
        ```

   c. **Update "Last Updated" timestamp** at top

6. **Confirm to user**:
   ```
   ✅ Started Task [N]: [Name]

   Next steps:
   - Use `/flow-iteration-add [name]` to add iterations
   - Or use `/flow-brainstorm-start [topics]` to plan this task
   ```

**Output**:
- Updated `phase-N/task-M.md` status
- Updated `DASHBOARD.md` current work and task status
```

---

## /flow-task-complete

**File**: `flow-task-complete.md`

```markdown
---
description: Mark current task as complete
---

You are executing the `/flow-task-complete` command from the Flow framework.

**Purpose**: Mark the current task as ✅ COMPLETE (when all iterations done).

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- State transition (🚧 IN PROGRESS → ✅ COMPLETE)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 567-613 for completion criteria

**Multi-File Architecture**: This command:
- Updates task status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with completion and next work

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current task: Phase N, Task M
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Verify all iterations marked ✅ COMPLETE
   - If incomplete iterations found:
     ```
     ❌ Cannot complete task - incomplete iterations found:
     - Iteration 2: Error Handling (🚧 IN PROGRESS)
     - Iteration 3: Retry Logic (⏳ PENDING)

     Complete all iterations first or mark as ❌ CANCELLED / 🔮 DEFERRED.
     ```

3. **Update task file** (`phase-N/task-M.md`):
   - Change task status at top:
     ```markdown
     **Status**: 🚧 IN PROGRESS
     ```
     Becomes:
     ```markdown
     **Status**: ✅ COMPLETE
     ```

4. **Update DASHBOARD.md**:

   a. **Update task status in "📊 Progress Overview"**:
      - Change task marker from 🚧 to ✅
      - Remove "← CURRENT" indicator
      - Example:
        ```markdown
        - 🚧 **Task 3**: API Integration (4/4 iterations) ← CURRENT
        ```
        Becomes:
        ```markdown
        - ✅ **Task 3**: API Integration (4/4 iterations)
        ```

   b. **Update "📍 Current Work" section**:
      - **If more tasks in phase**: Advance to next task
        ```markdown
        ## 📍 Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 4 - Webhook Handler](phase-2/task-4.md) ⏳ PENDING
        - **Next**: Use `/flow-task-start` to begin this task
        ```
      - **If all tasks in phase complete**: Suggest phase completion
        ```markdown
        ## 📍 Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/) - All tasks complete!
        - **Next**: Use `/flow-phase-complete` to mark phase as done
        ```

   c. **Update completion percentages**:
      - Recalculate phase percentage
      - Recalculate overall percentage
      - Update "📈 Completion Status" section

   d. **Update "Last Updated" timestamp** at top

5. **Confirm to user**:
   ```
   ✅ Completed Task [N]: [Name]

   **What's Next**:
   - **More tasks in phase?** → Use `/flow-task-start` to begin Task [N+1]: [Name]
   - **All tasks complete?** → Use `/flow-phase-complete` to mark phase as done
   ```

**Output**:
- Updated `phase-N/task-M.md` status
- Updated `DASHBOARD.md` with completion and next work
```

---

## /flow-iteration-add

**File**: `flow-iteration-add.md`

```markdown
---
description: Add a new iteration under the current task
---

You are executing the `/flow-iteration-add` command from the Flow framework.

**Purpose**: Add a new iteration to the current task file and update DASHBOARD.md.

**Multi-File Architecture**: This command:
- Adds iteration section to `phase-N/task-M.md` file
- Updates `DASHBOARD.md` with new iteration

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Iteration Patterns, Task Structure Rules
- **Deep dive if needed**: Read lines 238-566 for Task Structure Rules using Read(offset=238, limit=329)

**🚨 SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this iteration that are NOT part of the current work:

1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Navigate from dashboard** (dashboard-first pattern):
   - Read `DASHBOARD.md`
   - Find current phase and task from "📍 Current Work" section
   - Extract: Phase number N, Task number M

2. **Parse arguments**:
   - `iteration_name` = Name/goal of iteration (required)
   - `iteration_description` = Optional description

3. **Read current task file**:
   - Open `phase-N/task-M.md`
   - Count existing iterations to determine next iteration number
   - Find "## Iterations" section

4. **Add new iteration section** to task file:

   ```markdown
   ### ⏳ Iteration [N]: [iteration_name]

   **Goal**: [iteration_name expanded or iteration_description if provided]
   **Status**: ⏳ PENDING

   ---
   ```

   **Template Notes**:
   - Place AFTER last iteration in "## Iterations" section
   - Use `###` heading level (three hashes)
   - Status always starts as ⏳ PENDING
   - Infer goal from iteration_name if no description provided

5. **Update DASHBOARD.md**:

   a. **Find current task entry** in "📊 Progress Overview" section

   b. **Update task iteration count**:
      - Change: `- 🚧 **Task 3**: API Integration (1/3 iterations)`
      - To: `- 🚧 **Task 3**: API Integration (1/4 iterations)`

   c. **Add iteration to expanded list** (if task is expanded):
      ```markdown
      - 🚧 **Task 3**: API Integration (1/4 iterations) ← CURRENT
        - ✅ Iteration 1: REST Client Setup
        - 🚧 Iteration 2: Error Handling ← ACTIVE
        - ⏳ Iteration 3: Retry Logic
        - ⏳ Iteration 4: [NEW ITERATION NAME]
      ```

   d. **Update completion percentages**:
      - Recalculate phase percentage: `(completed_iterations / total_iterations) * 100`
      - Recalculate overall percentage
      - Update "📈 Completion Status" section

   e. **Update "Last Updated" timestamp** at top of dashboard

6. **Confirm to user**:
   ```
   ✅ Added Iteration [N]: [iteration_name] to Task [M]: [Task Name]

   Next steps:
   - Use `/flow-brainstorm-start [topics]` to plan this iteration
   - Or add more iterations with `/flow-iteration-add [name]`
   ```

**Output**:
- Updated `phase-N/task-M.md` with new iteration section
- Updated `DASHBOARD.md` with iteration count and percentages

```

---

## /flow-brainstorm-start

**File**: `flow-brainstorm-start.md`

```markdown
---
description: Start brainstorming session with user-provided topics
---

You are executing the `/flow-brainstorm-start` command from the Flow framework.

**Purpose**: Begin a brainstorming session for the current iteration with subjects provided by the user.

**🔴 REQUIRED: Read Framework Quick Reference First**
- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types, Common Patterns
- **Deep dive if needed**: Read lines 1167-1797 for complete Brainstorming Pattern using Read(offset=1167, limit=631)

**Framework Reference**: This command requires framework knowledge to structure brainstorming session correctly. See Quick Reference guide above for essential patterns.

**Signature**: `/flow-brainstorm-start [optional: free-form text describing topics to discuss]`

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates brainstorming section in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with "🚧 BRAINSTORMING" status

**🚨 SCOPE BOUNDARY RULE** (CRITICAL - see DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues during brainstorming that are NOT part of the current iteration:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Why This Matters**: User stays in control of priorities, AI finds issues proactively but doesn't make scope decisions

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Check status (should be ⏳ PENDING or 🚧 IN PROGRESS)

3. **Determine mode** (two modes available):

   **MODE 1: With Argument** (user provides topics in command)
   - User provided topics in `topics` parameter (free-form text)
   - Parse the user's input and extract individual subjects
   - User controls WHAT to brainstorm, AI structures HOW
   - Example: `/flow-brainstorm-start "API design, database schema, auth flow, error handling"`
   - AI extracts: [API design, database schema, auth flow, error handling]
   - **Proceed to step 4**

   **MODE 2: Without Argument** (interactive) ⚠️ CRITICAL
   - **NO arguments provided** by user
   - **DO NOT** auto-generate subjects from iteration description
   - **DO NOT** read task file and invent subjects automatically
   - **DO NOT** proceed to create brainstorming section yet
   - **STOP and ask the user**:

     Example prompt to user:
     ```
     I'll start a brainstorming session for Iteration [K]: [Name].

     **What subjects would you like to discuss?**

     You can provide:
     - Comma-separated topics: "API design, database, auth"
     - Free-form text describing areas to explore
     - Bullet list of specific topics

     Based on the iteration scope, here are some suggestions:
     - [Suggestion 1 based on iteration goal]
     - [Suggestion 2 based on iteration goal]
     - [Suggestion 3 based on iteration goal]

     Please provide the topics you'd like to brainstorm.
     ```

   - **WAIT for user response** - do NOT proceed without it
   - **After user responds**, extract subjects from their response
   - **Then proceed to step 4**

4. **Extract subjects from user input** (ONLY after user provides topics):
   - Parse natural language text from user's input
   - Identify distinct topics/subjects (comma-separated, "and", bullet points, etc.)
   - Create numbered list
   - Handle 1 to 100+ topics gracefully
   - If ambiguous, ask user for clarification

5. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** to 🚧 IN PROGRESS (if ⏳ PENDING):
      ```markdown
      ### ⏳ Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### 🚧 Iteration 2: Error Handling
      ```

   b. **Create brainstorming section** in iteration:
      ```markdown
      #### Brainstorming Session - Error Handling Strategy

      **Focus**: Design comprehensive error handling for Stripe API integration

      **Subjects to Discuss** (tackle one at a time):

      1. ⏳ **API Error Types** - What errors can Stripe return?
      2. ⏳ **Error Mapping** - How to map Stripe errors to our domain?
      3. ⏳ **Retry Strategy** - When to retry, exponential backoff?
      4. ⏳ **User Experience** - How to communicate errors to users?

      **Resolved Subjects**:

      ---
      ```

6. **Update DASHBOARD.md**:

   a. **Update "📍 Current Work" section**:
      ```markdown
      ## 📍 Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) 🚧 BRAINSTORMING
      - **Focus**: Designing comprehensive error handling strategy
      ```

   b. **Update iteration status in "📊 Progress Overview"**:
      - Change iteration marker to show 🚧 with "BRAINSTORMING" indicator

   c. **Update "Last Updated" timestamp** at top

7. **Confirm to user** (only after creating brainstorming section):
   ```
   ✅ Started brainstorming session with [N] subjects for Iteration [K]: [Name]

   **Subjects**:
   1. [Subject 1]
   2. [Subject 2]
   3. [Subject 3]
   ...

   Use `/flow-next-subject` to start discussing the first subject.
   ```

**Key Principles**:
- ✅ **User always provides topics** (via argument or when prompted)
- ❌ **AI NEVER invents subjects** from iteration description without user input
- ❌ **AI NEVER auto-generates** a subject list when no argument provided
- ✅ **If no argument**: STOP, suggest topics, WAIT for user response
- ✅ **After user provides topics**: THEN create brainstorming section

**Output**:
- Updated `phase-N/task-M.md` with brainstorming section
- Updated `DASHBOARD.md` with "🚧 BRAINSTORMING" status

```

---

## /flow-brainstorm-subject

**File**: `flow-brainstorm-subject.md`

```markdown
---
description: Add a subject to discuss in brainstorming
---

You are executing the `/flow-brainstorm-subject` command from the Flow framework.

**Purpose**: Add a new subject to the current brainstorming session.

**🔴 REQUIRED: Read Framework Quick Reference First**
- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Creation Patterns (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates "Subjects to Discuss" list in `phase-N/task-M.md`

**🚨 SCOPE BOUNDARY RULE** (CRITICAL):

Adding subjects dynamically is a KEY feature of Flow. When you discover NEW issues while discussing current subjects:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking current subject resolution)
   - **B**: Add as new brainstorming subject (this command - design needed)
   - **C**: Handle immediately as part of current subject (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Parse arguments**: `subject_text` = subject name and optional brief description

3. **Read current task file** (`phase-N/task-M.md`):
   - Find current iteration's brainstorming session
   - Locate "Subjects to Discuss" section

4. **Add subject to list** in task file:
   - Count existing subjects
   - Append new subject:
     ```markdown
     5. ⏳ **[Subject Text]** - [Brief description if provided]
     ```

5. **Update task file**: Save changes to `phase-N/task-M.md`

6. **Confirm to user**:
   ```
   ✅ Added Subject [N]: [Subject Text] to brainstorming session

   Use `/flow-next-subject` to discuss subjects in order.
   ```

**Output**: Updated `phase-N/task-M.md` with new subject in "Subjects to Discuss" list.
```

---

## /flow-brainstorm-review

**File**: `flow-brainstorm-review.md`

```markdown
---
description: Review all resolved subjects, suggest follow-up work
---

You are executing the `/flow-brainstorm-review` command from the Flow framework.

**Purpose**: Review all resolved brainstorming subjects, verify completeness, summarize decisions, show action items, and suggest follow-up work (iterations/pre-tasks) before marking the brainstorming session complete.

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types (A/B/C/D) (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Session Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Reads brainstorming session from `phase-N/task-M.md`
- Reviews all resolved subjects and suggests next steps
- **READ-ONLY** - No file changes (user confirms before completing)

**This is the review gate before `/flow-brainstorm-complete`.**

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K's brainstorming session
   - Read all "Subjects to Discuss" and "Resolved Subjects"

3. **Verify all subjects resolved**:

   - Check "Subjects to Discuss" section in task file
   - Count total subjects vs ✅ resolved subjects
   - If ANY subjects remain unmarked (⏳ PENDING), warn user: "Not all subjects resolved. Run `/flow-next-subject` to complete remaining subjects."
   - If all subjects are ✅ resolved, proceed to next step

4. **Summarize resolved subjects**:

   - Read all entries in "Resolved Subjects" section
   - Create concise summary of each resolution:
     - Subject name
     - Decision made
     - Key rationale points
   - Present in numbered list format

5. **Show all action items**:

   - Extract all documented action items from resolved subjects
   - Categorize by type:
     - **Pre-Implementation Tasks**: Work that must be done BEFORE implementing this iteration
     - **Follow-up Iterations**: Future work to tackle after this iteration
     - **Documentation Updates**: Files/docs that need changes
     - **Other Actions**: Miscellaneous tasks
   - Present in organized format

6. **Categorize action items** (CRITICAL - Ask user to clarify):

   **The 3 Types of Action Items**:

   **Type 1: Pre-Implementation Tasks (Blockers)**
   - Work that MUST be done BEFORE starting main implementation
   - Examples: Refactor legacy code, fix blocking bugs, setup infrastructure
   - These become separate "Pre-Implementation Tasks" section
   - Must be ✅ COMPLETE before running `/flow-implement-start`

   **Type 2: Implementation Work (The Iteration Itself)**
   - The actual work of the current iteration
   - Examples: Command updates, feature additions, new logic
   - These stay as action items IN the iteration description
   - Work on these AFTER running `/flow-implement-start`

   **Type 3: New Iterations (Future Work)**
   - Follow-up work for future iterations
   - Examples: V2 features, optimizations, edge cases discovered
   - Create with `/flow-iteration-add`

   **Decision Tree for AI**:
   - Extract all action items from resolved subjects
   - For each action item, ask yourself:
     - "Does this BLOCK the main work?" → Type 1 (Pre-task)
     - "Is this THE main work?" → Type 2 (Implementation)
     - "Is this FUTURE work?" → Type 3 (New iteration)
   - **If uncertain, ASK THE USER**: "I found these action items. Are they:
     - A) Blockers that must be done first (pre-tasks)
     - B) The implementation work itself
     - C) Future work for new iterations"

   Present categorization in this format:

     ```
     **Pre-Implementation Tasks** (Type 1 - complete before /flow-implement-start):
     - [Task description] - Why it blocks: [reason]

     **Implementation Work** (Type 2 - these ARE the iteration):
     - [Action item 1]
     - [Action item 2]
     (These stay in iteration, work on after /flow-implement-start)

     **New Iterations** (Type 3 - add with /flow-iteration-add):
     - Iteration N+1: [Name] - [Why it's future work]
     ```

7. **Consolidate Resolution Items into Action Items section** (CRITICAL - NEW PATTERN):

   After user confirms categorization:

   - **Extract all "Resolution Items" from Type D subjects**:
     - Read all resolved subjects with "Resolution Type: D"
     - Each Type D subject has a "Resolution Items" list
     - Collect all Resolution Items into a single consolidated list

   - **Replace iteration's Action Items section**:
     ```markdown
     #### Action Items

     (Consolidated from Resolution Items above by `/flow-brainstorm-review`)

     - [ ] [Resolution Item 1 from Subject 1]
     - [ ] [Resolution Item 2 from Subject 1]
     - [ ] [Resolution Item 1 from Subject 2]
     - [ ] [Resolution Item 2 from Subject 2]
     - [ ] [Resolution Item 1 from Subject 3]
     ```

   - **Key Points**:
     - ONE Action Items section per iteration (single source of truth)
     - Preserves all Resolution Items from all Type D subjects
     - Add header comment: "(Consolidated from Resolution Items above by `/flow-brainstorm-review`)"
     - All checkboxes start as unchecked `- [ ]`
     - Resolution Items in subjects remain unchanged (for context)

   - **If NO Type D items** (all subjects are Type A/B/C):
     - Create minimal Action Items section referencing pre-tasks or other work

8. **Await user confirmation**:
   - Do NOT automatically create iterations or pre-tasks
   - Show categorization above
   - Ask: "Does this categorization look correct? Should I adjust anything?"
   - If user confirms Type 1 (pre-tasks) exist: Ask if they want them created now
   - If user confirms Type 3 (new iterations): Ask if they want them created now
   - After confirmation: Ask about action items consolidation (step 7)

9. **Show "What's Next" Section**:
   ```markdown
   ## 🎯 What's Next

   **After reviewing**:
   1. If pre-implementation tasks were identified → Create them in "Pre-Implementation Tasks" section
   2. If new iterations were suggested → Use `/flow-iteration-add` to create each one
   3. Once all pre-tasks are ✅ COMPLETE → Run `/flow-brainstorm-complete` to mark iteration 🎨 READY

   **Decision Tree**:
   - Pre-tasks needed? → Create them, complete them, THEN run `/flow-brainstorm-complete`
   - No pre-tasks? → Run `/flow-brainstorm-complete` immediately
   - Need more iterations? → Use `/flow-iteration-add [description]` first
   ```

**Output**:
- **READ-ONLY** - No files modified
- Comprehensive review summary with actionable suggestions, awaiting user confirmation
- User must confirm before proceeding to `/flow-brainstorm-complete`
```

---

## /flow-brainstorm-complete

**File**: `flow-brainstorm-complete.md`

```markdown
---
description: Complete brainstorming and generate action items
---

You are executing the `/flow-brainstorm-complete` command from the Flow framework.

**Purpose**: Close the current brainstorming session (only after pre-implementation tasks are done).

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Completion Criteria (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates iteration status to 🎨 READY in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with "🎨 READY FOR IMPLEMENTATION" status

**IMPORTANT**: Pre-implementation tasks should be documented in task file during brainstorming, then completed BEFORE running this command.

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K
   - Verify all subjects in "Subjects to Discuss" are ✅ resolved

3. **Check for pre-implementation tasks** in task file:

   - Look for "#### Pre-Implementation Tasks" section in iteration
   - If found:
     - Check if all pre-tasks are marked ✅ COMPLETE
     - If any are ⏳ PENDING or 🚧 IN PROGRESS:
       ```
       ❌ Pre-implementation tasks exist but are not complete:
       - [Task 1]: ⏳ PENDING
       - [Task 2]: 🚧 IN PROGRESS

       Complete them first, then run this command again.
       ```
     - If all are ✅ COMPLETE: Proceed to step 4
   - If not found: Proceed to step 4

4. **Verify iteration has up-to-date action items**:

   - Read the iteration's goal or action items
   - Check if they reference the brainstorming session:
     - ✅ **Good patterns**:
       - References brainstorming subjects
       - Has action items from Type D resolutions
     - ❌ **Outdated patterns**:
       - No reference to brainstorming
       - Action items don't match resolved subjects

   - **If action items are outdated**:
     - Warn user: "The iteration's action items don't reference the brainstorming session. Should I update them to match the brainstorming subjects?"
     - Wait for user confirmation

   - **If action items are up-to-date**: Proceed to step 5

5. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from 🚧 to 🎨:
      ```markdown
      ### 🚧 Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### 🎨 Iteration 2: Error Handling
      ```

   b. **Add completion note** after brainstorming session:
      ```markdown
      **Brainstorming Status**: ✅ COMPLETE
      **Pre-Implementation Tasks**: ✅ COMPLETE (if applicable)
      **Ready for**: `/flow-implement-start`
      ```

6. **Update DASHBOARD.md**:

   a. **Update "📍 Current Work" section**:
      ```markdown
      ## 📍 Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) 🎨 READY FOR IMPLEMENTATION
      - **Next**: Use `/flow-implement-start` to begin implementation
      ```

   b. **Update iteration status in "📊 Progress Overview"**:
      - Change iteration marker to show 🎨 READY

   c. **Update "Last Updated" timestamp** at top

7. **Confirm to user**:
   ```
   ✅ Brainstorming session complete! Iteration [K]: [Name] marked 🎨 READY FOR IMPLEMENTATION

   **Next Step**: Use `/flow-implement-start` to begin implementation

   **Reminder**: If you discover new issues during implementation (scope violations), STOP and discuss with the user before proceeding.
   ```

**Output**:
- Updated `phase-N/task-M.md` with 🎨 READY status
- Updated `DASHBOARD.md` with "🎨 READY FOR IMPLEMENTATION"
```

---

## /flow-implement-start

**File**: `flow-implement-start.md`

```markdown
---
description: Begin implementation of current iteration
---

You are executing the `/flow-implement-start` command from the Flow framework.

**Purpose**: Begin implementation phase for the current iteration.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task file**

- State transition (🎨 READY/⏳ PENDING → 🚧 IMPLEMENTING)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 1798-1836 for implementation workflow

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current work
- Updates iteration status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` current work section
- **Prerequisite**: Brainstorming must be ✅ COMPLETE and all pre-implementation tasks done

**🚨 SCOPE BOUNDARY RULE** (CRITICAL - see DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues during implementation that are NOT part of the current iteration's action items:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Exception**: Syntax errors or blocking bugs in files you must modify (document what you fixed in Implementation Notes)

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current task: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Check iteration status (should be 🎨 READY or ⏳ PENDING)

3. **Read Testing Strategy** (CRITICAL):
   - Read `PLAN.md` "## Testing Strategy" section
   - Understand verification methodology (simulation, unit tests, TDD, manual QA)
   - Note file locations, naming conventions
   - **IMPORTANT**: Follow Testing Strategy exactly - do NOT violate conventions

4. **Verify readiness** (if iteration was 🎨 READY):
   - Brainstorming should be marked ✅ COMPLETE
   - All pre-implementation tasks should be ✅ COMPLETE
   - If not ready: Warn user and ask to complete brainstorming/pre-tasks first

5. **Handle ⏳ PENDING iterations** (no brainstorming yet):
   - Ask user: "Previous iteration complete. Do you want to brainstorm this iteration first (recommended) or skip directly to implementation?"
     - **User chooses brainstorm**: "Please run `/flow-brainstorm-start` first"
     - **User chooses skip**: Proceed with implementation

6. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from 🎨/⏳ to 🚧 IN PROGRESS:
      ```markdown
      ### 🎨 Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### 🚧 Iteration 2: Error Handling
      ```

   b. **Create implementation section** in task file:
      ```markdown
      #### Implementation - Iteration 2: Error Handling

      **Status**: 🚧 IN PROGRESS (2025-01-15)

      **Action Items**: See resolved subjects above (Type D items)

      **Implementation Notes**:
      [Leave blank - filled during work]

      **Files Modified**:
      [Leave blank - filled as work progresses]

      **Verification**: [Leave blank - how work verified]

      ---
      ```

   **IMPORTANT**: Implementation section REFERENCES subjects (don't duplicate action items)

7. **Update parent task status** (if needed):
   - If task is ⏳ PENDING: Change to 🚧 IN PROGRESS in task file AND DASHBOARD.md
   - If task already 🚧: Skip

8. **Update DASHBOARD.md**:

   a. **Update "📍 Current Work" section**:
      ```markdown
      ## 📍 Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) 🚧 IMPLEMENTING
      - **Focus**: Implementing comprehensive error handling with retry logic
      ```

   b. **Update iteration status in "📊 Progress Overview"**:
      - Change iteration marker from 🎨/⏳ to 🚧
      - Add "← ACTIVE" indicator

   c. **Update "Last Updated" timestamp** at top

9. **Confirm to user**:
   ```
   ✅ Started implementation of Iteration [K]: [Name]

   Action items from brainstorming subjects:
   - [List Type D action items from resolved subjects]

   Follow Testing Strategy in PLAN.md for verification.
   ```

**Output**:
- Updated `phase-N/task-M.md` with implementation section
- Updated `DASHBOARD.md` current work

```

---

## /flow-implement-complete

**File**: `flow-implement-complete.md`

```markdown
---
description: Mark current iteration as complete
---

You are executing the `/flow-implement-complete` command from the Flow framework.

**Purpose**: Mark the current iteration as complete.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task file**
- State transition (🚧 IMPLEMENTING → ✅ COMPLETE)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 1798-1836 for completion criteria

**Multi-File Architecture**: This command:
- Updates iteration status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` completion percentages
- Advances to next iteration or suggests task completion

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Verify iteration marked 🚧 IN PROGRESS

3. **Verify completion**:
   - Check brainstorming action items (if brainstorming was done)
   - If unchecked items remain: Ask "There are unchecked action items. Are you sure you want to mark complete?"

4. **Check for existing verification information**:
   - Read Implementation Notes section in task file
   - Review recent conversation (last 5-10 messages) for testing/verification discussion
   - If verification info found: Skip to step 6 (don't ask redundant questions)
   - If NO verification info found: Proceed to step 5

5. **Prompt for verification notes** (ONLY if not already available):
   ```
   How did you verify this iteration works?
   - Tests run? (unit, integration, simulation)
   - Manual checks?
   - Code review?
   ```

6. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from 🚧 to ✅:
      ```markdown
      ### 🚧 Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### ✅ Iteration 2: Error Handling
      ```

   b. **Update implementation section**:
      ```markdown
      #### Implementation - Iteration 2: Error Handling

      **Status**: ✅ COMPLETE (2025-01-15)

      **Implementation Notes**:
      - Created `src/integrations/stripe/ErrorMapper.ts` (98 lines)
      - Created `src/integrations/stripe/RetryPolicy.ts` (76 lines)
      - Updated StripeClient with error handling and retry

      **Files Modified**:
      - `src/integrations/stripe/StripeClient.ts` - Added error handling
      - `src/integrations/stripe/ErrorMapper.ts` - Created
      - [... more files ...]

      **Verification**:
      - ✅ All error mapping tests passing
      - ✅ Retry logic tests passing
      - ✅ Integration test with Stripe API successful
      ```

7. **Check if task/phase complete**:
   - Count iterations: How many ✅ COMPLETE vs total?
   - If all iterations complete: Task is ready for `/flow-task-complete`

8. **Update DASHBOARD.md**:

   a. **Update iteration status in "📊 Progress Overview"**:
      - Change iteration marker from 🚧 to ✅
      - Update iteration count: `(1/4 iterations)` → `(2/4 iterations)`

   b. **Update "📍 Current Work" section**:
      - **If more iterations**: Advance to next iteration
        ```markdown
        ## 📍 Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
        - **Iteration**: [Iteration 3 - Retry Logic](phase-2/task-3.md#iteration-3-retry-logic) ⏳ PENDING
        - **Next**: Use `/flow-brainstorm-start` or `/flow-implement-start`
        ```
      - **If all iterations complete**:
        ```markdown
        ## 📍 Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 3 - API Integration](phase-2/task-3.md) - All iterations complete!
        - **Next**: Use `/flow-task-complete` to mark task as done
        ```

   c. **Update completion percentages**:
      - Recalculate phase percentage
      - Recalculate overall percentage
      - Update "📈 Completion Status" section

   d. **Update "Last Updated" timestamp** at top

9. **Confirm to user**:
   ```
   ✅ Completed Iteration [K]: [Name]

   **What's Next**:
   - **More iterations?** → Use `/flow-brainstorm-start` or `/flow-implement-start` for next iteration
   - **All iterations done?** → Use `/flow-task-complete` to mark task as complete

   **Current state**: [X]/[Y] iterations complete
   ```

**Output**:
- Updated `phase-N/task-M.md` with completion status
- Updated `DASHBOARD.md` with progress and next work

```

---

## /flow-status

**File**: `flow-status.md`

```markdown
---
description: Show current position and project progress
---

You are executing the `/flow-status` command from the Flow framework.

**Purpose**: Display current work position and project progress from the dashboard.

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**
- Dashboard-first approach - reads ONLY DASHBOARD.md
- Extremely efficient: <100 lines to read vs thousands in old architecture
- This is the REFERENCE MODEL command - simplest example of multi-file navigation

**Multi-File Architecture**: Flow now uses separate files:
- `DASHBOARD.md` - Progress tracking (⭐ read by this command)
- `PLAN.md` - Static context (not read by this command)
- `phase-N/task-M.md` - Task details (not read by this command)

**Instructions**:

1. **Find .flow/DASHBOARD.md**:
   ```bash
   # Primary location
   .flow/DASHBOARD.md

   # If not found
   Suggest: "/flow-blueprint to create new project" or "/flow-plan-update to migrate old single-file plan"
   ```

2. **Read DASHBOARD.md** (entire file):
   ```bash
   # Simply read the whole file - it's small and focused
   Read: .flow/DASHBOARD.md
   ```

   DASHBOARD.md contains everything you need:
   - Current work pointer (Phase/Task/Iteration)
   - Progress overview for all phases
   - Completion percentages
   - Next actions
   - Recent activity
   - Last updated timestamp

3. **Extract key information**:

   From "📍 Current Work" section:
   - Current Phase (number and name)
   - Current Task (number and name)
   - Current Iteration (number and name)
   - Current status emoji (⏳ 🚧 🎨 ✅ etc.)
   - Focus description

   From "📊 Progress Overview" section:
   - All phases with their status
   - Tasks within each phase
   - Iteration counts per task
   - Completion indicators

   From "📈 Completion Status" section:
   - Phases: X/Y complete
   - Tasks: X/Y complete
   - Iterations: X/Y complete
   - Overall percentage

   From "🎯 Next Actions" section:
   - Immediate actions (today)
   - Short-term actions (this week)
   - Upcoming milestones

4. **Display formatted status**:

   ```
   # [Project Name] - Status

   📍 **Current Work**
   Phase [N]: [Name] [Status]
     └─ Task [M]: [Name] [Status]
         └─ Iteration [K]: [Name] [Status]

   **Focus**: [Current focus description from dashboard]

   ---

   📊 **Progress Overview**

   ### Phase 1: [Name] [Status]
   - Task 1: [Name] [Status] ([X/Y iterations])
   - Task 2: [Name] [Status] ([X/Y iterations])

   ### Phase 2: [Name] [Status] ← CURRENT
   - Task 1: [Name] [Status] ([X/Y iterations])
   - Task 2: [Name] [Status] ([X/Y iterations]) ← CURRENT

   ### Phase 3: [Name] [Status]
   ...

   ---

   📈 **Completion**
   - Phases: [X/Y] ([percentage]%)
   - Tasks: [X/Y] ([percentage]%)
   - Iterations: [X/Y] ([percentage]%)
   - **Overall**: [percentage]%

   ---

   🎯 **Next Actions**
   Immediate:
   - [Action 1]
   - [Action 2]

   Short-term:
   - [Goal 1]
   - [Goal 2]

   ---

   📝 **Recent Activity**
   [Show 3-5 most recent items from dashboard]

   ---

   **Last Updated**: [Timestamp from dashboard]
   ```

5. **Suggest next action** (based on current iteration status):

   Read the current iteration status from dashboard and suggest:

   **If ⏳ PENDING**:
   → "Use `/flow-brainstorm-start` to begin brainstorming this iteration"

   **If 🚧 IN PROGRESS (Brainstorming)**:
   → "Use `/flow-next-subject` to continue brainstorming"
   → Or check "Next Actions" section in dashboard for specific guidance

   **If 🚧 IN PROGRESS (Implementing)**:
   → "Continue implementation. Use `/flow-implement-complete` when done"

   **If 🎨 READY**:
   → "Use `/flow-implement-start` to begin implementation"

   **If ✅ COMPLETE**:
   → "Use `/flow-iteration-add` to add next iteration"
   → Or if task complete: "Use `/flow-task-complete` to finish this task"

6. **Optional: Verify dashboard is up-to-date**:

   Check "Last Updated" timestamp:
   - If recent (< 1 hour): All good
   - If stale (> 24 hours): Suggest running `/flow-verify-plan` to check consistency

   Note: Don't read task files to verify - that's `/flow-verify-plan`'s job. This command trusts the dashboard.

**Key Principle**: DASHBOARD.md is the source of truth for current state. This command simply displays what's in the dashboard - it doesn't validate against task files (that's what `/flow-verify-plan` does).

**Output**: Formatted status display with current position, progress overview, completion stats, and next action suggestion.

```

---

## /flow-summarize

**File**: `flow-summarize.md`

```markdown
---
description: Generate summary of all phases/tasks/iterations
---

You are executing the `/flow-summarize` command from the Flow framework.

**Purpose**: Generate high-level overview of entire project structure and completion state.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task files**
- Uses DASHBOARD.md for high-level view
- Reads task files for detailed iteration status
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 105-179 for hierarchy context

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` for overall structure
- Reads all `phase-N/task-M.md` files for detailed status
- Generates comprehensive summary from all files

**Use case**: "Bird's eye view" of project health, progress across all phases, quick status reports

**Comparison to other commands**:
- `/flow-status` = "Where am I RIGHT NOW?" (micro view - reads DASHBOARD.md only)
- `/flow-summarize` = "What's the WHOLE PICTURE?" (macro view - reads all files)
- `/flow-verify-plan` = "Is this accurate?" (validation)

**Instructions**:

1. **Read DASHBOARD.md**:
   - Extract current work position
   - Get all phases and tasks from "📊 Progress Overview"
   - Get completion percentages from "📈 Completion Status"

2. **Read all task files**:
   - List all phase directories: `ls .flow/phase-*/`
   - For each phase, list task files: `ls .flow/phase-N/`
   - Read each `phase-N/task-M.md` to get:
     - Task status
     - All iterations with status markers
     - Brainstorming status (if applicable)

3. **Generate structured summary** (compact, scannable format):

```

📊 Flow Summary

Version: [V1/V2/V3]
Status: [Current phase/task/iteration from metadata]

Phase [N]: [Name] [Status] [%]

- Task [N]: [Name] [Status]
  - Iter [N-N] [Status]: [Concise description]
  - Iter [N] 🚧 CURRENT: [What you're working on]
  - Iter [N] ⏳: [What's next]

Phase [N]: [Name] [Status] [%]

- Task [N-N]: [Grouped if similar] [Status]
- Task [N]: [Name] [Status]

Deferred to V2:

- [Iteration/feature name]
- [Iteration/feature name]

---

TL;DR: [One punchy sentence about overall state]

```

4. **Formatting rules**:
- **Compact**: Group consecutive completed iterations (e.g., "Iter 1-5 ✅")
- **Scannable**: Use emojis (✅ ⏳ 🚧 🎨) and percentages prominently
- **Highlight**: Mark CURRENT work explicitly in bold or with flag
- **Indent**: Phase (no indent), Task (- prefix), Iteration (-- or nested -)
- **Defer section**: Show V2/future items at bottom
- **Skip noise**: Don't list every task name if they're obvious/sequential
- **Focus on active work**: Emphasize in-progress and next items

5. **Example output** (payment gateway):

```

📊 Flow Summary

Version: V1
Status: Phase 2, Task 5, Iteration 2 - In Progress

Phase 1: Foundation ✅ 100%

- Task 1-2: Setup, API, Database schema ✅

Phase 2: Core Implementation 🚧 75%

- Task 3-4: Payment processing, Webhooks ✅
- Task 5: Error Handling
  - Iter 1 ✅: Retry logic
  - Iter 2 🚧 CURRENT: Circuit breaker
  - Iter 3 ⏳: Dead letter queue

Phase 3: Testing & Integration ⏳ 0%

- Task 6: Integration tests (pending)

Deferred to V2:

- Advanced features (monitoring, metrics)
- Name generation

---

TL;DR: Foundation done, core payment flow working, currently building circuit breaker for error handling.

```

**Example output** (RED project - showing V1/V2 split):

```

📊 Flow Summary - RED Ability Generation

=== V1 - Core System ===

Phase 1: Foundation ✅ 100%

- Task 1-4: Constants, enums, types, refactoring ✅

Phase 2: Core Implementation 🚧 85%

- Iter 1-5 ✅: Tier gen, slots, filtering, selection, template parsing
- Iter 6 🚧 NEXT: Green.generate() integration (ties everything together)
- Iter 7 ⏳: Blue validation (input guards)
- Iter 9 ⏳ LAST: Red API wrapper (exposes Blue → Green)

Phase 3: Testing

- Script-based testing (Blue → Green flow)

Deferred to V2:

- Iter 8: Name generation (stub returns "Generated Ability")
- Database persistence
- Stats-based damage calculations

=== V2 - Enhanced System (Phase 4) ===

Enhancements:

- Potency system (stats × formulas replace fixed damage)
- Name generation (124 weighted prefix/suffix combos)
- 12 new placeholders (conditionals, resources, targeting)
- Damage variance (±10% for crits)
- Points & Luck systems
- Database persistence

---

TL;DR:
V1 = Basic working system with hardcoded damage ranges (85% done, integration next)
V2 = Dynamic formulas, character stats integration, full feature set

```

6. **Add deferred/cancelled sections**:
```

🔮 Deferred Items:

- Iteration 10: Name Generation (V2 - complexity, needs 124 components)
- Task 12: Advanced Features (V2 - out of V1 scope)
- Feature X: Multi-provider support (V3 - abstraction layer)

❌ Cancelled Items:

- Task 8: Custom HTTP Client (rejected - SDK is better)
- Subject 3: GraphQL API (rejected - REST is sufficient)

```

7. **Smart verification** (active work only):
- Skip ✅ COMPLETE items (verified & frozen)
- Verify 🚧 ⏳ 🎨 items match Progress Dashboard
- Check ❌ items have reasons
- Check 🔮 items have reasons + destinations
- Report:
  ```
  🔍 Verification (Active Work Only):
  ✅ All active markers (🚧 ⏳) match Progress Dashboard
  ⏭️  Skipped 18 completed items (verified & frozen)
  ```

8. **Handle multiple versions**:
- If PLAN.md has V2/V3 sections, use `=== V1 Summary ===` separator
- V1 gets full Phase/Task/Iteration breakdown
- V2+ get high-level "Enhancements" list (not full iteration tree)
- Separate TL;DR line for each version

9. **After generating summary**:
- "Use `/flow-status` to see detailed current position"
- "Use `/flow-verify-plan` to verify accuracy against actual code"

**Manual alternative**:
- Read entire PLAN.md manually
- Create outline of all phases/tasks/iterations
- Count completions and calculate percentages
- Format into hierarchical view

**Output**: Hierarchical summary of entire project structure with completion tracking.
```

---

## /flow-next-subject

**File**: `flow-next-subject.md`

```markdown
---
description: Discuss next subject, capture decision, and mark resolved
---

You are executing the `/flow-next-subject` command from the Flow framework.

**Purpose**: Show next unresolved subject, present options collaboratively, wait for user decision, then mark as ✅ resolved.

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types (lines in Quick Reference) - Types A/B/C/D decision matrix
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Reads/updates brainstorming session in `phase-N/task-M.md`
- Marks subjects ✅ resolved in task file

**Framework Reference**: This command requires framework knowledge to properly categorize resolution types. See Quick Reference guide above for essential patterns.

**🚨 SCOPE BOUNDARY RULE** (CRITICAL - see DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues while discussing subjects that are NOT part of the current iteration:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Why This Matters**: User stays in control of priorities. AI finds issues proactively but doesn't make scope decisions.

**New Collaborative Workflow** (two-phase approach):
```

Phase 1 (Present):
/flow-next-subject → present subject + options → ask user → 🛑 STOP & WAIT

Phase 2 (Capture - triggered by user response):
User responds → capture decision → document → mark ✅ → auto-advance to next

```

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K's brainstorming session
   - Locate "Subjects to Discuss" section

3. **Find first unresolved subject**: Look for first ⏳ subject in the list

4. **If found** (subject needs discussion):

   **Step A: Present subject**
   - Display subject name and description
   - Present relevant context from iteration goal
   - **DO NOT read codebase files**
   - **DO NOT analyze existing implementation**
   - **DO NOT create detailed solutions**
   - Keep it brief - this is just presenting the topic

   **Step B: Present options and STOP** ⚠️ CRITICAL
   - **DO NOT research code** before presenting options
   - **DO NOT read files** to understand current implementation
   - **DO NOT create detailed architecture diagrams**
   - Suggest 2-4 high-level options/approaches based on GENERAL knowledge
   - Present each option with brief pros/cons (1-2 sentences each)
   - Format as numbered list for clarity
   - Include option for "Your own approach"
   - Ask user explicitly: "Which option do you prefer? Or provide your own approach."
   - **🛑 STOP HERE - Wait for user response (do NOT proceed to capture decision)**
   - **DO NOT** decide on behalf of user
   - **DO NOT** document any decision yet
   - **DO NOT** create massive detailed resolutions
   - Command execution ends here - user will respond in next message

   **Step C: Capture user's decision** (only execute AFTER user responds)
   - Read user's response from their message
   - If decision is clear: proceed to document it
   - If unclear: ask clarifying questions
   - If rationale not provided: ask "What's your reasoning for this choice?"
   - Optional: "Any action items to track for this decision?"
   - **KEEP DOCUMENTATION CONCISE** (1-3 paragraphs, not 336 lines!)
   - **NO massive architecture diagrams** unless user explicitly provides one
   - **NO detailed implementation plans** - save for implementation phase
   - Capture: Decision + Rationale + Action Items (if any)

   **Step D: Document resolution in task file**
   - Mark subject ✅ in "Subjects to Discuss" list (in `phase-N/task-M.md`)
   - Add **CONCISE** resolution section under "Resolved Subjects":
     ```markdown
     ### ✅ **Subject [N]: [Name]**

     **Decision**: [User's decision from their response - 1-2 sentences]

     **Rationale**:
     - [Reason 1 from user or follow-up]
     - [Reason 2]

     **Action Items** (if any):
     - [ ] [Item 1 - brief, not detailed implementation steps]
     - [ ] [Item 2]

     ---
     ```
   - **Example of TOO MUCH**: 336 line resolution with interfaces, diagrams, detailed architecture
   - **Example of GOOD**: 10-20 line resolution with decision, rationale, 3-5 action items

   **Step E: Auto-advance OR prompt for review**
   - Save changes to `phase-N/task-M.md`
   - Show progress: "[N] of [Total] subjects resolved"
   - Check if more ⏳ subjects exist:
     - **If YES** (more pending): Auto-show next unresolved subject
     - **If NO** (all resolved): Show workflow prompt below

5. **If all resolved** (this was the last subject):
   - **Show brief summary** of decisions made
   - **⚠️ CRITICAL - Show "What's Next" Section (MANDATORY - AI MUST NOT SKIP THIS)**:
     ```markdown
     ✅ All subjects resolved!

     ## 🎯 What's Next

     **REQUIRED NEXT STEP**: Run `/flow-brainstorm-review` to:
     - Analyze all resolved subjects
     - Categorize action items (pre-tasks vs implementation vs new iterations)
     - Generate follow-up work suggestions
     - Prepare for implementation

     **DO NOT run `/flow-brainstorm-complete` yet** - review comes first!

     **Workflow Reminder**:
     1. ✅ NOW: `/flow-brainstorm-review` (analyze & suggest)
     2. THEN: Create any pre-tasks if needed
     3. THEN: Complete pre-tasks (if any)
     4. FINALLY: `/flow-brainstorm-complete` (mark 🎨 READY)

     **Why this order matters**: Review identifies blockers (pre-tasks) that must be done before implementation starts.
     ```
   - **AI BEHAVIOR**: Do NOT suggest `/flow-brainstorm-complete` or any other command. The "What's Next" section MUST explicitly guide to `/flow-brainstorm-review` first.

**Key Principle**: Moving to next subject implies current is resolved. No separate "resolve" command needed.

**Output**: Updated `phase-N/task-M.md` with subject resolution and show next subject.
```

---

## /flow-next-iteration

**File**: `flow-next-iteration.md`

```markdown
---
description: Show next iteration details
---

You are executing the `/flow-next-iteration` command from the Flow framework.

**Purpose**: Display details about the next pending iteration in the current task.

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- Finds next ⏳ PENDING iteration in current task
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 567-613 for iteration context

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current task
- Reads `phase-N/task-M.md` to find next pending iteration

**Pattern**: Works like `/flow-next-subject` but for iterations - shows what's coming next.

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current task: Phase N, Task M

2. **Read current task file** (`phase-N/task-M.md`):
   - Find "## Iterations" section
   - Look for first iteration marked ⏳ PENDING

3. **Find next pending iteration**: First ⏳ PENDING iteration in task file

4. **If found, display iteration details**:
```

📋 Next Iteration:

**Iteration [N]**: [Name]

**Goal**: [What this iteration builds]

**Status**: ⏳ PENDING

**Approach**: [Brief description from iteration section if available]

---

Ready to start? Use `/flow-brainstorm-start [topic]` to begin.

```

5. **If NOT found (no pending iterations)**:
- Check if current iteration is in progress: "Still working on Iteration [N]: [Name]. Use `/flow-implement-complete` when done."
- Otherwise: "No more iterations in current task. Use `/flow-iteration-add [description]` to create next iteration, or `/flow-task-complete` if task is done."

6. **Show progress**: "Iteration [current] of [total] in current task"

**Output**: Display next iteration details and suggest appropriate next action.
```

---

## /flow-next

**File**: `flow-next.md`

```markdown
---
description: Smart helper - suggests next action based on current context
---

You are executing the `/flow-next` command from the Flow framework.

**Purpose**: Auto-detect current context and suggest the next logical step.

**🟢 NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- Smart navigation using Dashboard and current context
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 3277-3356 for decision tree reference

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current work
- Reads `phase-N/task-M.md` to determine current state
- Suggests next command based on context

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K
   - Check iteration status (⏳ 🚧 🎨 ✅)

3. **Determine current context**:

   - Check if in brainstorming session:
     - Look for "Subjects to Discuss" section
     - Count unresolved subjects (⏳ markers)
   - Check for pre-implementation tasks:
     - Look for "#### Pre-Implementation Tasks" section
     - Count pending vs complete
   - Check if in main implementation:
     - Look for "#### Implementation" section

4. **Suggest next command based on context**:

   **Determine exact state**:

   **If status = ⏳ PENDING**:
   → "Use `/flow-brainstorm-start [topic]` to begin this iteration"

   **If status = 🚧 IN PROGRESS**:
   **Check phase progression** (in this order):

   1. **Check unresolved subjects**:
      If any "⏳" subjects in "Subjects to Discuss":
      → "Use `/flow-next-subject` to resolve next subject"
      Show: "X subjects remaining: [list]"

   2. **Check pre-implementation tasks**:
      If "### **Pre-Implementation Tasks:**" section exists:
      Count pending tasks (^#### ⏳)

      If pending > 0:
      → "Continue with Task X: [Name]"
      Show: "[X/Y] pre-implementation tasks complete"

      If pending = 0:
      → "Pre-implementation complete. Use `/flow-brainstorm-complete`"

   3. **Check main implementation**:
      If "### **Implementation**" section exists:
      → "Continue main implementation"
      Show: "Use `/flow-implement-complete` when done"

   4. **Default** (subjects resolved, no pre-tasks):
      → "Use `/flow-brainstorm-complete` to finish brainstorming"

   **If status = 🎨 READY**:
   → "Use `/flow-implement-start` to begin implementation"

   **If status = ✅ COMPLETE**:
   → "Use `/flow-next-iteration` to move to next iteration"

4. **Show current status summary**: Brief summary of where you are

**Output**: Suggest appropriate next command based on context.
```

---

## /flow-rollback

**File**: `flow-rollback.md`

```markdown
---
description: Undo last plan change
---

You are executing the `/flow-rollback` command from the Flow framework.

**Purpose**: Undo the last change made to plan files (DASHBOARD.md or task files).

**🟢 NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Undoes last change using CHANGELOG.md
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 1969-2014 for rollback patterns

**Multi-File Architecture**: This command can rollback:
- DASHBOARD.md status updates (phase/task/iteration status changes)
- Task file changes (iteration added, status updated)
- File moves (task archived, moved to backlog)

**Instructions**:

1. **Read CHANGELOG.md**:
   - Look for "📝 Recent Activity" section
   - If no CHANGELOG.md or no recent entries: "No recent changes to rollback."

2. **Identify last change**:

   - Parse last entry in CHANGELOG.md
   - Extract what was changed:
     - "Phase N started" → DASHBOARD.md phase status
     - "Task M completed" → DASHBOARD.md + task file status
     - "Iteration K added" → Task file iteration section
     - "Task M moved to backlog" → File moved to backlog/
     - "Task M archived" → File moved to archive/

3. **Ask for confirmation**:

   - Display last change details:
     ```
     Last change ([Date/Time]):
     - Action: [Description]
     - File(s): [Affected files]
     - Change: [What was modified]

     Rollback this change? (yes/no)
     ```

4. **If confirmed, revert change based on type**:

   **A. Status change rollback**:
   - Read DASHBOARD.md
   - Revert status marker to previous state
   - Example: `🚧 IN PROGRESS` → `⏳ PENDING`
   - Update task file status marker if applicable

   **B. File move rollback**:
   - Move file back: `backlog/phase-N-task-M.md` → `phase-N/task-M.md`
   - Or: `archive/phase-N/task-M.md` → `phase-N/task-M.md`
   - Update DASHBOARD.md to remove archived/backlog markers
   - Update BACKLOG.md or CHANGELOG.md accordingly

   **C. Section added rollback**:
   - Remove last added section from task file
   - Example: Remove last iteration, pre-task, or brainstorm subject
   - Update DASHBOARD.md if iteration count changed

   **D. Checkbox rollback**:
   - Uncheck last checked checkbox in task file
   - Find Implementation section, uncheck last ✅ item

5. **Update CHANGELOG.md**: Add rollback entry

   ```markdown
   ### [Date/Time]
   - 🔄 Rolled back: [Description of reverted change]
   ```

6. **Confirm to user**:

   ```
   ✅ Rolled back: [Description of change]

   **Reverted**:
   - File: [file path]
   - Change: [what was undone]

   CHANGELOG.md updated with rollback entry.
   ```

**Limitation**: Can only rollback one step at a time. For major reverts, manually edit files or use git to revert commits.

**Output**: Revert last change in plan files, update CHANGELOG.md.
```

---

## /flow-verify-plan

**File**: `flow-verify-plan.md`

```markdown
---
description: Verify plan file matches actual codebase state
---

You are executing the `/flow-verify-plan` command from the Flow framework.

**Purpose**: Verify that plan files (DASHBOARD.md, PLAN.md, task files) are synchronized with actual project state.

**🔴 REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Framework Structure validation, Status Markers (in Quick Reference)
- **Deep dive if needed**: Read lines 105-179 for Framework Structure using Read(offset=105, limit=75)

**Multi-File Architecture**: This command verifies:
- `DASHBOARD.md` - Progress tracking and current work pointers
- `PLAN.md` - Static overview (architecture, testing, constraints)
- `phase-N/task-M.md` - Individual task files with iterations
- Task files contain actual action items and implementation details

**Context**:

- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/PLAN.md, .flow/phase-N/task-M.md
- **Use case**: Run before starting new AI session or compacting conversation to ensure context is accurate

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section for current phase/task/iteration
   - Extract current phase number, task number, iteration number
   - Note current iteration status (🚧 IN PROGRESS or 🎨 READY)

2. **Read current task file**:
   - Locate `.flow/phase-N/task-M.md` based on DASHBOARD.md
   - Find current iteration section (marked 🚧 IN PROGRESS or 🎨 READY)
   - Read "Implementation - Iteration [N]" section
   - Identify all action items
   - Note which items are marked as ✅ complete

3. **Verify claimed completions against actual project state**:

   - For each ✅ completed action item, check if it actually exists:
     - "Create UserAuth.ts" → Verify file exists using Glob or Read
     - "Add login endpoint" → Search for login endpoint in code using Grep
     - "Update database schema" → Check schema files exist
   - List any discrepancies found

4. **Check for unreported work**:

   - Look for modified files that aren't mentioned in task file
   - Check git status (if available) for uncommitted changes
   - Identify files that were changed but not documented

5. **Verify DASHBOARD.md accuracy**:
   - Check that current work pointers match actual task file statuses
   - Verify completion percentages align with actual work done
   - Check that phase/task/iteration hierarchy is consistent

6. **Report findings**:
```

📋 Plan Verification Results:

**Current Work** (from DASHBOARD.md):
- Phase [N], Task [M], Iteration [K]

**Task File**: [phase-N/task-M.md](phase-N/task-M.md)

✅ Verified Complete:
- [List action items that are correctly marked complete]

❌ Discrepancies Found:
- [List action items marked complete but evidence not found]
- [List DASHBOARD.md pointers that don't match task files]

📝 Unreported Work:
- [List files changed but not mentioned in task file]

Status: [SYNCHRONIZED / NEEDS UPDATE]

```

7. **If discrepancies found**:
- Ask user: "Plan files are out of sync with project state. Update files now? (yes/no)"
- If yes: Update plan files to reflect actual state:
  - Update task file (phase-N/task-M.md): Uncheck items that aren't actually done
  - Update DASHBOARD.md: Fix current work pointers, completion percentages
  - Add notes about files modified in task file "Implementation Notes" section
  - Update status markers if needed
- If no: "Review discrepancies above and update plan files manually."

8. **If synchronized**:
- "Plan files are synchronized with project state. Ready to continue work."

**Manual alternative**:
- Review DASHBOARD.md for current work location
- Read current task file manually
- Check each completed action item exists in codebase
- Use `git status` and `git diff` to verify changes
- Update task file and DASHBOARD.md to match reality

**Output**: Verification report and optional plan file updates.
```

---

## /flow-compact

**File**: `flow-compact.md`

```markdown
You are executing the `/flow-compact` command from the Flow framework.

**Purpose**: Generate comprehensive conversation report for context transfer to new AI instance.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Generates comprehensive report using DASHBOARD.md, PLAN.md, and task file content
- Uses `/flow-status` dashboard-first logic for current position
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 2327-2362 for context preservation patterns

**Multi-File Architecture**: This command reads:
- `DASHBOARD.md` - Current work location and progress overview
- `PLAN.md` - Architecture, testing strategy, constraints (static context)
- `phase-N/task-M.md` - Current task file with iterations, brainstorming, implementation

**Context**:

- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/PLAN.md, .flow/phase-N/task-M.md
- **Use case**: Before compacting conversation or starting new AI session - ensures zero context loss

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section for current phase/task/iteration
   - Read "📊 Progress Overview" for completed work
   - Read "🎯 Next Actions" for pending items
   - Read "📝 Recent Activity" for conversation history
   - Read "💡 Key Decisions This Week" for important context

2. **Read PLAN.md**:
   - Extract "## 🎯 Project Goal" for feature overview
   - Read "## 🏗️ Architecture" section for technical context
   - Read "## 🧪 Testing Strategy" for quality requirements
   - Read "## 📋 Constraints" for limitations
   - Read "## 🎓 Learning Goals" for educational objectives

3. **Read current task file** (from DASHBOARD.md pointers):
   - Locate `.flow/phase-N/task-M.md`
   - Read "Task Overview" section (purpose, dependencies, scope)
   - Read current iteration brainstorming subjects (decisions, rationale)
   - Read "Implementation - Iteration [N]" section (action items, progress)
   - Read "Task Notes" section (discoveries, decisions, references)

4. **Generate comprehensive report covering**:

   **Current Work Context**:

   - What feature/task are we working on? (from DASHBOARD.md)
   - What phase/task/iteration are we in? (with status)
   - What was the original goal? (from PLAN.md + task Purpose)

   **Conversation History**:

   - What decisions were made during brainstorming? (from task file subjects)
   - What subjects were discussed and resolved? (with resolution types)
   - What pre-implementation tasks were identified and completed? (from task file)
   - What action items were generated? (from Implementation section)

   **Implementation Progress**:

   - What has been implemented so far? (from task file Implementation Notes)
   - What files were created/modified? (from Files Modified section)
   - What verification was done? (from Verification section)
   - What remains incomplete? (unchecked action items)

   **Challenges & Solutions**:

   - What blockers were encountered? (from Implementation Notes)
   - How were they resolved? (from Pre-Implementation Tasks or notes)
   - What design trade-offs were made? (from brainstorming rationale)

   **Next Steps**:

   - What is the immediate next action? (from DASHBOARD.md "🎯 Next Actions")
   - What are the pending action items? (from current iteration)
   - What should the next AI instance focus on?

   **Important Context**:

   - Any quirks or special considerations (from Task Notes)
   - Technical constraints (from PLAN.md + Task Overview dependencies)
   - User preferences or decisions that must be preserved (from decisions)

5. **Report format**:
```

# Context Transfer Report

## Generated: [Date/Time]

## Current Status

[Phase/Task/Iteration with status markers]

## Feature Overview

[What we're building and why]

## Conversation Summary

[Chronological summary of discussions and decisions]

## Implementation Progress

[What's done, what's in progress, what's pending]

## Key Decisions & Rationale

[Critical decisions made with reasoning]

## Files Modified

[List with brief description of changes]

## Challenges Encountered

[Problems and how they were solved]

## Next Actions

[Immediate next steps for new AI instance]

## Critical Context

[Must-know information for continuation]

```

5. **Important guidelines**:
- **Do NOT include generic project info** (tech stack, architecture overview, etc.)
- **Focus ENTIRELY on the feature at hand** and this conversation
- **Do NOT worry about token output length** - comprehensive is better than brief
- **Include WHY, not just WHAT** - decisions need context
- **Be specific** - reference exact file names, function names, line numbers
- **Preserve user preferences** - if user made specific choices, document them

6. **After generating report**:
- "Context transfer report generated. Copy this report to a new AI session to continue work with zero context loss."
- "Use `/flow-verify-plan` before starting new session to ensure plan files (DASHBOARD.md, task files) are synchronized."

**Manual alternative**:
- Read entire conversation history manually
- Read DASHBOARD.md for current status
- Read current task file for detailed context
- Read PLAN.md for architectural constraints
- Summarize key points, decisions, and progress
- Document in separate notes file

**Output**: Comprehensive context transfer report.
```

---

## Installation Instructions

To use these commands:

1. **Copy individual command files** to `.claude/commands/`:

   ```bash
   mkdir -p .claude/commands
   # Copy each command section above into separate .md files
   # Example: flow-blueprint.md, flow-phase.md, etc.
   ```

2. **Or use the copy-paste method**:

   - Copy the content between the code blocks for each command
   - Create corresponding `.md` files in `.claude/commands/`
   - File names should match command names (e.g., `flow-blueprint.md`)

3. **Test with `/help`**: Run `/help` in Claude Code to see your new commands listed

---

## Command Execution Flow

```
/flow-blueprint
    ↓
Creates PLAN.md with skeleton
    ↓
/flow-brainstorm_start
    ↓
/flow-brainstorm-subject (repeat as needed)
    ↓
/flow-brainstorm_resolve (for each subject)
    ↓
Complete pre-implementation tasks (if any)
    ↓
/flow-brainstorm_complete
    ↓
/flow-implement-start
    ↓
Work through action items (check them off)
    ↓
/flow-implement-complete
    ↓
Repeat for next iteration
```

**Helper commands** available at any time:

- `/flow-status` - Check current position
- `/flow-next` - Auto-advance to next step
- `/flow-rollback` - Undo last change
- `/flow-phase-add`, `/flow-task-add`, `/flow-iteration-add` - Add structure as needed
- `/flow-plan-split` - Archive old completed tasks to reduce PLAN.md size

---

## /flow-plan-split

**File**: `flow-plan-split.md`

```markdown
---
description: Archive old completed tasks to reduce PLAN.md size
---

You are executing the `/flow-plan-split` command from the Flow framework.

**Purpose**: Archive old completed tasks to reduce DASHBOARD.md clutter while preserving full project history in `archive/` directory.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Moves completed task FILES to archive/ directory (keeps recent 3 tasks visible)
- Updates DASHBOARD.md and CHANGELOG.md to reflect archived tasks
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 2363-2560 for archival patterns

**Multi-File Architecture**: This command:
- Moves `phase-N/task-M.md` files to `archive/phase-N/task-M.md`
- Updates `DASHBOARD.md` to mark tasks as archived
- Updates `CHANGELOG.md` to reference archived task files

**Context**:

- **Framework Guide**: DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/phase-N/task-M.md
- **Archive Directory**: .flow/archive/ (task files moved here)
- **Changelog**: .flow/CHANGELOG.md (updated with archive references)

**When to Use**: When DASHBOARD.md has 10+ completed tasks, causing clutter or difficult navigation.

**Archiving Strategy - Recent Context Window**:

- **Keep visible in DASHBOARD.md**: Current task + 3 previous tasks (regardless of status)
- **Archive**: All ✅ COMPLETE tasks older than "current - 3"
- **Always Keep Visible**: Non-complete tasks (⏳ 🚧 ❌ 🔮 🎨) regardless of age

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📍 Current Work" section
   - Extract current task number (e.g., Task 13)
   - Find "📊 Progress Overview" to list all tasks

2. **Calculate archiving threshold**:

   - Threshold = Current task number - 3
   - Example: Current = 13, Threshold = 10
   - **Archive candidates**: Tasks 1-9 (if ✅ COMPLETE)
   - **Keep visible**: Tasks 10, 11, 12, 13 (current + 3 previous)

3. **Identify archivable tasks**:

   - Find all tasks with number < threshold AND status = ✅ COMPLETE
   - List task files: `phase-N/task-M.md` for each archivable task
   - **IMPORTANT**: Keep non-complete tasks visible (⏳ 🚧 ❌ 🔮 🎨) even if old

4. **Move task files to archive**:

   - Create `archive/` directory if doesn't exist
   - For each archivable task:
     - Create phase directory in archive: `archive/phase-N/` if needed
     - Move `phase-N/task-M.md` to `archive/phase-N/task-M.md`
     - Preserve full task content (iterations, brainstorming, everything)

5. **Update CHANGELOG.md**:

   **If .flow/CHANGELOG.md does NOT exist** (first archive):

   ```markdown
   # Project Changelog

   This file contains historical records of completed tasks moved to archive.

   ## 📦 Archived Tasks

   ### Phase N: [Phase Name]

   - **Task M**: [Task Name] - [archive/phase-N/task-M.md](archive/phase-N/task-M.md)
     - Completed: [Date]
     - Archived: [Date]

   ---

   **Last Updated**: [Date]
   **Total Archived**: [Count] tasks
   ```

   **If .flow/CHANGELOG.md ALREADY exists**:
   - Read existing CHANGELOG.md
   - Add new archived tasks under appropriate phase sections
   - Update "Last Updated" and "Total Archived" count
   - Maintain phase hierarchy (don't duplicate phase headers)

6. **Update DASHBOARD.md**:

   **A. Update Progress Overview**:
   - Add 📦 marker to archived tasks
   - Format: `- ✅📦 Task 5: Feature Name (archived)`
   - Keep task in list but mark as archived
   - Update completion percentages to reflect remaining visible tasks

   **B. Update phase headers** (if all phase tasks archived):
   ```markdown
   ### Phase 1: Foundation ✅ COMPLETE

   **Goal**: [Phase goal]
   **Status**: 100% complete ([N] tasks archived to [archive/phase-1/](archive/phase-1/))
   ```

7. **Verify and confirm**:

   - Count archived files
   - Calculate DASHBOARD.md size reduction
   - Confirm to user:

     ```
     ✅ Plan split complete!

     **Archived**: [X] tasks to .flow/archive/
     **Files moved**:
       - phase-1/task-1.md → archive/phase-1/task-1.md
       - phase-1/task-2.md → archive/phase-1/task-2.md
       ...

     **DASHBOARD.md**: Updated to mark [X] tasks as 📦 archived
     **CHANGELOG.md**: Updated with archive references
     **Recent context**: Kept Task [threshold] through Task [current] visible

     Your Progress Dashboard still shows complete project history.
     Archived task files available in .flow/archive/
     ```

**Edge Cases**:

- **No old completed tasks**: "No tasks to archive. All completed tasks are within recent context window (current + 3 previous)."
- **Current task < 4**: "Current task is Task [N]. Need at least Task 4 to enable archiving (keeps current + 3 previous)."
- **Non-complete old tasks**: Keep visible in DASHBOARD.md: "Task [N] kept visible (not complete - status: [status])"

**Output**: Move task files to archive/, update DASHBOARD.md and CHANGELOG.md (full history preserved).

```

---

## /flow-backlog-add

**File**: `flow-backlog-add.md`

```markdown
---
description: Move task(s) to backlog to reduce active plan clutter
---

You are executing the `/flow-backlog-add` command from the Flow framework.

**Purpose**: Move pending tasks to BACKLOG.md to reduce active dashboard clutter while preserving all task content.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task files**

- Moves task files to backlog directory (token efficiency feature)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog management patterns

**Multi-File Architecture**: This command:
- Moves `phase-N/task-M.md` files to `backlog/` directory
- Updates `DASHBOARD.md` to remove tasks from active view
- Creates/updates `BACKLOG.md` with references to backogged tasks

**Key Insight**: Backlog is for **token efficiency**, not prioritization. Tasks aren't "low priority" - they're just "not now" (weeks/months away).

**Signature**: `/flow-backlog-add <task-number>` or `/flow-backlog-add <start>-<end>`

**Examples**:
- `/flow-backlog-add 14` - Move Task 14 to backlog
- `/flow-backlog-add 14-22` - Move Tasks 14 through 22 to backlog

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "📊 Progress Overview" section
   - Locate tasks by number

2. **Parse arguments**:
   - Single task: `task_numbers` = task number (e.g., "14")
   - Range: `task_numbers` = start-end (e.g., "14-22")
   - Extract task number(s) to move

3. **Validate tasks**:
   - Find task files: `phase-N/task-M.md`
   - Check task status - warn if moving tasks that are 🚧 IN PROGRESS or ✅ COMPLETE
   - Recommended: Only move ⏳ PENDING tasks
   - If user confirms moving non-pending tasks, proceed

4. **Move task files to backlog**:
   - Create `backlog/` directory if doesn't exist
   - For each task:
     - Move `phase-N/task-M.md` to `backlog/phase-N-task-M.md`
     - Preserve all content (iterations, brainstorming, everything)

5. **Update BACKLOG.md**:

   **If BACKLOG.md does NOT exist** (first time):

   ```markdown
   # Project Backlog

   This file lists tasks moved to backlog/ directory to reduce active dashboard size.

   **Backlog Info**:
   - Task files moved to backlog/ directory
   - Tasks retain original numbers for easy reference
   - Full content preserved (brainstorming, iterations, everything)
   - Pull tasks back when ready to work on them

   **Last Updated**: [Current date]
   **Tasks in Backlog**: [Count]

   ---

   ## 📋 Backlog Tasks

   - **Task [N]**: [Name] - [backlog/phase-N-task-M.md](backlog/phase-N-task-M.md)
   - **Task [N]**: [Name] - [backlog/phase-N-task-M.md](backlog/phase-N-task-M.md)
   ```

   **If BACKLOG.md ALREADY exists**:
   - Read existing BACKLOG.md
   - Update "Last Updated" timestamp
   - Update "Tasks in Backlog" count
   - Add tasks to "📋 Backlog Tasks" list

6. **Update DASHBOARD.md**:
   - Remove tasks from "📊 Progress Overview" section
   - Or mark as moved: `- ⏳ Task 14: Potency system (moved to backlog)`
   - Update completion percentages

7. **Reset task status to ⏳ PENDING** (in backlog files):
   - Open each backlog file
   - Change task status to ⏳ PENDING
   - Fresh start when pulled back

8. **Verify and confirm**:
   - Count moved files
   - Confirm to user:

     ```
     ✅ Moved to backlog!

     **Backlogged**: [N] task(s) to backlog/ directory
     **Files moved**: Task [list of numbers]
     **Location**: backlog/phase-N-task-M.md

     Use `/flow-backlog-view` to see backlog contents.
     Use `/flow-backlog-pull <task-number>` to bring a task back when ready.
     ```

**Edge Cases**:
- **Task doesn't exist**: "Task [N] not found"
- **Invalid range**: "Invalid range format. Use: /flow-backlog-add 14-22"
- **Empty range**: "No tasks found in range 14-22"
- **Already in backlog**: Check backlog/ directory first, warn if task already there

**Output**: Move task files to backlog/ directory, update DASHBOARD.md and BACKLOG.md.

```

---

## /flow-backlog-view

**File**: `flow-backlog-view.md`

```markdown
---
description: Show backlog contents (tasks waiting)
---

You are executing the `/flow-backlog-view` command from the Flow framework.

**Purpose**: Display backlog showing all tasks currently in backlog directory.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from BACKLOG.md and backlog/ directory**

- Simple read operation (shows backlog list)
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog context

**Multi-File Architecture**: This command:
- Reads `BACKLOG.md` for task list
- Lists files in `backlog/` directory

**Instructions**:

1. **Check if BACKLOG.md exists**:
   - If NOT found: "📦 Backlog is empty. Use `/flow-backlog-add <task>` to move tasks."
   - If found: Proceed to step 2

2. **Read BACKLOG.md**:
   - Extract "Last Updated" timestamp
   - Extract "Tasks in Backlog" count
   - Read "📋 Backlog Tasks" section for task list

3. **Verify backlog/ directory**:
   - List files in `backlog/` directory
   - Confirm task files exist: `backlog/phase-N-task-M.md`

4. **Display backlog contents**:

   ```
   📦 Backlog Contents ([N] tasks):

   **Last Updated**: [Date]

   **Tasks Waiting**:
   - **Task 14**: Potency system - [backlog/phase-2-task-14.md](backlog/phase-2-task-14.md)
   - **Task 15**: Points & Luck systems - [backlog/phase-2-task-15.md](backlog/phase-2-task-15.md)
   - **Task 16**: Database persistence - [backlog/phase-3-task-16.md](backlog/phase-3-task-16.md)

   ---

   **Next Steps**:
   - Use `/flow-backlog-pull <task-number>` to move a task back to active work
   - Example: `/flow-backlog-pull 14` brings Task 14 back to its original phase
   ```

5. **Optional: Show task details** (if user wants more info):
   - Can read full task file from backlog/ on request
   - Default view is just list (lightweight)

**Output**: Display backlog list with task files and guidance.

```

---

## /flow-backlog-pull

**File**: `flow-backlog-pull.md`

```markdown
---
description: Pull task from backlog back into active plan
---

You are executing the `/flow-backlog-pull` command from the Flow framework.

**Purpose**: Move a task from BACKLOG.md back to PLAN.md with sequential renumbering in active phase.

**🟢 NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md, BACKLOG.md, and task files**

- Moves task file back from backlog/ to phase directory
- Optional background reading (NOT required): DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog patterns

**Multi-File Architecture**: This command:
- Moves `backlog/phase-N-task-M.md` back to `phase-N/task-M.md`
- Updates `DASHBOARD.md` to show task
- Updates `BACKLOG.md` to remove task

**Signature**: `/flow-backlog-pull <task-number> [position]`

**Examples**:
- `/flow-backlog-pull 14` - Pull Task 14 back to its original phase
- `/flow-backlog-pull 14 add to phase 5` - Pull Task 14 to Phase 5 instead

**Instructions**:

1. **Check if BACKLOG.md exists**:
   - If NOT found: "📦 Backlog is empty. Nothing to pull."
   - If found: Proceed

2. **Parse arguments**:
   - Required: `task_number` - Task number to pull (e.g., "14")
   - Optional: `position` - Positioning instruction (e.g., "add to phase 5")

3. **Validate task exists in backlog**:
   - Read BACKLOG.md to find task entry
   - Find backlog file: `backlog/phase-N-task-M.md`
   - If NOT found: "Task [N] not found in backlog. Use `/flow-backlog-view` to see available."
   - If found: Proceed

4. **Determine target phase**:
   - **Default**: Use task's original phase (from filename `phase-N-task-M.md`)
   - **With position instruction**: Parse for target phase
     - "add to phase 5" → Move to phase-5/
   - **If phase doesn't exist**: Create phase directory

5. **Determine new task number**:
   - List existing tasks in target phase
   - Find highest task number
   - New task number = highest + 1
   - Example: phase-2/ has task-1.md, task-2.md → new task is task-3.md

6. **Move task file back**:
   - Move `backlog/phase-N-task-M.md` to `phase-N/task-K.md` (K = new number)
   - Update task metadata in file:
     - Update task number in header
     - Reset status to ⏳ PENDING
   - Preserve all content (iterations, brainstorming, everything)

7. **Update BACKLOG.md**:
   - Remove task from "📋 Backlog Tasks" list
   - Decrement "Tasks in Backlog" count
   - Update "Last Updated" timestamp

8. **Update DASHBOARD.md**:
   - Add task to "📊 Progress Overview" in target phase
   - Mark as ⏳ PENDING
   - Update phase task count
   - Update completion percentages

9. **Verify and confirm**:
   ```
   ✅ Pulled from backlog!

   **Task**: Task [old-number] → Task [new-number]
   **File**: backlog/phase-N-task-M.md → phase-N/task-K.md
   **Phase**: Phase [N]: [Name]
   **Status**: ⏳ PENDING (ready to start)

   **Backlog**: [N-1] tasks remaining

   Use `/flow-task-start` to begin this task when ready.
   ```

**Edge Cases**:
- **Backlog empty**: "Backlog is empty. Nothing to pull."
- **Task not in backlog**: "Task [N] not in backlog."
- **Target phase doesn't exist**: Create phase directory
- **No active phase**: Ask user which phase to add task to

**Output**: Move task file from backlog/ to phase directory, update DASHBOARD.md and BACKLOG.md.

```

COMMANDS_DATA_EOF
}

get_framework_content() {
  cat <<'FRAMEWORK_DATA_EOF'
<!-- AI_SCAN:QUICK_REFERENCE:1-600 -->
# Quick Reference for AI (Read This First!!)

> **Purpose**: This section provides essential Flow framework knowledge in ~600 lines instead of reading the entire file. Read this first, then use the Section Index to jump to specific sections only when needed.

> **NEW in Multi-File Architecture**: Flow now uses separate files (`DASHBOARD.md`, `PLAN.md`, `phase-N/task-N.md`) instead of a single monolithic `PLAN.md`. All commands follow a **dashboard-first** navigation pattern.

---

<!-- AI_SCAN:MULTI_FILE_STRUCTURE:12-85 -->
## Multi-File Structure Overview

Flow uses a **multi-file architecture** where work is split across focused files:

```
.flow/
├── DASHBOARD.md              # ⭐ USER'S MAIN WORKSPACE (single source of truth for progress)
├── PLAN.md                   # 📖 Static context (overview, architecture, scope)
├── BACKLOG.md                # 📦 Deferred/future tasks
├── ARCHIVE.md                # 🗄️ Completed work (created by /flow-plan-split)
├── phase-1/                  # 👤 USER'S WORK FILES
│   ├── task-1.md            # 📝 Task with iterations, brainstorming, implementation
│   ├── task-2.md
│   └── task-3.md
├── phase-2/                  # 👤 USER'S WORK FILES
│   ├── task-1.md
│   └── task-2.md
└── framework/                # 🤖 AI REFERENCE FILES (read-only for user)
    ├── DEVELOPMENT_FRAMEWORK.md  # 🎓 Complete methodology guide
    └── examples/             # 📚 Example files for AI to learn from
        ├── DASHBOARD.md
        ├── PLAN.md
        ├── phase-1/
        │   └── task-1.md
        └── phase-2/
            └── task-3.md
```

### File Purposes

**👤 USER'S FILES** (What you work in):

**DASHBOARD.md** (⭐ Most Important - Single Source of Truth):
- User spends most time here
- Shows current work pointer (Phase/Task/Iteration)
- Displays progress overview with ALL phases/tasks/iterations
- Key decisions needing user input
- **This is the ONLY place progress is tracked** - no duplication

**PLAN.md** (Static Context - Rarely Changes):
- Like CLAUDE.md but for this specific feature/project
- Purpose, Goals (text only, no checklists), Scope (V1 only)
- Architecture overview
- DO/DON'T guidelines
- Minimal and focused - no assumptions about future work

**phase-N/task-N.md** (Work Files - All Tasks Have Iterations):
- Contains task overview and dependencies
- **All tasks have iterations** (no standalone tasks)
- Each iteration has: Pre-tasks (optional) → Brainstorming (optional) → Action Items
- One Action Items section per iteration
- Brainstorming subjects produce "Resolution Items" → consolidated into Action Items

**BACKLOG.md** (Future Work):
- Tasks moved out of active plan
- Deferred features
- V2/V3 items (if user explicitly wants to track them)

**ARCHIVE.md** (Completed Work):
- Created by `/flow-plan-split`
- Archives all completed tasks
- Task files become references: "See ARCHIVE.md"

**🤖 AI REFERENCE FILES** (Read-only, for AI agents):

**framework/DEVELOPMENT_FRAMEWORK.md** (This File):
- Complete Flow methodology
- Templates, patterns, best practices
- AI reads this to understand how Flow works

**framework/examples/** (Example Project):
- Real example of Flow in use (payment gateway project)
- AI learns patterns from these examples
- Shows DASHBOARD.md, PLAN.md, and task file formats

---

<!-- AI_SCAN:CORE_HIERARCHY:88-110 -->
## Core Hierarchy

```
PHASE → TASK → ITERATION → BRAINSTORM → IMPLEMENTATION → COMPLETE
```

**Structure**:
- **PHASE**: High-level milestone (e.g., "Core Implementation", "Testing")
  - Lives in: DASHBOARD.md (overview) + `phase-N/` directory
- **TASK**: Feature/component to build (e.g., "Database Schema", "API Endpoints")
  - Lives in: `phase-N/task-N.md` file
- **ITERATION**: Incremental buildout (e.g., "V1: Basic validation", "V2: Advanced rules")
  - Lives in: Inside task file (`phase-N/task-N.md`)
- **BRAINSTORM**: Design before code (subjects → decisions → action items)
  - Lives in: Inside iteration section of task file
- **IMPLEMENTATION**: Execute action items from brainstorming
  - Lives in: Inside iteration section of task file

**Golden Rule**: Brainstorm → Pre-Tasks → Implementation (never skip brainstorming for complex work)

---

<!-- AI_SCAN:DASHBOARD_FIRST_PATTERN:113-165 -->
## Dashboard-First Navigation Pattern

**ALL commands follow this pattern**:

```
1. Read DASHBOARD.md (source of truth)
2. Extract current context:
   - Phase: Phase N
   - Task: Task M (in phase-N/ directory)
   - Iteration: Iteration K
3. Navigate to task file: phase-N/task-M.md
4. Perform operation (read/edit task file)
5. Update DASHBOARD.md with new state
```

**Example: `/flow-implement-start`**:
```
1. Read DASHBOARD.md
   → Current: Phase 2, Task 3, Iteration 2
2. Construct path: phase-2/task-3.md
3. Read phase-2/task-3.md
   → Find Iteration 2 section
4. Add Implementation subsection
5. Update DASHBOARD.md:
   - Change Iteration 2 status: ⏳ → 🚧
   - Update "Current Work" pointer
```

**Why Dashboard-First?**
- Single source of truth for project state
- User always knows where they are
- Commands don't need to search multiple files
- Consistent navigation across all commands

**Key Insight**: DASHBOARD.md is like an index - it tells you WHERE to find detailed work (which task file, which iteration).

---

<!-- AI_SCAN:STATUS_MARKERS:168-195 -->
## Status Markers

| Marker | Meaning | When to Use |
|--------|---------|-------------|
| ✅ | COMPLETE | Finished and verified (frozen, skip re-verification) |
| ⏳ | PENDING | Not started yet |
| 🚧 | IN PROGRESS | Currently working on this |
| 🎨 | READY | Brainstorming done, ready to implement |
| ❌ | CANCELLED | Decided against (must document WHY) |
| 🔮 | DEFERRED | Moved to V2/V3/later (must document WHY + WHERE - usually moved to BACKLOG.md) |
| 🎯 | ACTIVE | Current focus (optional, used in DASHBOARD.md) |

**Rules**:
- Every Phase/Task/Iteration/Subject MUST have a status marker
- ✅ COMPLETE items are verified & frozen (skip re-verification)
- ❌ CANCELLED and 🔮 DEFERRED must document reason
- Status appears in BOTH:
  - DASHBOARD.md (for overview)
  - Task file header (phase-N/task-M.md)

**Status Lifecycle**:
```
⏳ PENDING → 🚧 IN PROGRESS → ✅ COMPLETE
                ↓
              🎨 READY (for iterations with brainstorming)
```

---

<!-- AI_SCAN:TASK_STRUCTURE_QUICK:198-270 -->
## Task Structure Rules

**The Golden Rule**: **ALL tasks have iterations** - this provides consistent structure and enables iterative development.

### Task with Iterations (The Only Pattern)

**File**: `phase-N/task-N.md`
```markdown
# Task 3: Implement Payment Gateway

**Status**: 🚧 IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate Stripe API for payment processing

---

## Task Overview

Build production-ready payment gateway integration.

**Why This Task**: Current system has no payment processing capability.

**Dependencies**:
- Requires: Task 1 (Database Layer)
- Blocks: Task 4 (Subscription System)

---

## Iterations

### ✅ Iteration 1: API Setup

**Goal**: Configure Stripe SDK and credentials
**Status**: ✅ COMPLETE

[Brainstorming → Action Items → Implementation sections below]

---

### 🚧 Iteration 2: Payment Processing

**Goal**: Implement charge creation and webhooks
**Status**: 🚧 IN PROGRESS

[Currently brainstorming...]
```

**Why iterations-only**:
- Consistent structure across all tasks
- Enables human-in-loop iteration (plan → brainstorm → implement → complete)
- Clear progress tracking (iteration status)
- Simple tasks just have 1-2 iterations with action items
- Complex tasks have multiple iterations with brainstorming

**Structure per iteration**:
1. **Pre-Implementation Tasks** (optional) - Quick fixes before starting
2. **Brainstorming Session** (optional) - Design decisions → Resolution Items
3. **Action Items** (required) - ONE list per iteration, consolidated from brainstorming or direct
4. **Implementation** - Track work, files modified, discoveries

---

<!-- AI_SCAN:SUBJECT_RESOLUTION:273-300 -->
## Subject Resolution Types

When brainstorming (inside task file), every resolved subject falls into ONE of these types:

| Type | Name | When | Action | Example |
|------|------|------|--------|---------|
| **A** | Pre-Implementation Task | Small code changes needed BEFORE iteration | Create pre-task (< 30 min work) | Fix interface, rename file, update enum |
| **B** | Immediate Documentation | Architectural decision, no code yet | Update PLAN.md Architecture section NOW | Design pattern choice, API contract |
| **C** | Auto-Resolved | Answered by another subject's decision | Mark as resolved by Subject N | Cascade decisions |
| **D** | Iteration Action Items | Substantial feature work that IS the iteration | Create "Resolution Items" list in subject | Build API endpoint, implement validator |

**Decision Flow**:
1. Does subject require code changes?
   - **NO** → Type B (Documentation) or Type C (Auto-resolved)
   - **YES** → Continue to #2
2. Is it small quick task (< 30 min)?
   - **YES** → Type A (Pre-task)
   - **NO** → Type D (Resolution Items → Action Items)

**Where They Live**:
- Type B decisions → Update `PLAN.md` Architecture section immediately
- Type A pre-tasks → Pre-Implementation Tasks section (before brainstorming complete)
- Type D Resolution Items → Listed in subject, then `/flow-brainstorm-review` consolidates them into iteration's Action Items section

**Key Insight**: Brainstorming creates "Resolution Items" per subject. The `/flow-brainstorm-review` command consolidates all Resolution Items → single Action Items list per iteration.

---

<!-- AI_SCAN:COMMON_PATTERNS:303-410 -->
## Common Patterns Quick Reference

### Creating a New Project

```bash
# Option 1: From scratch
/flow-blueprint

# Option 2: Convert existing docs
/flow-migrate

# Option 3: Convert old single-file PLAN.md
/flow-plan-update
```

**Result**: Creates DASHBOARD.md, PLAN.md, phase-1/ directory with initial task files

---

### Starting Work on a Phase

```bash
/flow-phase-add "Phase 2: Core Implementation"
/flow-phase-start
```

**Files Created/Updated**:
- `phase-2/` directory created
- DASHBOARD.md updated with new phase section

---

### Adding a Task

```bash
/flow-task-add "API Integration"
```

**Files Created/Updated**:
- `phase-N/task-M.md` created (N = current phase, M = next task number)
- DASHBOARD.md updated with new task entry

---

### Working on an Iteration

```bash
# 1. Add iteration to current task
/flow-iteration-add "Error Handling"

# 2. Start brainstorming
/flow-brainstorm-start

# 3. Resolve subjects one by one
/flow-next-subject
# [Discuss subject, choose Type A/B/C/D, document decision]

# 4. After all subjects resolved, review
/flow-brainstorm-review
# [AI suggests iterations/pre-tasks based on decisions]

# 5. Complete any pre-tasks, then close brainstorming
/flow-brainstorm-complete

# 6. Start implementation
/flow-implement-start

# 7. Do the work...

# 8. Complete implementation
/flow-implement-complete
```

**Files Updated**:
- Current `phase-N/task-M.md` (brainstorming, implementation sections added)
- DASHBOARD.md (status updates throughout)
- Possibly PLAN.md (if Type B decisions made)

---

### Checking Status

```bash
/flow-status
```

**Result**: Reads DASHBOARD.md, shows formatted current state
- Current work pointer
- Progress overview
- Completion percentages
- Next actions

**This is the REFERENCE MODEL command** - simple dashboard read, no complex logic needed.

---

### Finding Next Work

```bash
/flow-next
```

**Logic**:
1. Read DASHBOARD.md
2. Check current iteration status
3. Suggest appropriate next command based on state

---

<!-- AI_SCAN:BRAINSTORMING_WORKFLOW:413-480 -->
## Brainstorming Workflow Pattern

**Context**: Happens inside `phase-N/task-M.md` file, within an iteration section.

### Structure in Task File

```markdown
### 🚧 Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling

**Status**: 🚧 IN PROGRESS (Brainstorming)

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design retry logic, error recovery patterns

**Subjects to Discuss**:
1. ⏳ Retry Strategy
2. ⏳ Circuit Breaker Pattern
3. ⏳ Error Logging

**Resolved Subjects**:

---

##### ✅ Subject 1: Retry Strategy

**Decision**: Use exponential backoff with 3 retries

**Resolution Type**: D (Iteration Action Items)

**Rationale**: Balances reliability with user experience

**Action Items**:
- [ ] Implement RetryPolicy class
- [ ] Add exponential backoff logic
- [ ] Configure max retry count

---

##### ✅ Subject 2: Circuit Breaker Pattern

**Decision**: Skip circuit breaker for V1, defer to V2

**Resolution Type**: B (Documentation)

**Rationale**: V1 scope is tight, circuit breaker adds complexity

**Documentation Update**: Added to PLAN.md V2 scope
```

### Workflow Commands

1. **Start**: `/flow-brainstorm-start`
   - Adds brainstorming section to current iteration
   - Creates "Subjects to Discuss" list

2. **Resolve**: `/flow-next-subject`
   - Picks next ⏳ subject
   - Discuss with user
   - Document decision + choose Type A/B/C/D
   - Add action items if needed

3. **Review**: `/flow-brainstorm-review` (CRITICAL STEP!)
   - After all subjects resolved
   - AI analyzes all decisions
   - Suggests if more iterations needed
   - Identifies pre-implementation tasks
   - **Always suggest this BEFORE /flow-brainstorm-complete**

4. **Complete**: `/flow-brainstorm-complete`
   - Marks brainstorming ✅ COMPLETE
   - Changes iteration status to 🎨 READY
   - Only call AFTER completing pre-tasks

---

<!-- AI_SCAN:PRE_IMPLEMENTATION_PATTERN:483-540 -->
## Pre-Implementation Tasks Pattern

**Context**: Discovered during brainstorming (Type A subjects). Must be completed BEFORE starting iteration implementation.

### Structure in Task File

```markdown
### 🚧 Iteration 2: Error Handling

[... Brainstorming section above ...]

---

#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

##### ⏳ Pre-Task 1: Refactor Legacy Error Handler

**Why Blocking**: Current ErrorHandler doesn't support async retry logic

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async
- Add retryAsync() method
- Update 3 existing call sites

**Files**:
- src/utils/ErrorHandler.ts
- src/services/BillingService.ts
- tests/utils/ErrorHandler.test.ts

**Test**: Run existing tests to ensure no regressions

---

##### ✅ Pre-Task 2: Update Type Definitions

**Completed**: 2025-01-15

**Changes Made**:
- Added ErrorType enum
- Updated function signatures
- All tests passing
```

### Workflow

1. During brainstorming, identify Type A subjects (small < 30 min tasks)
2. `/flow-brainstorm-review` creates pre-implementation tasks section
3. Complete all pre-tasks (mark each ✅ with completion date)
4. Only then call `/flow-brainstorm-complete`
5. Then call `/flow-implement-start`

**Why This Matters**: Pre-tasks unblock the main implementation. Doing them early prevents getting stuck mid-iteration.

---

<!-- AI_SCAN:SECTION_INDEX:543-600 -->
## Section Index (Use Read Tool with Offset/Limit)

**How to Use**: When you need deep details, use `Read(file_path, offset=X, limit=Y)` to read ONLY the specific section.

### Quick Reference Sections (You Just Read These!)
- Lines 1-600: This Quick Reference (current section)

### Core Framework Sections
- Lines 601-850: **Framework Philosophy & Principles**
  - Domain-Driven Design approach
  - Agile iterative philosophy
  - When to use Flow

- Lines 851-1100: **Multi-File Architecture Deep Dive**
  - File responsibilities in detail
  - Cross-file references
  - Directory structure rules
  - File naming conventions

- Lines 1101-1400: **Task Structure Rules (Complete Guide)**
  - Iterations-only architecture
  - When to split tasks
  - Task size guidelines
  - Nested iteration patterns

- Lines 1401-1700: **Brainstorming Pattern (Complete Guide)**
  - Full brainstorming workflow
  - Subject resolution types deep dive
  - Pre-implementation task patterns
  - Bugs discovered pattern

- Lines 1701-1900: **Implementation Pattern (Complete Guide)**
  - Implementation structure
  - Notes and discoveries
  - Verification checklist
  - When to mark complete

- Lines 1901-2100: **Status Management**
  - Status marker lifecycle
  - State transitions
  - Common pitfalls
  - Recovery from incorrect states

- Lines 2101-2600: **File Templates**
  - DASHBOARD.md template (complete)
  - PLAN.md template (complete)
  - task-N.md template (complete)
  - Copy-paste ready templates

- Lines 2601-2900: **Command Patterns**
  - Dashboard-first navigation (detailed)
  - Structure creation pattern
  - Full traversal pattern
  - Cross-file search pattern

- Lines 2901-3200: **Complete Workflow Examples**
  - Full feature implementation walkthrough
  - File updates at each step
  - Real-world example with payment gateway

- Lines 3201-3500: **Backlog Management**
  - BACKLOG.md structure
  - Moving tasks to backlog
  - Pulling tasks back
  - Archiving with /flow-plan-split

- Lines 3501-3800: **Best Practices & Pitfalls**
  - Common mistakes
  - How to recover
  - Performance tips
  - Multi-developer workflows

---

**End of Quick Reference** - Continue reading below for complete framework documentation →


<!-- AI_SCAN:FRAMEWORK_PHILOSOPHY:620-850 -->
# Framework Philosophy & Principles

## What is Flow?

Flow is a **specification-driven iterative development methodology** that combines:
- **Domain-Driven Design** principles (understand before building)
- **Agile philosophy** (iterative shipping, adapt to feedback)
- **Progressive disclosure** (V1 → V2 → V3, defer complexity)

### Core Metaphor: Building a Human Body

**Skeleton** (Phase 1) → **Veins** (Phase 2) → **Flesh** (Phase 3) → **Fibers** (Phase 4)

- **Skeleton**: Basic structure and foundation
  - Minimal working version
  - Core data models
  - Basic happy path

- **Veins**: Core data flow and connections
  - Main feature workflows
  - Critical integration points
  - Error handling basics

- **Flesh**: Incremental complexity
  - Additional features
  - Edge cases
  - Performance optimization

- **Fibers**: Refinement and optimization
  - Polish and UX improvements
  - Advanced edge cases
  - Production hardening

### Multi-File Architecture Philosophy

**Problem**: Monolithic `PLAN.md` files grow to 500-5000+ lines, becoming:
- Hard to navigate
- Slow to load/edit
- Git merge nightmares
- Context overload for AI

**Solution**: Split into focused files:
- **DASHBOARD.md**: User's active workspace (what's happening NOW)
- **PLAN.md**: Static context (WHY we're building this, HOW it fits together)
- **phase-N/task-N.md**: Detailed work files (what's IN each task)
- **BACKLOG.md**: Future work (what's DEFERRED)

**Benefits**:
- Smaller files = faster to read/edit
- Each file has single responsibility
- Git conflicts are localized
- AI can focus on relevant file only
- User knows where to look for information

### When to Use Flow

**✅ Use Flow For**:
- Complex features requiring design decisions
- Multi-phase projects (> 2 weeks)
- Features with unclear requirements (need exploration)
- Team projects (shared context needed)
- Features requiring iterative refinement

**❌ Don't Use Flow For**:
- Simple bug fixes (< 1 hour)
- Trivial features (< 5 steps)
- Well-defined copy-paste implementations
- One-off scripts

### Key Principles

#### 1. Plan-Before-Code

**Never start coding without understanding the problem domain.**

- Brainstorming is NOT optional for complex work
- Document decisions and rationale
- Identify pre-implementation tasks early
- Update architecture documentation (PLAN.md) for major decisions

#### 2. Context Preservation

**The plan files ARE the memory of the project.**

- DASHBOARD.md: Current state (always up-to-date)
- PLAN.md: Static context (reference docs)
- Task files: Complete work history per task
- CHANGELOG.md: Historical decisions
- Everything is documented, nothing is forgotten

#### 3. Iterative Refinement

**Ship V1, then V2, then V3 - don't try to build perfect V1.**

- V1: Minimum viable (skeleton + veins)
- V2: Enhancements (flesh)
- V3: Optimization (fibers)
- Defer complexity to later versions

#### 4. Progressive Disclosure

**Focus only on what's needed NOW.**

- Each iteration is focused and shippable
- Don't design V3 during V1 brainstorming
- Document V2/V3 ideas in PLAN.md or BACKLOG.md
- Revisit deferred decisions when actually needed

#### 5. State Preservation

**Status markers track progress across sessions.**

- ✅ COMPLETE: Frozen, verified, skip re-verification
- 🚧 IN PROGRESS: Currently active work
- ⏳ PENDING: Not started yet
- 🎨 READY: Brainstorming done, ready to code
- Status in both DASHBOARD.md (overview) and task files (details)

#### 6. Dashboard-First Navigation

**DASHBOARD.md is the single source of truth for "where are we?"**

- All commands read DASHBOARD.md first
- Dashboard points to current task file
- Task file contains detailed work
- Consistent navigation pattern across all commands

---

<!-- AI_SCAN:MULTI_FILE_ARCHITECTURE:852-1100 -->
# Multi-File Architecture Deep Dive

## File Responsibilities

### DASHBOARD.md (Progress Tracking)

**Purpose**: User's main workspace - shows current work and overall progress

**Sections**:
1. **Current Work** - Pointer to active Phase/Task/Iteration
2. **Progress Overview** - All phases with task completion status
3. **Completion Status** - Percentages and statistics
4. **Next Actions** - What to do next

**Update Frequency**: Every command that changes state

**User Interaction**: User reads this constantly to understand where they are

**Example Structure**:
```markdown
# Project Dashboard

**Last Updated**: 2025-01-15 14:30

## 📍 Current Work
- **Phase**: [Phase 2 - Core Implementation](phase-2/)
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
- **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) 🚧

## 📊 Progress Overview

### Phase 1: Foundation ✅ COMPLETE
- ✅ Task 1: Project Setup (3/3 iterations)
- ✅ Task 2: Core Models (2/2 iterations)

### Phase 2: Core Implementation 🚧 IN PROGRESS (2/5 tasks)
- ✅ Task 1: Database Layer (2/2 iterations)
- ✅ Task 2: Business Logic (3/3 iterations)
- 🚧 Task 3: API Integration (1/4 iterations) ← CURRENT
- ⏳ Task 4: Authentication
- ⏳ Task 5: Caching Layer

## 📈 Completion Status
- Phase 1: 100% (5/5 iterations)
- Phase 2: 40% (6/15 iterations)
- Overall: 55% (11/20 iterations)

## 🎯 Next Actions
- [ ] Complete Iteration 2 error handling patterns
- [ ] Review error taxonomy with team
- [ ] Start Iteration 3 retry logic design
```

### PLAN.md (Static Context)

**Purpose**: Like CLAUDE.md but for this specific feature/project

**Sections**:
1. **Overview** - Purpose, Goals, Scope (V1/V2/V3)
2. **Architecture** - System design, components, data flow
3. **Testing Strategy** - How to test this feature
4. **Development Phases** - High-level phase descriptions (NOT detailed tasks)

**Update Frequency**: Rarely (only when architecture changes or Type B brainstorming decisions)

**User Interaction**: User reads at start of project, refers back occasionally

**Key Insight**: This is the "WHY" and "HOW" documentation - it explains the big picture

**Example Structure**:
```markdown
# Payment Gateway Integration - Development Plan

> **📍 Current Progress**: See [DASHBOARD.md](DASHBOARD.md)
> **🎯 Purpose**: Integrate Stripe payment processing

**Created**: 2025-01-10
**Version**: V1

## Overview

### Purpose
Build production-ready payment gateway integration supporting credit cards and subscriptions.

### Goals
- [ ] Process credit card payments via Stripe API
- [ ] Handle webhook events for async notifications
- [ ] Implement retry logic for failed payments

### Scope

**V1 (Included)**:
- Credit card payment processing
- Basic subscription support
- Webhook handler
- Retry logic (3 attempts)

**V2 (Future)**:
- ACH/bank transfer support
- Multi-currency
- Saved payment methods

## Architecture

### System Design

**Components**:
- `PaymentService` - Core payment orchestration
- `StripeClient` - API wrapper with retry logic
- `WebhookHandler` - Event processing
- `PaymentRepository` - Database persistence

### Data Flow
[Diagram or description]

## Testing Strategy

**Methodology**: Simulation-based per-service testing
**Location**: `scripts/` directory
**Naming**: `{service}.scripts.ts`

## Development Phases

### Phase 1: Foundation
Setup project structure and dependencies

### Phase 2: Core Implementation
Build payment processing functionality

### Phase 3: Testing & Hardening
Comprehensive testing and edge cases
```

### phase-N/task-N.md (Work Files)

**Purpose**: Container for all work related to a specific task

**Sections**:
1. **Task Header** - Status, Phase link, Purpose
2. **Task Overview** - Description, dependencies, why this task
3. **Iterations** - All tasks have iterations (1+ iterations per task)
4. **Task Notes** - Discoveries, decisions, references

**Update Frequency**: Constantly during work on this task

**User Interaction**: User works in this file during active development

**Key Insight**: This is the "WHAT" and "HOW SPECIFICALLY" - all the detailed work

**Example Structure** (Task with Iterations):
```markdown
# Task 3: API Integration

**Status**: 🚧 IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API

---

## Task Overview

Build robust Stripe API client with error handling and retry logic.

**Why This Task**: Need payment processing capability

**Dependencies**:
- Requires: Task 1 (Database Layer)
- Blocks: Task 4 (Authentication)

---

## Iterations

### ✅ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper

**Status**: ✅ COMPLETE

[Brainstorming, Implementation sections below]

---

### 🚧 Iteration 2: Error Handling

**Goal**: Implement error handling

**Status**: 🚧 IN PROGRESS

[Currently working on this iteration]

---

## Task Notes

**Discoveries**:
- Stripe SDK handles connection pooling automatically

**Decisions**:
- Using Stripe Node SDK v12.x

**References**:
- Stripe API Docs: https://stripe.com/docs/api
```

### BACKLOG.md (Future Work)

**Purpose**: Storage for deferred tasks and V2/V3 features

**Sections**:
1. **Backlog Dashboard** - Summary of backlog items
2. **Backlog Items** - Deferred tasks with reasoning

**Update Frequency**: When moving tasks out of active plan or adding future work

**Example Structure**:
```markdown
# Project Backlog

## 📋 Backlog Dashboard

**Total Items**: 8
**V2 Features**: 5
**V3 Features**: 2
**Deferred Bugs**: 1

## Backlog Items

### ⏳ Task: Multi-Currency Support

**Originally Planned**: Phase 2, Task 6
**Deferred To**: V2
**Reasoning**: V1 scope focuses on USD only, multi-currency adds significant complexity
**Estimated Effort**: 2 weeks
**Dependencies**: Core payment processing complete
```

### CHANGELOG.md (History)

**Purpose**: Historical record of completed work

**Example**:
```markdown
# Changelog

## [V1.2.0] - 2025-01-15
### Added
- Retry logic for failed payments
- Webhook signature validation

### Fixed
- Race condition in payment processing

## [V1.1.0] - 2025-01-10
### Added
- Basic payment processing
- Stripe API integration
```

### ARCHIVE.md (Completed Work)

**Purpose**: Created by `/flow-plan-split` - archives completed tasks

**Structure**: Flat list of completed tasks with all iterations

**Effect**: Original task files become references:
```markdown
# Task 1: Project Setup

**Status**: ✅ COMPLETE (Archived)

See [ARCHIVE.md](../ARCHIVE.md#task-1-project-setup) for complete details.
```

## Cross-File References

### Linking Between Files

**Dashboard → Task File**:
```markdown
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
```

**Task File → Dashboard**:
```markdown
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
```

**Task File → PLAN.md**:
```markdown
See [PLAN.md Architecture section](../PLAN.md#architecture) for system design
```

**PLAN.md → Backlog**:
```markdown
Multi-currency support deferred to V2 (see [BACKLOG.md](BACKLOG.md))
```

### Reference Patterns

**Current Work Pointer** (in DASHBOARD.md):
```markdown
## 📍 Current Work
- **Phase**: Phase 2 - Core Implementation
- **Task**: Task 3 - API Integration
- **Iteration**: Iteration 2 - Error Handling
- **File**: [phase-2/task-3.md](phase-2/task-3.md#iteration-2-error-handling)
```

This pointer is the SOURCE OF TRUTH for "where are we right now?"

## Directory Structure Rules

### Phase Directories

**Naming**: `phase-N/` where N is the phase number (1, 2, 3, ...)
**Created**: When `/flow-phase-add` is run
**Contains**: Task files for that phase

```
phase-1/
├── task-1.md
├── task-2.md
└── task-3.md
```

### Task File Naming

**Format**: `task-N.md` where N is the task number within the phase
**Numbering**: Sequential within each phase (task-1, task-2, task-3, ...)
**Name in Content**: Task file contains descriptive name in header

**Example**:
- File: `phase-2/task-3.md`
- Header: `# Task 3: API Integration`

### File Naming Conventions

**DO**:
- ✅ Use `phase-N/` for phase directories
- ✅ Use `task-N.md` for task files
- ✅ Keep all Flow files in `.flow/` directory
- ✅ Use lowercase for filenames

**DON'T**:
- ❌ Don't put task name in filename (`task-3-api-integration.md`)
- ❌ Don't nest deeper than `phase-N/task-N.md`
- ❌ Don't create subdirectories under phase directories


<!-- AI_SCAN:TASK_STRUCTURE_COMPLETE:1101-1400 -->
# Task Structure Rules (Complete Guide)

## The Golden Rule

**ALL Tasks Have Iterations**

This provides consistent structure and enables human-in-loop iterative development.

## Why Iterations-Only?

- **Consistent structure** - Every task follows same pattern, easier to navigate
- **Human-in-loop** - Enables plan → brainstorm → implement → complete cycle
- **Progress tracking** - Clear iteration status shows where you are
- **Flexibility** - Simple tasks have 1-2 iterations, complex tasks have many
- **No special cases** - One pattern to learn and follow

## Task Pattern (The Only Pattern)

**File**: `phase-N/task-N.md`

### Complete Example

```markdown
# Task 3: API Integration

**Status**: 🚧 IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API for payment processing

---

## Task Overview

Build robust Stripe API client with error handling, retry logic, and webhooks.

**Why This Task**: Core payment functionality depends on reliable API integration.

**Dependencies**:
- **Requires**: Task 1 (Database Layer) - need PaymentRepository
- **Requires**: Task 2 (Business Logic) - need PaymentService interface
- **Blocks**: Task 4 (Authentication) - auth tokens stored via this API

**Estimated Complexity**: High (3-4 iterations expected)

---

## Iterations

### ✅ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper with authentication

**Status**: ✅ COMPLETE (2025-01-12)

---

#### Brainstorming Session - REST Client Architecture

**Focus**: Design API client abstraction and authentication flow

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ✅ Subject 1: Client Architecture Pattern

**Decision**: Use singleton pattern with lazy initialization

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe SDK maintains connection pool internally
- Multiple instances would create redundant connections
- Lazy init delays credential validation until first use

**Resolution Items**:
- Create `StripeClient` singleton class
- Implement lazy initialization in constructor
- Add credential validation on first API call

---

##### ✅ Subject 2: Authentication Flow

**Decision**: Use API key from environment variable with validation

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Follows Stripe best practices
- Supports different keys per environment
- Fails fast if key missing or invalid

**Resolution Items**:
- Load `STRIPE_API_KEY` from env
- Validate key format at startup
- Throw clear error if key missing

---

#### Action Items

(Consolidated from Resolution Items above by `/flow-brainstorm-review`)

- [x] Create `StripeClient` singleton class
- [x] Implement lazy initialization in constructor
- [x] Add credential validation on first API call
- [x] Load `STRIPE_API_KEY` from env
- [x] Validate key format at startup
- [x] Throw clear error if key missing

---

#### Implementation - Iteration 1: REST Client Setup

**Status**: ✅ COMPLETE (2025-01-12)

**Implementation Notes**:
- Created `src/payment/StripeClient.ts` with singleton pattern
- Implemented environment-based key loading
- Added validation for API key format (starts with `sk_`)
- Discovered bug in existing error handling (see Pre-Implementation Tasks in Iteration 2)

**Files Modified**:
- `src/payment/StripeClient.ts` - Created (142 lines)
- `src/config/env.ts` - Added STRIPE_API_KEY validation
- `scripts/payment.scripts.ts` - Created test file

**Verification**:
- ✅ All tests passing in payment.scripts.ts
- ✅ API key validation working correctly
- ✅ Singleton pattern verified

---

### 🚧 Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling and retry logic

**Status**: 🚧 IN PROGRESS (Brainstorming)

---

#### Pre-Implementation Tasks

##### ⏳ Pre-Task 1: Refactor Legacy Error Handler

**Why Blocking**: Current ErrorHandler doesn't support async retry logic

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async
- Add retryAsync() method
- Update 3 existing call sites

**Files**:
- src/utils/ErrorHandler.ts
- src/services/BillingService.ts
- tests/utils/ErrorHandler.test.ts

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design retry logic, error recovery patterns

**Subjects to Discuss**:
1. ⏳ Retry Strategy
2. ⏳ Circuit Breaker Pattern
3. ⏳ Error Logging

**Resolved Subjects**:
(To be filled during brainstorming)

---

### ⏳ Iteration 3: Retry Logic

**Goal**: Add exponential backoff retry for transient failures

**Status**: ⏳ PENDING

---

### ⏳ Iteration 4: Integration Tests

**Goal**: Comprehensive test coverage with Stripe API simulation

**Status**: ⏳ PENDING

---

## Task Notes

**Discoveries**:
- Stripe SDK already implements connection pooling (no need for custom)
- Error codes changed in Stripe API v2023-10-16 (updated error taxonomy)

**Decisions**:
- Using Stripe Node SDK v12.x (latest stable)
- Not implementing custom connection pool (SDK handles it)

**References**:
- Stripe API Docs: https://stripe.com/docs/api
- Existing billing: `src/legacy/billing.ts` (PayPal integration pattern)
- Similar webhook: `src/webhooks/shipment.ts` (signature validation example)
```

### Completion Criteria

Task is ✅ COMPLETE when:
- ALL iterations are ✅ COMPLETE
- Task Notes updated with discoveries
- All dependencies satisfied

## Exception: Pre-Implementation Tasks

**Only exception to "no direct action items" rule**:

Pre-implementation tasks are discovered during brainstorming (Type A subjects) and must be completed BEFORE iteration implementation starts.

**Structure**:
```
Task
├── Iteration N
│   ├── Pre-Implementation Tasks ← EXCEPTION: Action items at iteration level
│   ├── Brainstorming Session
│   └── Implementation
```

**Why Allowed**: These are blocking tasks that unblock the iteration. They're scoped to < 30 min and must be done before `/flow-implement-start`.

## When to Split a Task

### Task Too Large?

**Signals**:
- More than 5 iterations planned
- Iterations span multiple unrelated concerns
- Task takes > 4 weeks
- Task description is vague ("Implement everything...")

**Solution**: Split into multiple tasks

**Example**:
```
Before:
- Task: Payment System (10 iterations)

After:
- Task 1: Payment Processing (4 iterations)
- Task 2: Webhook Handling (3 iterations)
- Task 3: Payment Analytics (3 iterations)
```

### Task Too Small?

**Signals**:
- Only 1 iteration with 2-3 action items
- No brainstorming needed
- Can complete in < 1 hour

**Solution**: Use Single Iteration with Direct Action Items

**Example**:
```
Task: Add Logging
- Iteration 1: Logging Implementation
  - Action Items (no brainstorming):
    - Add logger configuration
    - Update main entry points
    - Add log rotation
```

## Nested Iteration Pattern

**Question**: Can iterations have sub-iterations?

**Answer**: No. Keep structure flat.

**Why**: Two levels (Task → Iteration) is enough. If you need more nesting, split the task.

**If You Feel You Need More Nesting**:
1. You probably need multiple tasks instead
2. Or your brainstorming subjects should become separate iterations

---

<!-- AI_SCAN:BRAINSTORMING_COMPLETE:1402-1700 -->
# Brainstorming Pattern (Complete Guide)

## What is Brainstorming?

**Brainstorming** is the design-before-code phase where you:
1. Identify questions/decisions (subjects)
2. Discuss each subject
3. Document decisions
4. Generate action items
5. Identify pre-implementation work

**Location**: Inside task file, within iteration section

**Mandatory For**: Complex iterations requiring design decisions

## Brainstorming Structure

### Complete Brainstorming Section

```markdown
#### Brainstorming Session - [Topic]

**Focus**: [What we're designing/deciding]

**Subjects to Discuss**:
1. ⏳ [Subject name]
2. ⏳ [Subject name]
3. ⏳ [Subject name]

**Resolved Subjects**:

---

##### ✅ Subject 1: [Name]

**Decision**: [Your decision]

**Resolution Type**: A / B / C / D

**Rationale**: [Why this decision]

**Action Items** (if Type A or D):
- [ ] Item 1
- [ ] Item 2

**Documentation Update** (if Type B):
[What was updated in PLAN.md]

---

##### ✅ Subject 2: [Name]

[... same structure ...]
```

## Subject Resolution Types (Deep Dive)

### Type A: Pre-Implementation Task

**When**: Small code change needed BEFORE iteration starts

**Criteria**:
- Required for iteration (blocking)
- Small scope (< 30 min)
- Can be done independently
- Examples: Fix interface, rename file, update enum, fix bug

**Action**:
1. Document decision
2. Create action items
3. Add to "Pre-Implementation Tasks" section
4. Complete BEFORE `/flow-brainstorm-complete`

**Example**:
```markdown
##### ✅ Subject 3: Type Definition Updates

**Decision**: Need to update PaymentStatus enum to include new states

**Resolution Type**: A (Pre-Implementation Task)

**Rationale**: Current enum missing "pending_retry" and "failed_permanent" states needed for retry logic

**Action Items**:
- [ ] Update PaymentStatus enum in types.ts
- [ ] Update 4 switch statements to handle new states
- [ ] Add tests for new states

**Note**: Must complete before implementing retry logic
```

### Type B: Immediate Documentation

**When**: Architectural decision that affects system design

**Criteria**:
- No code changes yet
- Updates PLAN.md Architecture section
- Examples: Design pattern choice, API contract, data model

**Action**:
1. Document decision
2. Update PLAN.md Architecture section NOW
3. Reference update in subject

**Example**:
```markdown
##### ✅ Subject 1: Error Recovery Strategy

**Decision**: Implement retry with exponential backoff, no circuit breaker for V1

**Resolution Type**: B (Documentation)

**Rationale**:
- Exponential backoff handles transient failures well
- Circuit breaker adds complexity, defer to V2
- Stripe API has good rate limiting, low risk of cascade failures

**Documentation Update**:
Updated PLAN.md Architecture section with retry strategy diagram and V2 scope for circuit breaker
```

### Type C: Auto-Resolved

**When**: Subject answered by another subject's decision

**Criteria**:
- No independent decision needed
- Cascade from another subject
- Examples: Implementation detail determined by architecture choice

**Action**:
1. Note which subject resolved this
2. No additional action items

**Example**:
```markdown
##### ✅ Subject 4: Retry Delay Calculation

**Decision**: Use exponential backoff as decided in Subject 1

**Resolution Type**: C (Auto-Resolved by Subject 1)

**Rationale**: Subject 1 already decided on exponential backoff strategy, this subject is implementation detail
```

### Type D: Iteration Action Items

**When**: Substantial feature work that IS the iteration

**Criteria**:
- Main implementation work
- Takes significant time (> 30 min)
- Examples: Build API endpoint, implement validator, create service

**Action**:
1. Document decision
2. Create action items
3. These become implementation action items

**Example**:
```markdown
##### ✅ Subject 2: Retry Implementation

**Decision**: Implement RetryPolicy class with configurable backoff strategy

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Separate class for testability
- Configurable for different API endpoints
- Can swap strategies (exponential, linear, fixed)

**Action Items**:
- [ ] Create RetryPolicy class
- [ ] Implement exponential backoff algorithm
- [ ] Add configuration for max retries, base delay
- [ ] Integrate with StripeClient
- [ ] Add tests for retry scenarios
```

## Brainstorming Workflow Commands

### 1. `/flow-brainstorm-start`

**When**: Starting brainstorming for current iteration

**Effect**:
- Adds brainstorming section to current iteration
- Prompts user for subjects to discuss
- Creates "Subjects to Discuss" list

**Example**:
```
User: /flow-brainstorm-start
AI: Let's start brainstorming for Iteration 2: Error Handling.

What subjects should we discuss? (e.g., "Retry strategy, Error logging, Circuit breaker")

User: Retry strategy, Error taxonomy, Logging format, Integration with existing error handler

AI: Added 4 subjects to brainstorming session in phase-2/task-3.md
```

### 2. `/flow-next-subject`

**When**: Ready to discuss next subject

**Effect**:
- Finds next ⏳ PENDING subject
- Discusses with user
- Documents decision
- User/AI chooses Type A/B/C/D
- Creates action items if needed
- Marks subject ✅ COMPLETE

**Example**:
```
User: /flow-next-subject
AI: Let's discuss Subject 1: Retry Strategy

[Discussion happens...]

AI: Decision: Use exponential backoff with 3 retries

Is this:
A) Pre-implementation task (< 30 min, blocking)
B) Documentation update (update PLAN.md Architecture)
C) Auto-resolved by another subject
D) Main iteration work (implementation action items)

User: D

AI: What are the action items?

User: Create RetryPolicy class, implement backoff algorithm, integrate with client, add tests

AI: Documented. Subject 1 marked complete. 3 subjects remaining.
```

### 3. `/flow-brainstorm-review` (CRITICAL!)

**When**: After ALL subjects resolved, BEFORE `/flow-brainstorm-complete`

**Why Critical**:
- AI reviews all decisions holistically
- Suggests if more iterations needed
- Identifies pre-implementation tasks
- Catches missing subjects

**Effect**:
- AI reads all resolved subjects
- Suggests additional iterations if decisions reveal more work
- Creates "Pre-Implementation Tasks" section if Type A subjects found
- Confirms readiness to close brainstorming

**Example**:
```
User: /flow-brainstorm-review
AI: Reviewing all 4 resolved subjects...

Summary:
- Subject 1: Retry strategy (Type D) → Main iteration work
- Subject 2: Error taxonomy (Type B) → Updated PLAN.md
- Subject 3: Logging format (Type D) → Main iteration work
- Subject 4: Integration with error handler (Type A) → Pre-implementation task

Analysis:
Based on the decisions, I recommend:

1. Pre-Implementation Task Identified:
   - Subject 4 requires updating ErrorHandler.ts before implementing retry logic
   - Estimated: 20 minutes
   - Action: Update ErrorHandler to support async operations

2. Current Iteration Scope Confirmed:
   - Implementing RetryPolicy and logging is appropriate for this iteration
   - Estimated: 3-4 hours of work

3. No Additional Iterations Needed:
   - All error handling concerns addressed
   - Circuit breaker deferred to V2

Next Steps:
1. Complete pre-implementation task (update ErrorHandler.ts)
2. Run /flow-brainstorm-complete
3. Run /flow-implement-start

Ready to proceed?
```

### 4. `/flow-brainstorm-complete`

**When**: After completing ALL pre-implementation tasks

**Effect**:
- Marks brainstorming ✅ COMPLETE
- Changes iteration status to 🎨 READY
- Updates DASHBOARD.md

**Example**:
```
User: /flow-brainstorm-complete
AI: Verifying pre-implementation tasks...
✅ Pre-Task 1: Update ErrorHandler.ts - COMPLETE

Brainstorming complete! Iteration 2 is now 🎨 READY.

Next: /flow-implement-start to begin coding.
```

## Pre-Implementation Tasks Pattern

### Structure

```markdown
#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

##### ⏳ Pre-Task 1: [Name]

**Why Blocking**: [Explanation of why this blocks implementation]

**Scope** (< 30 min):
- [What needs to be done]
- [Specific changes]

**Files**:
- [List of files to modify]

**Test**: [How to verify it's done]

---

##### ✅ Pre-Task 2: [Name]

**Completed**: [Date]

**Changes Made**:
- [What was actually done]
- [Any deviations from plan]
```

### Workflow

1. During brainstorming, Type A subjects are identified
2. `/flow-brainstorm-review` creates "Pre-Implementation Tasks" section
3. User completes each pre-task (or AI helps)
4. Mark each pre-task ✅ with completion date
5. Only after ALL pre-tasks done → `/flow-brainstorm-complete`

### Why This Pattern Exists

**Problem**: During brainstorming, you discover small blocking issues:
- Interface signature is wrong
- Enum is missing a value
- Legacy code doesn't support new pattern
- Type definitions need update

**Without Pre-Tasks**:
- Start implementation
- Hit blocker
- Stop to fix blocker
- Lose context
- Take longer overall

**With Pre-Tasks**:
- Identify blockers upfront during brainstorming
- Fix them while context is fresh
- Start implementation with clean path
- No interruptions

## Bugs Discovered Pattern

**Use Case**: During brainstorming, you analyze reference implementations and find bugs

**Pattern**:
```markdown
#### Bugs Discovered in Reference Implementation

##### Bug 1: Race Condition in PaymentService

**Location**: `src/services/PaymentService.ts:145`

**Problem**:
```typescript
// Current code (buggy)
async processPayment(amount: number) {
  const status = await this.checkStatus();
  // Race condition: status can change between check and update
  await this.updatePayment(status);
}
```

**Fix**:
```typescript
// Fixed code
async processPayment(amount: number) {
  await this.db.transaction(async (tx) => {
    const status = await this.checkStatus(tx);
    await this.updatePayment(status, tx);
  });
}
```

**Impact**: Could cause duplicate charges in concurrent requests

**Action**: Add to Pre-Implementation Tasks
```

**Why Document This**:
- Shows thorough analysis
- Prevents reintroducing same bugs
- Helps team learn from reference code
- Documents why certain patterns are used


<!-- AI_SCAN:IMPLEMENTATION_PATTERN:1880-1970 -->
# Implementation Pattern (Complete Guide)

## What is Implementation?

**Implementation** is the coding phase where you execute action items from brainstorming.

**Location**: Inside task file, within iteration section, after brainstorming

**Prerequisite**: Brainstorming must be ✅ COMPLETE (status 🎨 READY)

## Implementation Structure

```markdown
#### Implementation - Iteration [N]: [Name]

**Status**: 🚧 IN PROGRESS

**Action Items**: See resolved subjects above

**Implementation Notes**:
[Document discoveries, decisions, challenges during work]

**Files Modified**:
- [file1.ts] - [what changed]
- [file2.ts] - [what changed]

**Verification**:
- ✅ [verification step 1]
- ✅ [verification step 2]
```

## Implementation Workflow

### 1. `/flow-implement-start`

**Prerequisites**:
- Brainstorming ✅ COMPLETE
- All pre-implementation tasks ✅ COMPLETE
- Iteration status is 🎨 READY

**Effect**:
- Adds "Implementation" section to current iteration
- Changes iteration status: 🎨 READY → 🚧 IN PROGRESS
- Updates DASHBOARD.md

### 2. Do the Work

**During Implementation**:
- Work through action items from resolved subjects
- Document discoveries in "Implementation Notes"
- Track files modified
- Note any deviations from plan

**Good Implementation Notes**:
```markdown
**Implementation Notes**:
- Discovered Stripe SDK v12 deprecated `charges.create()`, using `paymentIntents.create()` instead
- Added StripeErrorMapper class to convert SDK errors to domain errors (not in original plan, but needed)
- Performance: API calls taking 200-300ms, added caching layer (will document in Architecture)
- Bug found: Existing PaymentRepository missing transaction support, added in separate commit
```

### 3. `/flow-implement-complete`

**Prerequisites**:
- All action items done
- Code works (tests pass)
- Implementation notes updated

**Effect**:
- Marks iteration ✅ COMPLETE
- Updates DASHBOARD.md
- Moves to next iteration or completes task

## Verification Checklist

Before marking iteration complete, verify:

**Code Quality**:
- [ ] All action items implemented
- [ ] Code follows project style guide
- [ ] No commented-out code or TODOs left behind
- [ ] Error handling in place

**Testing**:
- [ ] Unit tests written and passing
- [ ] Integration tests if needed
- [ ] Manual testing done
- [ ] Edge cases covered

**Documentation**:
- [ ] Implementation notes updated
- [ ] Files modified list complete
- [ ] Any architecture changes documented in PLAN.md
- [ ] Code comments for complex logic

**Integration**:
- [ ] Works with existing code
- [ ] No breaking changes (or documented if intentional)
- [ ] Dependencies satisfied
- [ ] Performance acceptable

## When to Mark Complete

**✅ Mark Complete When**:
- All verification checklist items done
- You would be comfortable shipping this
- Another developer could understand what was done
- No blocking issues remain

**❌ Don't Mark Complete When**:
- Tests are failing
- Code is partially implemented
- "TODO: finish this later" comments exist
- Blocking bugs discovered but not fixed

---

<!-- AI_SCAN:STATUS_MANAGEMENT:1972-2100 -->
# Status Management

## Status Marker Lifecycle

### Phase Lifecycle

```
⏳ PENDING (created)
    ↓
    /flow-phase-start
    ↓
🚧 IN PROGRESS (working on tasks)
    ↓
    /flow-phase-complete (all tasks done)
    ↓
✅ COMPLETE
```

**Alternative Endings**:
- ❌ CANCELLED (decided not to do this phase)
- 🔮 DEFERRED (moved to V2/V3, added to BACKLOG.md)

### Task Lifecycle (with Iterations)

```
⏳ PENDING (created)
    ↓
    /flow-task-start
    ↓
🚧 IN PROGRESS (working on iterations)
    ↓
    /flow-task-complete (all iterations done)
    ↓
✅ COMPLETE
```

### Iteration Lifecycle

```
⏳ PENDING (created)
    ↓
    /flow-brainstorm-start
    ↓
🚧 IN PROGRESS (brainstorming)
    ↓
    /flow-brainstorm-complete (all subjects resolved, pre-tasks done)
    ↓
🎨 READY (ready to implement)
    ↓
    /flow-implement-start
    ↓
🚧 IN PROGRESS (implementing)
    ↓
    /flow-implement-complete (all action items done, verified)
    ↓
✅ COMPLETE
```

**Simplified Path** (no brainstorming):
```
⏳ PENDING
    ↓
    /flow-implement-start (if no brainstorming needed)
    ↓
🚧 IN PROGRESS
    ↓
    /flow-implement-complete
    ↓
✅ COMPLETE
```

## State Transitions

### Valid Transitions

**Phase**:
- ⏳ → 🚧 (start)
- 🚧 → ✅ (complete)
- 🚧 → ❌ (cancel)
- 🚧 → 🔮 (defer)
- ⏳ → ❌ (cancel before starting)
- ⏳ → 🔮 (defer before starting)

**Task**:
- ⏳ → 🚧 (start)
- 🚧 → ✅ (complete)
- 🚧 → ❌ (cancel)
- 🚧 → 🔮 (defer)

**Iteration**:
- ⏳ → 🚧 (start brainstorming or implementing)
- 🚧 → 🎨 (finish brainstorming)
- 🎨 → 🚧 (start implementing)
- 🚧 → ✅ (finish implementing)

### Invalid Transitions

**Never Do This**:
- ❌ ✅ → 🚧 (reopening completed work - create new iteration instead)
- ❌ ⏳ → ✅ (skipping work - mark cancelled or remove if never needed)
- ❌ 🎨 → ⏳ (moving backwards - if brainstorming wrong, add new iteration)

## Common Pitfalls

### Pitfall 1: Marking Complete Too Early

**Problem**:
```markdown
### Iteration 2: Error Handling ✅ COMPLETE

**Implementation Notes**:
- Started implementing retry logic
- TODO: finish exponential backoff
- TODO: add tests
```

**Why Bad**: Work is not done, tests missing, TODOs present

**Fix**: Keep status 🚧 IN PROGRESS until ALL work done

### Pitfall 2: Not Updating DASHBOARD.md

**Problem**: Update task file status but forget DASHBOARD.md

**Effect**: DASHBOARD.md shows wrong current work, user is confused

**Fix**: Commands automatically update both files

### Pitfall 3: Skipping Brainstorming

**Problem**:
```markdown
### Iteration 2: Complex Feature ⏳

[Immediately start implementing without design]
```

**Why Bad**: No decisions documented, will need refactoring later

**Fix**: Always brainstorm for complex work, only skip for trivial iterations

### Pitfall 4: Mixing Status in DASHBOARD and Task File

**Problem**:
- DASHBOARD.md shows Iteration 2 🚧 IN PROGRESS
- Task file shows Iteration 2 ✅ COMPLETE

**Why Bad**: Source of truth is inconsistent

**Fix**: `/flow-verify-plan` detects this, always update both together

## Recovery from Incorrect States

### Reopening Completed Work

**Scenario**: Marked iteration complete, but found bugs/issues

**Wrong Approach**: Change ✅ → 🚧

**Right Approach**:
1. Keep original iteration ✅ COMPLETE
2. Add new iteration: "Iteration N+1: Fix Issues from Iteration N"
3. Document what needs fixing

**Why**: Preserves history, shows work progression

### Abandoned Work

**Scenario**: Started iteration, decided not to finish

**Options**:
1. **Cancel**: Mark ❌ CANCELLED with reason
2. **Defer**: Mark 🔮 DEFERRED, move to BACKLOG.md with reason
3. **Remove**: If truly never started, just delete iteration

**Choose Cancel/Defer**: When some work was done or decision has value

**Choose Remove**: When created by mistake, no work done

### Stuck in Brainstorming

**Scenario**: Brainstorming taking too long, can't resolve subjects

**Solution**:
1. Review resolved subjects
2. Identify if subject should be Type C (auto-resolved)
3. Consider if subject should move to separate iteration
4. If truly stuck, add subject as "Research spike" iteration

---

<!-- AI_SCAN:FILE_TEMPLATES:2102-2600 -->
# File Templates

## DASHBOARD.md Template

```markdown
# [Project Name] - Dashboard

**Last Updated**: [Date & Time]

**Project**: [Brief one-liner]
**Status**: [Overall status]
**Version**: [V1/V2/V3]

---

## 📍 Current Work

- **Phase**: [Phase N - Name](phase-N/)
- **Task**: [Task M - Name](phase-N/task-M.md)
- **Iteration**: [Iteration K - Name](phase-N/task-M.md#iteration-K) [Status Emoji]
- **Focus**: [One sentence describing current work]

---

## 📊 Progress Overview

### Phase 1: [Name] [Status Emoji]

**Goal**: [One sentence phase goal]
**Status**: [Completion summary, e.g., "3/3 tasks complete"]

**Tasks**:
- [Status Emoji] **Task 1**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]
  - [Status Emoji] Iteration 2: [Name]
- [Status Emoji] **Task 2**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]

### Phase 2: [Name] [Status Emoji]

**Goal**: [One sentence phase goal]
**Status**: [Completion summary]

**Tasks**:
- [Status Emoji] **Task 1**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]
  - 🚧 Iteration 2: [Name] ← **CURRENT**
  - ⏳ Iteration 3: [Name]

---

## 💡 Key Decisions

**Decision Needed**: [Question for user]
- Option A: [Choice] - [Rationale]
- Option B: [Choice] - [Rationale]
- **Recommendation**: [If AI has suggestion]

**Resolved**:
- **[Date]**: [Decision made] - [Brief rationale]
```

---

## PLAN.md Template

```markdown
# [Feature/Project Name] - Development Plan

> **📖 Framework Guide**: See [DEVELOPMENT_FRAMEWORK.md](DEVELOPMENT_FRAMEWORK.md) for complete methodology
> **📍 Current Progress**: See [DASHBOARD.md](DASHBOARD.md) for real-time status tracking
> **🎯 Purpose**: [One sentence describing what this feature/project does]

**Created**: [Date]
**Version**: [V1/V2/V3]
**Plan Location**: `.flow/` (managed by Flow framework)

---

## Overview

### Purpose

[2-3 paragraphs explaining WHY this feature exists and WHAT problem it solves]

### Goals

[Describe what success looks like - text format, NOT checklists]

**Primary Goals**:
- [Measurable goal 1]
- [Measurable goal 2]
- [Measurable goal 3]

**Success Criteria**:
- [How we know this is successful]
- [Performance targets, if applicable]
- [User experience goals]

### Scope

**V1 Scope** (Current Session):
- [Feature 1]
- [Feature 2]
- [Feature 3]
- [Constraint/limitation]

**Note**: V2/V3/Out-of-Scope sections only included if user explicitly requests them. Default to V1-only scope for minimal planning overhead.

---

## Architecture

### System Context

[High-level description of how this feature fits into the system - describe WHAT exists, NOT prescriptive current-vs-desired with line numbers]

**Components**:
- **[ComponentName]**: [Responsibility]
- **[ComponentName]**: [Responsibility]

**Key Dependencies**:
- [Internal service/module]: [What we need from it]
- [External library/API]: [Why we need it, version if relevant]

**Reference Implementations** (if relevant):
- [Existing code to learn from]: [File path or description]
- [Similar feature]: [What to reuse/avoid]

---

## DO / DON'T Guidelines

**✅ DO**:
- [Best practice for this project]
- [Quality standard to maintain]
- [Pattern to follow]

**❌ DO NOT**:
- [Anti-pattern to avoid]
- [Common mistake to prevent]
- [Constraint to respect]

---

## Notes & Learnings

**Design Decisions**:
- [Date]: [Decision made and rationale]

**References**:
- [External doc]: [URL]
- [Internal doc]: [Path]
```

---

## task-N.md Template (With Iterations)

```markdown
# Task [N]: [Task Name]

**Status**: ⏳ PENDING
**Phase**: [Phase M - Name](../DASHBOARD.md#phase-M-name)
**Purpose**: [One sentence - what this task accomplishes]

---

## Task Overview

[2-3 paragraphs describing this task in detail]

**Why This Task**: [Explanation of why this task is necessary]

**Dependencies**:
- **Requires**: [Task name/number] - [What we need from it]
- **Blocks**: [Task name/number] - [What depends on this]

**Estimated Complexity**: [Low/Medium/High] ([X iterations expected])

---

## Iterations

### ⏳ Iteration 1: [Name]

**Goal**: [One sentence - what this iteration achieves]

**Status**: ⏳ PENDING

---

#### Brainstorming Session - [Iteration Name]

(Optional - design decisions will be documented here if needed)

**Focus**: [What we're designing - TBD]

**Subjects to Discuss**:
- (Add subjects with /flow-brainstorm-subject)

**Resolved Subjects**:
- (Filled during brainstorming)

---

#### Action Items

- [ ] [TBD - Define during brainstorming or add directly]

---

### ⏳ Iteration 2: [Name]

**Goal**: [One sentence - what this iteration achieves]

**Status**: ⏳ PENDING

---

#### Brainstorming Session - [Iteration Name]

(Optional - design decisions will be documented here if needed)

**Focus**: [What we're designing - TBD]

**Subjects to Discuss**:
- (Add subjects with /flow-brainstorm-subject)

**Resolved Subjects**:
- (Filled during brainstorming)

---

#### Action Items

- [ ] [TBD - Define during brainstorming or add directly]

---

## Task Notes

**Discoveries**:
- [Things learned while working on this task]

**Decisions**:
- [Task-specific decisions made]

**References**:
- [Relevant code]: [Path]
- [Documentation]: [URL]
```

---

## Iteration Section Template (Full)

```markdown
### [Status Emoji] Iteration [N]: [Name]

**Goal**: [One sentence]

**Status**: [Status]

---

#### Pre-Implementation Tasks

(Optional - only if Type A subjects identified during brainstorming)

##### ⏳ Pre-Task 1: [Name]

**Why Blocking**: [Explanation]

**Scope** (< 30 min):
- [What to do]

**Files**:
- [file1]

**Test**: [How to verify]

---

#### Brainstorming Session - [Topic]

(Optional - only for complex iterations requiring design decisions)

**Focus**: [What we're designing]

**Subjects to Discuss**:
1. ⏳ [Subject name]
2. ⏳ [Subject name]

**Resolved Subjects**:

---

##### ✅ Subject 1: [Name]

**Decision**: [The decision made]

**Resolution Type**: [A/B/C/D]

**Rationale**: [Why this decision]

**Resolution Items** (if Type D):
- [Item to do]
- [Item to do]

**Note**: Type A creates Pre-Tasks. Type B updates PLAN.md immediately. Type C references other subjects. Type D creates Resolution Items.

---

#### Action Items

(Required - ONE list per iteration)

**If brainstorming**: `/flow-brainstorm-review` consolidates all Resolution Items into this list
**If no brainstorming**: List action items directly

- [ ] [Action item 1]
- [ ] [Action item 2]
- [ ] [Action item 3]

---

#### Implementation - Iteration [N]: [Name]

(Added by `/flow-implement-start`, updated during work, completed by `/flow-implement-complete`)

**Status**: 🚧 IN PROGRESS

**Implementation Notes**:
- [Discovery during implementation]
- [Change from plan]

**Files Modified**:
- [file1.ts] - [what changed]
- [file2.ts] - [what changed]

**Verification**:
- ✅ [Test passed]
- ✅ [Manual verification done]
```


<!-- AI_SCAN:COMMAND_PATTERNS:2726-2900 -->
# Command Patterns

## Dashboard-First Navigation Pattern (Detailed)

**Used By**: 16 commands (brainstorming, implementation, state management)

### Pattern Steps

```
1. Read DASHBOARD.md
2. Extract current context from "📍 Current Work" section:
   - Phase number (e.g., "Phase 2")
   - Task number (e.g., "Task 3")
   - Iteration number (e.g., "Iteration 2")
3. Construct task file path: phase-{N}/task-{M}.md
4. Read task file
5. Locate relevant section (e.g., Iteration K)
6. Perform operation (read/edit)
7. Update DASHBOARD.md with new state
```

### Example Implementation

**Command**: `/flow-implement-start`

```
Step 1: Read DASHBOARD.md
→ Extract: Phase 2, Task 3, Iteration 2

Step 2: Construct path
→ phase-2/task-3.md

Step 3: Read phase-2/task-3.md
→ Find "### Iteration 2: Error Handling"

Step 4: Check prerequisites
→ Brainstorming status: ✅ COMPLETE
→ Iteration status: 🎨 READY

Step 5: Add Implementation section
→ Insert "#### Implementation - Iteration 2: Error Handling"
→ Add structure (Status, Action Items, Implementation Notes, etc.)

Step 6: Update DASHBOARD.md
→ Change "Iteration 2" status: 🎨 READY → 🚧 IN PROGRESS
→ Update "Last Updated" timestamp
→ Update "Current Work" section if needed

Step 7: Notify user
→ "Started implementation of Iteration 2. See phase-2/task-3.md for details."
```

### Commands Using This Pattern

- `/flow-brainstorm-start`
- `/flow-brainstorm-subject`
- `/flow-next-subject`
- `/flow-brainstorm-review`
- `/flow-brainstorm-complete`
- `/flow-implement-start`
- `/flow-implement-complete`
- `/flow-iteration-add`
- `/flow-task-start`
- `/flow-task-complete`
- `/flow-next`
- `/flow-next-iteration`

---

## Structure Creation Pattern

**Used By**: 4 commands (blueprint, phase-add, task-add, migrate)

### Pattern Steps

```
1. Read DASHBOARD.md (or create if missing for blueprint)
2. Determine what to create:
   - New phase directory?
   - New task file?
   - Initial project structure?
3. Create directory/file with template content
4. Update DASHBOARD.md to include new structure
5. Notify user with file paths created
```

### Example: `/flow-task-add "API Integration"`

```
Step 1: Read DASHBOARD.md
→ Current phase: Phase 2

Step 2: Determine next task number
→ Read phase-2/ directory
→ Find existing files: task-1.md, task-2.md
→ Next task number: 3

Step 3: Create phase-2/task-3.md
→ Use "Task with Iterations" template
→ Fill in: Task name, Phase link, Status ⏳

Step 4: Update DASHBOARD.md
→ Add to Phase 2 section:
  "- ⏳ **Task 3**: API Integration"

Step 5: Notify user
→ "Created phase-2/task-3.md. Use /flow-task-start to begin work."
```

---

## Full Traversal Pattern

**Used By**: 4 commands (status, summarize, verify-plan, plan-split)

### Pattern Steps

```
1. Read DASHBOARD.md
2. Extract all phases from "Progress Overview" section
3. For each phase:
   a. Read phase directory (phase-N/)
   b. List all task files (task-*.md)
   c. Read each task file
   d. Extract relevant information (status, iterations, completion)
4. Aggregate information
5. Generate report or perform validation
6. Return result to user
```

### Example: `/flow-summarize`

```
Step 1: Read DASHBOARD.md
→ Find phases: Phase 1, Phase 2, Phase 3

Step 2: For Phase 1:
→ Read phase-1/ directory
→ Files: task-1.md, task-2.md, task-3.md
→ Read each file, extract:
  - Task name
  - Status
  - Iteration count
  - Key decisions from brainstorming

Step 3: For Phase 2:
→ (repeat same process)

Step 4: For Phase 3:
→ (repeat same process)

Step 5: Generate summary
→ Format output:
  # Project Summary
  
  ## Phase 1: Foundation ✅ COMPLETE
  - Task 1: Project Setup (3 iterations) ✅
    - Key decisions: Singleton pattern, env-based config
  - Task 2: Core Models (2 iterations) ✅
    - Key decisions: Entity validation, repository pattern
  
  ## Phase 2: Core Implementation 🚧 IN PROGRESS
  ...
  
Step 6: Return summary to user
```

---

## Cross-File Search Pattern

**Used By**: 4 commands (backlog-add, backlog-pull, next-iteration, rollback)

### Pattern Steps

```
1. Read DASHBOARD.md (understand scope)
2. Determine search criteria:
   - Looking for next ⏳ iteration?
   - Finding task by number?
   - Searching for specific status?
3. Use Grep or Read to search across multiple task files
4. Collect matches
5. Perform operation (move to backlog, update status, etc.)
6. Update DASHBOARD.md if needed
7. Return result
```

### Example: `/flow-next-iteration`

```
Step 1: Read DASHBOARD.md
→ Current: Phase 2, Task 3, Iteration 2 (in progress)

Step 2: Determine next iteration to work on
→ Check current task file first (phase-2/task-3.md)
→ Look for next ⏳ iteration after current one

Step 3: Read phase-2/task-3.md
→ Find iterations:
  - Iteration 1: ✅ COMPLETE
  - Iteration 2: 🚧 IN PROGRESS (current)
  - Iteration 3: ⏳ PENDING ← FOUND
  - Iteration 4: ⏳ PENDING

Step 4: If found in current task
→ Return "Iteration 3: Retry Logic"
→ Show goal and status

Step 5: If not found in current task
→ Look at next task in current phase
→ Then next phase if needed

Step 6: Return result
→ "Next iteration: Iteration 3 - Retry Logic (phase-2/task-3.md)"
```

---

<!-- AI_SCAN:COMPLETE_WORKFLOW:2902-3200 -->
# Complete Workflow Examples

## Example 1: Payment Gateway Integration (Full Feature)

### Project Setup

```bash
# Create new project
/flow-blueprint

AI: Please provide project details:
- Feature name?
- Purpose?
- High-level phases?

User: Payment Gateway Integration
      Integrate Stripe for credit card payments
      Phases: Foundation, Core Implementation, Testing

AI: Created:
- DASHBOARD.md
- PLAN.md
- phase-1/ (Foundation)
- phase-1/task-1.md (Project Setup)
```

**Files Created**:
- `.flow/DASHBOARD.md` - Progress tracking
- `.flow/PLAN.md` - Overview, architecture, testing strategy
- `.flow/phase-1/` - First phase directory
- `.flow/phase-1/task-1.md` - Initial task

---

### Working Through Phase 1

```bash
# Start first phase
/flow-phase-start

# Add tasks to Phase 1
/flow-task-add "Project Setup"
/flow-task-add "Core Models"

# Start first task
/flow-task-start

# Add iteration to Task 1
/flow-iteration-add "Repository Structure"

# Start brainstorming
/flow-brainstorm-start

AI: What subjects should we discuss for Repository Structure?

User: Directory layout, Configuration setup, Dependency management

AI: Added 3 subjects to brainstorming. Use /flow-next-subject to begin.

# Resolve subjects
/flow-next-subject

AI: Let's discuss Subject 1: Directory Layout
    What structure should we use?

User: Standard src/ structure with feature-based organization

AI: Is this:
    A) Pre-implementation task
    B) Documentation update
    C) Auto-resolved
    D) Main iteration work

User: D

AI: Action items?

User: Create src/payment/ directory, Add index files, Setup barrel exports

AI: Subject 1 resolved. 2 subjects remaining.

/flow-next-subject
[... continue resolving subjects ...]

# After all subjects resolved
/flow-brainstorm-review

AI: Reviewing all 3 subjects...
    - Subject 1: Directory layout (Type D)
    - Subject 2: Config setup (Type D)
    - Subject 3: Dependencies (Type A - Pre-task)
    
    Pre-implementation task identified:
    - Update package.json with Stripe SDK
    
    Ready to proceed?

User: Yes

# Complete pre-task
[Install Stripe SDK]

# Complete brainstorming
/flow-brainstorm-complete

AI: Brainstorming complete. Iteration 1 is now 🎨 READY.
    Use /flow-implement-start to begin coding.

# Start implementation
/flow-implement-start

# Do the work
[Create directory structure, setup config, etc.]

# Complete implementation
/flow-implement-complete

AI: Iteration 1 complete! ✅
    Next: Use /flow-iteration-add for Iteration 2, or /flow-task-complete if task is done.
```

**Files Updated During This Workflow**:
1. **DASHBOARD.md**:
   - Phase 1 status: ⏳ → 🚧
   - Task 1 status: ⏳ → 🚧 → ✅
   - Current work pointer updated throughout
   - Progress percentages updated

2. **phase-1/task-1.md**:
   - Task status: ⏳ → 🚧
   - Iteration 1 added
   - Brainstorming section filled
   - Implementation notes added
   - Status: 🚧 → ✅

---

### Moving to Phase 2

```bash
# Complete Phase 1
/flow-phase-complete

AI: Phase 1 complete! ✅
    Ready to start Phase 2?

# Add Phase 2
/flow-phase-add "Core Implementation"

# Start Phase 2
/flow-phase-start

# Add tasks
/flow-task-add "API Integration"
/flow-task-add "Webhook Handler"
/flow-task-add "Error Handling"

# Work through tasks
[... repeat similar workflow as Phase 1 ...]
```

---

## Example 2: Simple Task with Single Iteration

```bash
# Add simple task
/flow-task-add "Update Documentation"

AI: Created phase-2/task-4.md
    Task created with iterations structure.

    Since this is simple documentation work, you can:
    - Add one iteration with direct action items (skip brainstorming)
    - Start, implement, and complete quickly

# Add single iteration
/flow-iteration-add "Documentation Updates"

AI: Added Iteration 1 to Task 4.
    For simple work, you can skip brainstorming and add action items directly.

User: Add these action items:
      - Update README
      - Fix typos
      - Add examples

AI: Added 3 action items to Iteration 1.
    Use /flow-implement-start to begin.

# Start implementation
/flow-implement-start

# Do the work
[Update docs]

# Complete implementation
/flow-implement-complete

AI: Iteration 1 complete! ✅
    Task 4 has 1/1 iterations complete.
    Use /flow-task-complete to mark task done.

/flow-task-complete

AI: Task 4 complete! ✅
    Moving to next task...
```

**Note**: Simple tasks use one iteration with direct action items - no brainstorming required.

---

## Example 3: Deferring Work to Backlog

```bash
# During Phase 2, decide to defer a task
/flow-backlog-add 5 "Multi-currency support adds too much complexity for V1"

AI: Moved Task 5 to BACKLOG.md with reason.
    Updated DASHBOARD.md to reflect removal.

# Later, pull it back
/flow-backlog-pull 5

AI: Pulled Task 5 from backlog.
    Added to end of Phase 2.
    Updated DASHBOARD.md.
```

---

## Example 4: Archiving Completed Work

```bash
# After completing Phase 1 and Phase 2
/flow-plan-split

AI: Archiving completed work...
    - Phase 1: 3 tasks archived
    - Phase 2: Task 1-2 archived (completed only)
    
    Created ARCHIVE.md with all completed task details.
    
    Updated task files to reference archive:
    - phase-1/task-1.md → "See ARCHIVE.md"
    - phase-1/task-2.md → "See ARCHIVE.md"
    - phase-2/task-1.md → "See ARCHIVE.md"
    - phase-2/task-2.md → "See ARCHIVE.md"
    
    DASHBOARD.md now shows only active work.
```

---

<!-- AI_SCAN:BACKLOG_MANAGEMENT:3202-3500 -->
# Backlog Management

## BACKLOG.md Structure

```markdown
# Project Backlog

**Last Updated**: [Date]

---

## 📋 Backlog Dashboard

**Total Items**: [N]

**By Version**:
- V2 Features: [N]
- V3 Features: [N]
- Technical Debt: [N]
- Deferred Tasks: [N]

**By Priority**:
- High: [N]
- Medium: [N]
- Low: [N]

---

## Backlog Items

### High Priority

#### ⏳ Task: Multi-Currency Support

**Originally Planned**: Phase 2, Task 6
**Deferred To**: V2
**Priority**: High

**Reasoning**:
V1 scope focuses on USD only. Multi-currency requires:
- Exchange rate API integration
- Currency conversion logic
- Multi-currency display in UI
- Testing across currencies

This adds 2-3 weeks and is not critical for V1 launch.

**Estimated Effort**: 2-3 weeks
**Dependencies**: Core payment processing complete (Phase 2, Task 1-3)

**When to Pull Back**:
- After V1 launch
- When international customers become priority
- When we have exchange rate API access

---

#### ⏳ Task: Advanced Retry Logic with Circuit Breaker

**Originally Planned**: Phase 2, Task 3, Iteration 3
**Deferred To**: V2
**Priority**: High

**Reasoning**:
Basic retry logic (3 attempts, exponential backoff) is sufficient for V1.
Circuit breaker pattern adds value but requires:
- State management for circuit status
- Monitoring and alerting integration
- Configuration management
- Additional testing

**Estimated Effort**: 1 week
**Dependencies**: Basic retry logic (Phase 2, Task 3, Iteration 2)

---

### Medium Priority

#### ⏳ Feature: Saved Payment Methods

**Deferred To**: V2
**Priority**: Medium

**Reasoning**:
V1 focuses on one-time payments. Saved payment methods require:
- Secure token storage
- Card management UI
- PCI compliance review
- Additional security testing

**Estimated Effort**: 2 weeks
**Dependencies**: Payment processing complete, Security audit done

---

### Low Priority

#### ⏳ Technical Debt: Refactor PaymentService

**Deferred To**: V3
**Priority**: Low

**Reasoning**:
Current PaymentService works but has some code duplication.
Not urgent, can refactor after V2 when we understand all use cases better.

**Estimated Effort**: 3-4 days
**Dependencies**: None

---

## Removed from Backlog

### Task: ACH Payment Support

**Originally**: V2 Feature
**Removed**: 2025-01-20
**Reason**: Business decision - focus on credit cards only for foreseeable future
```

---

## Backlog Commands

### `/flow-backlog-add [task-number] "[reason]"`

**Purpose**: Move task from active plan to backlog

**Usage**:
```bash
# Move single task
/flow-backlog-add 6 "Multi-currency adds too much complexity for V1, deferring to V2"

# Move range of tasks
/flow-backlog-add 6-8 "These features are V2 scope"
```

**Effect**:
1. Reads DASHBOARD.md, finds Phase/Task info
2. Reads task file (phase-N/task-M.md)
3. Copies task details to BACKLOG.md with reason
4. Marks task as 🔮 DEFERRED in DASHBOARD.md
5. Updates task file status to 🔮 DEFERRED with reference to BACKLOG.md

**Task File After**:
```markdown
# Task 6: Multi-Currency Support

**Status**: 🔮 DEFERRED
**Deferred To**: V2
**Reason**: Too complex for V1 scope

See [BACKLOG.md](../BACKLOG.md#task-multi-currency-support) for details and reasoning.
```

---

### `/flow-backlog-view`

**Purpose**: Show backlog contents

**Usage**:
```bash
/flow-backlog-view
```

**Output**:
```
Backlog Summary:
- Total items: 8
- V2 features: 5
- V3 features: 2
- Technical debt: 1

High Priority (3 items):
1. Multi-Currency Support (V2)
2. Advanced Retry Logic (V2)
3. Saved Payment Methods (V2)

Medium Priority (3 items):
...

See BACKLOG.md for full details.
```

---

### `/flow-backlog-pull [task-number] [position]"`

**Purpose**: Pull task from backlog back into active plan

**Usage**:
```bash
# Pull task, add to end of current phase
/flow-backlog-pull 6

# Pull task, insert after specific task
/flow-backlog-pull 6 "after task 3"

# Pull task, insert at beginning of phase
/flow-backlog-pull 6 "at start"
```

**Effect**:
1. Reads BACKLOG.md, finds task details
2. Determines current phase from DASHBOARD.md
3. Creates new task file in phase directory
4. Assigns next available task number
5. Updates DASHBOARD.md with new task
6. Removes from BACKLOG.md (or marks as pulled)

**Example**:
```bash
/flow-backlog-pull 6

AI: Pulled "Multi-Currency Support" from backlog.
    Created phase-2/task-6.md
    Updated DASHBOARD.md
    
    Task is now ⏳ PENDING in Phase 2.
    Use /flow-task-start when ready to begin.
```

---

## When to Use Backlog

### Use Backlog For:

**V2/V3 Features**:
- Features planned but not in current version scope
- Enhancements discovered during V1 development
- Nice-to-have features that aren't MVP

**Deferred Tasks**:
- Tasks started but decided against mid-development
- Tasks that turned out more complex than expected
- Tasks blocked by external dependencies (waiting for API access, etc.)

**Technical Debt**:
- Refactoring opportunities identified
- Code improvements that aren't urgent
- Performance optimizations that can wait

**Scope Creep Prevention**:
- Features requested during development that expand scope
- "Wouldn't it be cool if..." ideas
- Gold-plating attempts

### Don't Use Backlog For:

**Cancelled Work**:
- Use ❌ CANCELLED status in task file instead
- Document reason directly in task

**Bugs**:
- Bugs should be fixed, not backlogged
- Exception: Non-critical bugs in V2 features can be backlogged with V2

**Core MVP Features**:
- If it's truly needed for V1, keep it in active plan
- Descope properly rather than backlog everything

---

<!-- AI_SCAN:BEST_PRACTICES:3502-3800 -->
# Best Practices & Pitfalls

## Best Practices

### 1. Always Brainstorm for Complex Work

**✅ DO**:
```markdown
### Iteration 2: Error Handling ⏳

[Brainstorming section]
[Pre-implementation tasks]
[Implementation section]
```

**❌ DON'T**:
```markdown
### Iteration 2: Error Handling ⏳

[Start implementing without design]
```

**Why**: Brainstorming surfaces decisions early, prevents refactoring later.

---

### 2. Keep DASHBOARD.md Up-to-Date

**✅ DO**:
- Update DASHBOARD.md every time status changes
- Use commands that automatically update both files
- Run `/flow-status` regularly to verify state

**❌ DON'T**:
- Update task file but forget DASHBOARD.md
- Manually edit both files (error-prone)
- Let DASHBOARD.md get stale

**Why**: DASHBOARD.md is source of truth for current state. Stale dashboard confuses everyone.

---

### 3. Use Descriptive Commit Messages

**✅ DO**:
```bash
git commit -m "Complete Iteration 2: Error Handling

- Implemented RetryPolicy with exponential backoff
- Added error taxonomy mapping
- Fixed legacy ErrorHandler async support
- All tests passing

Updated: phase-2/task-3.md, DASHBOARD.md"
```

**❌ DON'T**:
```bash
git commit -m "updates"
```

**Why**: Commit history tells story of feature development.

---

### 4. Document Discoveries Immediately

**✅ DO**:
```markdown
**Implementation Notes**:
- Discovered Stripe SDK v12 deprecated charges API
- Switched to PaymentIntents API (newer, more flexible)
- Added StripeErrorMapper class (not in original plan)
- Performance: API calls 200-300ms, added caching
```

**❌ DON'T**:
```markdown
**Implementation Notes**:
(empty)
```

**Why**: Discoveries are valuable context for future work and team members.

---

### 5. Break Down Large Tasks

**✅ DO**:
```
Phase 2: Core Implementation
- Task 1: Database Layer (3 iterations)
- Task 2: Business Logic (4 iterations)
- Task 3: API Integration (4 iterations)
```

**❌ DON'T**:
```
Phase 2: Core Implementation
- Task 1: Everything (25 iterations)
```

**Why**: Smaller tasks are easier to reason about, track progress, and complete.

---

### 6. Use Pre-Implementation Tasks

**✅ DO**:
```markdown
#### Pre-Implementation Tasks

##### ⏳ Pre-Task 1: Fix Interface Signature

**Why Blocking**: Current interface doesn't support async
...

[Complete before /flow-brainstorm-complete]
```

**❌ DON'T**:
```markdown
[Start implementation]
[Hit blocker]
[Stop to fix blocker]
[Lose context]
```

**Why**: Unblock early while context is fresh.

---

### 7. Reference PLAN.md for Big Decisions

**✅ DO**:
- Update PLAN.md Architecture section for Type B decisions
- Reference PLAN.md when explaining system design
- Keep PLAN.md as single source of truth for architecture

**❌ DON'T**:
- Scatter architecture decisions across task files
- Forget to document major design choices
- Let PLAN.md get out of sync with reality

---

### 8. Use /flow-verify-plan Regularly

**✅ DO**:
```bash
/flow-verify-plan

# Run this:
- After bulk edits
- When feeling lost
- Before marking phase complete
- After pulling from git
```

**Why**: Catches inconsistencies early before they cause confusion.

---

## Common Pitfalls

### Pitfall 1: Skipping /flow-brainstorm-review

**Problem**:
```bash
/flow-next-subject  # Resolve all subjects
/flow-brainstorm-complete  # Skip review!
```

**Why Bad**: Miss identifying pre-implementation tasks, miss suggesting more iterations.

**Fix**: ALWAYS run `/flow-brainstorm-review` after resolving all subjects, BEFORE `/flow-brainstorm-complete`.

---

### Pitfall 2: Marking Complete Too Early

**Problem**:
```markdown
### Iteration 2: Error Handling ✅ COMPLETE

**Implementation Notes**:
- TODO: Add tests
- TODO: Fix edge case
```

**Why Bad**: Work not actually done, TODOs present.

**Fix**: Only mark ✅ COMPLETE when ALL work done, verified, and no TODOs remain.

---

### Pitfall 3: Not Reading DASHBOARD.md First

**Problem**:
```
[AI tries to edit task file without reading DASHBOARD.md]
[Edits wrong task/iteration]
[Causes confusion]
```

**Why Bad**: Don't know current context, edit wrong places.

**Fix**: ALWAYS read DASHBOARD.md first (dashboard-first pattern).

---

### Pitfall 4: Creating Too Many Small Tasks

**Problem**:
```
Phase 2: Core Implementation
- Task 1: Create class (1 action item)
- Task 2: Add method (1 action item)
- Task 3: Add another method (1 action item)
[... 20 tiny tasks ...]
```

**Why Bad**: Overhead of task management exceeds value.

**Fix**: Combine related small work into one task with multiple action items or iterations.

---

### Pitfall 5: Not Linking Files

**Problem**:
```markdown
# Task 3 in phase-2/task-3.md

**Phase**: Phase 2
```

**Why Bad**: No clickable link back to DASHBOARD.md, hard to navigate.

**Fix**: Always use markdown links:
```markdown
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
```

---

### Pitfall 6: Forgetting to Update Examples

**Problem**: Make changes to framework, forget to update example files.

**Why Bad**: Users learn from outdated examples.

**Fix**: After changing framework docs, update examples/ directory to match.

---

## Performance Tips

### For Large Projects

**Problem**: 100+ tasks across 10 phases = slow to navigate

**Solutions**:

1. **Use /flow-plan-split regularly**:
   - Archives completed work
   - Keeps active plan small
   - Old work still accessible in ARCHIVE.md

2. **Leverage DASHBOARD.md**:
   - Dashboard has jump links
   - Don't read all task files, just current one
   - Use Grep to search across files when needed

3. **Keep task files focused**:
   - One task per file
   - Don't let iterations grow too large
   - Split task if > 7-8 iterations

---

## Multi-Developer Workflows

### Git Merge Conflicts

**Problem**: Multiple developers editing same files

**With Multi-File Architecture**:
- Conflicts localized to specific task files
- DASHBOARD.md conflicts are small and obvious
- Much better than monolithic PLAN.md merge conflicts

**Best Practices**:
1. Each developer works on different tasks (different files)
2. Communicate before editing DASHBOARD.md
3. Pull frequently to stay in sync
4. Use `/flow-verify-plan` after merging

---

### Handoff Between Developers

**Scenario**: Developer A starts task, Developer B finishes it

**Process**:
1. Developer A updates DASHBOARD.md and task file with current state
2. Developer A commits and pushes
3. Developer B pulls, runs `/flow-status` to understand current state
4. Developer B reads current task file (DASHBOARD.md tells them which file)
5. Developer B continues work from current iteration

**Key**: DASHBOARD.md + task files preserve complete context for handoff.

---

## Summary of Key Rules

1. **Dashboard-First**: Always read DASHBOARD.md first
2. **Iterations-Only**: All tasks have iterations (simple tasks use single iteration)
3. **Brainstorm Complex Work**: Don't skip brainstorming for complex iterations
4. **Pre-Tasks Before Implementation**: Complete all pre-tasks before `/flow-brainstorm-complete`
5. **Review Before Complete**: Always `/flow-brainstorm-review` before `/flow-brainstorm-complete`
6. **Document Everything**: Implementation notes, discoveries, decisions
7. **Update Both Files**: Commands update both DASHBOARD.md and task files
8. **Verify Regularly**: Use `/flow-verify-plan` to catch inconsistencies
9. **Archive When Large**: Use `/flow-plan-split` to keep active plan manageable
10. **Use Backlog**: Defer scope creep to BACKLOG.md, don't delete work

---

**End of Complete Framework Documentation**

For quick reference, see lines 1-600 (Quick Reference section).
For specific sections, see Section Index (lines 543-614).

FRAMEWORK_DATA_EOF
}

get_example_dashboard() {
  cat <<'EXAMPLE_DASHBOARD_EOF'
# Payment Gateway Integration - Dashboard

**Last Updated**: 2025-01-15 16:45
**Project**: Stripe payment processing integration with webhook support
**Status**: Phase 2 in progress
**Version**: V1

---

## 📍 Current Work

- **Phase**: [Phase 2 - Core Implementation](phase-2/)
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
- **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) 🚧 IN PROGRESS
- **Focus**: Implementing comprehensive error handling with retry logic for Stripe API calls

---

## 📊 Progress Overview

### Phase 1: Foundation ✅ COMPLETE

**Goal**: Establish project structure and core data models
**Status**: 100% complete (5/5 iterations)

**Tasks**:
- ✅ **Task 1**: Project Setup (3/3 iterations)
  - ✅ Iteration 1: Repository Structure
  - ✅ Iteration 2: Dependencies & Configuration
  - ✅ Iteration 3: Development Environment
- ✅ **Task 2**: Core Models (2/2 iterations)
  - ✅ Iteration 1: Entity Design
  - ✅ Iteration 2: Validation Logic

### Phase 2: Core Implementation 🚧 IN PROGRESS

**Goal**: Build payment processing and webhook handling functionality
**Status**: 40% complete (6/15 iterations)

**Tasks**:
- ✅ **Task 1**: Database Layer (2/2 iterations)
  - ✅ Iteration 1: Repository Pattern
  - ✅ Iteration 2: Transaction Support
- ✅ **Task 2**: Business Logic (3/3 iterations)
  - ✅ Iteration 1: Payment Service Core
  - ✅ Iteration 2: State Management
  - ✅ Iteration 3: Validation Rules
- 🚧 **Task 3**: API Integration (1/4 iterations) ← **CURRENT**
  - ✅ Iteration 1: REST Client Setup
  - 🚧 Iteration 2: Error Handling ← **ACTIVE**
  - ⏳ Iteration 3: Retry Logic
  - ⏳ Iteration 4: Integration Tests
- ⏳ **Task 4**: Webhook Handler (0/3 iterations)
  - ⏳ Iteration 1: Signature Verification
  - ⏳ Iteration 2: Event Processing
  - ⏳ Iteration 3: Idempotency
- ⏳ **Task 5**: Authentication (0/3 iterations)
  - ⏳ Iteration 1: Token Management
  - ⏳ Iteration 2: Security Middleware
  - ⏳ Iteration 3: Rate Limiting

### Phase 3: Testing & Hardening ⏳ PENDING

**Goal**: Comprehensive testing and production readiness
**Status**: Not started (0/8 iterations)

**Tasks**:
- ⏳ **Task 1**: Test Suite (0/3 iterations)
  - ⏳ Iteration 1: Unit Tests
  - ⏳ Iteration 2: Integration Tests
  - ⏳ Iteration 3: E2E Tests
- ⏳ **Task 2**: Error Scenarios (0/2 iterations)
  - ⏳ Iteration 1: Edge Cases
  - ⏳ Iteration 2: Failure Recovery
- ⏳ **Task 3**: Performance Testing (0/2 iterations)
  - ⏳ Iteration 1: Load Testing
  - ⏳ Iteration 2: Optimization
- ⏳ **Task 4**: Documentation (0/1 iteration)
  - ⏳ Iteration 1: API Docs & Guides

---

## 📚 Framework Patterns Demonstrated

This example project demonstrates Flow's **Resolution Items Pattern**:

- **See**: [phase-2/task-3.md](phase-2/task-3.md) - Iteration 1 and 2
- **Pattern**: During brainstorming, each subject produces "Resolution Items"
- **Consolidation**: `/flow-brainstorming-review` consolidates all Resolution Items into single Action Items list
- **Benefit**: Prevents scattered action items, ensures brainstorming flows cleanly into implementation

---

## 💡 Key Decisions

**Decision Needed**: Should we implement circuit breaker pattern for retry logic?
- Option A: Add circuit breaker now - More resilient, but adds complexity
- Option B: Defer to V2 - Ship V1 faster, add sophistication later
- **Recommendation**: Option B - Basic retry (exponential backoff, 3 attempts) is sufficient for V1. Circuit breaker can wait.

**Resolved**:
- **2025-01-13**: Retry Strategy - Using exponential backoff with 3 retries max. Balances reliability with user experience.
- **2025-01-14**: Error Taxonomy - Mapping Stripe errors to domain errors to decouple domain logic from Stripe SDK.
- **2025-01-13**: Circuit Breaker Deferred to V2 - Adds complexity, not critical for V1 launch.
EXAMPLE_DASHBOARD_EOF
}

get_example_plan() {
  cat <<'EXAMPLE_PLAN_EOF'
# Payment Gateway Integration - Development Plan

> **📖 Framework Guide**: See [DEVELOPMENT_FRAMEWORK.md](DEVELOPMENT_FRAMEWORK.md) for complete Flow methodology
> **📍 Current Progress**: See [DASHBOARD.md](DASHBOARD.md) for real-time status tracking
> **🎯 Purpose**: Integrate Stripe payment processing with credit card support and webhook handling

**Created**: 2025-01-08
**Version**: V1
**Plan Location**: `.flow/` (managed by Flow framework)

---

## Overview

### Purpose

Build a production-ready payment gateway integration that allows our platform to accept credit card payments through Stripe. The system must handle synchronous payment processing, asynchronous webhook notifications for payment events, and provide robust error handling with retry logic for transient failures.

This integration is critical for monetization and must meet PCI compliance requirements while maintaining <2s response time for payment operations.

### Goals

**Primary Goals**:
- Process credit card payments via Stripe API with <2s response time
- Handle webhook events for async payment state notifications (payment succeeded, failed, refunded)
- Implement automatic retry logic for transient API failures (3 attempts, exponential backoff)
- Maintain 99.9% payment processing success rate (excluding card declines)
- Ensure PCI compliance through proper token handling (no raw card data stored)

**Success Criteria**:
- Payment processing works end-to-end in production
- All webhook events handled correctly with idempotency
- Error rate < 0.1% (excluding legitimate declines)
- Test coverage > 85% for payment critical paths
- Security audit passed for PCI compliance

### Scope

**V1 Scope** (Current Session):
- Credit card payment processing (charges API)
- Basic subscription support (create, cancel)
- Webhook handler for critical events: `payment_intent.succeeded`, `payment_intent.failed`, `charge.refunded`
- Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s)
- Error handling: Map Stripe errors to domain errors
- Basic authentication with API keys
- USD currency only
- Payment history storage in PostgreSQL

---

## Architecture

### System Context

The payment gateway integration follows a layered architecture with clear separation of concerns: API Layer (request handling), Service Layer (business logic), Integration Layer (Stripe API wrapper), and Data Layer (persistence).

**Components**:
- **PaymentService**: Orchestrates payment processing flow (createPayment, processPayment, refundPayment)
- **StripeClient**: Stripe API wrapper with retry logic and error mapping (singleton pattern)
- **WebhookHandler**: Processes incoming Stripe webhook events with signature verification and idempotency
- **PaymentRepository**: Payment data persistence with ACID transaction support
- **ErrorMapper**: Translates Stripe errors to domain errors for decoupling

**Key Dependencies**:
- **Stripe Node SDK** (v12.18.0): Official API client with TypeScript support
- **Existing Auth Service**: User authentication for protected endpoints
- **PostgreSQL** (v14+): Database with transaction support for payment state

**Reference Implementations**:
- **Existing PayPal Integration** (`src/legacy/billing.ts`): Webhook signature validation pattern
- **Shipment Webhook Handler** (`src/webhooks/shipment.ts`): Idempotency pattern using event IDs

---

## DO / DON'T Guidelines

**✅ DO**:
- Always validate webhook signatures before processing events (security critical)
- Use transactions for all payment state changes (data integrity)
- Map Stripe errors to domain errors immediately (decouple from provider)
- Implement idempotency for webhook event processing (handle duplicate events)
- Log all payment operations for audit trail (PCI compliance)
- Use exponential backoff for retries (avoid thundering herd)

**❌ DO NOT**:
- Store raw card numbers in database (PCI violation - use tokens only)
- Skip webhook signature verification (security risk)
- Hard-code Stripe error codes in business logic (tight coupling)
- Process duplicate webhook events (use event ID deduplication)
- Return detailed error messages to client for declined cards (security)
- Retry non-transient errors (e.g., card declined, invalid request)

---

## Notes & Learnings

**Design Decisions**:
- **2025-01-13**: Using exponential backoff with 3 retries max for API calls - balances reliability with user experience
- **2025-01-14**: Mapping Stripe errors to domain errors - decouples domain logic from Stripe SDK, enables future provider switching
- **2025-01-13**: Deferring circuit breaker pattern to V2 - basic retry is sufficient for V1, reduces complexity

**References**:
- [Stripe API Docs](https://stripe.com/docs/api): Official API reference
- [Webhook Best Practices](https://stripe.com/docs/webhooks/best-practices): Security and idempotency patterns
EXAMPLE_PLAN_EOF
}

get_example_task_standalone() {
  cat <<'EXAMPLE_TASK_STANDALONE_EOF'
# Task 1: Project Setup

**Status**: ✅ COMPLETE
**Phase**: [Phase 1 - Foundation](../DASHBOARD.md#phase-1-foundation)
**Purpose**: Set up project structure, dependencies, and development environment

---

## Task Overview

Initialize the payment gateway project with proper directory structure, install required dependencies (Stripe SDK, testing frameworks), and configure the development environment for local development.

**Why This Task**: Foundation must be solid before building payment features. Proper setup prevents technical debt and configuration issues later.

**Dependencies**: None (first task in project)

---

## Iterations

### ✅ Iteration 1: Repository Structure

**Goal**: Create src/ directory structure and initialize project configuration
**Status**: ✅ COMPLETE

---

#### Action Items

- [x] Create directory structure (src/api, src/services, src/integrations, src/repositories)
- [x] Initialize package.json with required dependencies
- [x] Install Stripe SDK (stripe@12.18.0)
- [x] Install TypeScript and configure tsconfig.json (strict mode)
- [x] Create .env.example with required environment variables
- [x] Write README.md with setup instructions

---

#### Implementation - Iteration 1: Repository Structure

**Status**: ✅ COMPLETE

**Implementation Notes**:
- Created feature-based directory structure (group by feature, not by type)
  - Pattern: src/{feature}/{api|service|repository}/
  - Rationale: Easier to navigate, better encapsulation
- Stripe SDK v12 uses ESM modules, required updating tsconfig.json moduleResolution
- Needed to add `@types/node` for TypeScript type definitions
- TypeScript strict mode enabled to catch type errors early

**Files Modified**:
- `package.json` - Dependencies and scripts
- `tsconfig.json` - TypeScript configuration with strict mode
- `.env.example` - Environment variable template
- `README.md` - Setup and development instructions
- Created `src/` directory structure

**Verification**:
- ✅ All dependencies installed successfully (no vulnerabilities)
- ✅ TypeScript compiles without errors
- ✅ Test connection to Stripe API successful (test mode)

---

### ✅ Iteration 2: Dependencies & Configuration

**Goal**: Install testing frameworks and configure database
**Status**: ✅ COMPLETE

---

#### Action Items

- [x] Install Jest and testing utilities
- [x] Configure jest.config.js
- [x] Set up database connection and migration framework
- [x] Create initial schema migration for payments table
- [x] Verify setup by running database migrations

---

#### Implementation - Iteration 2: Dependencies & Configuration

**Status**: ✅ COMPLETE

**Implementation Notes**:
- Jest for unit tests, custom simulation scripts for integration tests
  - Rationale: Jest for fast unit tests, simulation scripts for realistic E2E tests without hitting live API
- PostgreSQL connection pooling requires max 10 connections for local dev
- Database migrations run successfully on all environments (local, staging)

**Files Modified**:
- `jest.config.js` - Jest testing configuration
- `src/database/connection.ts` - PostgreSQL connection pooling
- `migrations/001_create_payments_table.sql` - Initial schema

**Verification**:
- ✅ Database migrations run successfully
- ✅ Jest test runner configured and working
- ✅ All team members able to set up locally

---

### ✅ Iteration 3: Development Environment

**Goal**: Finalize local development setup and validate end-to-end
**Status**: ✅ COMPLETE

---

#### Action Items

- [x] Create npm scripts for development workflow (dev, build, test, migrate)
- [x] Set up hot-reload for local development
- [x] Add linting and formatting (ESLint, Prettier)
- [x] Validate entire setup with smoke test
- [x] Document common development tasks in README

---

#### Implementation - Iteration 3: Development Environment

**Status**: ✅ COMPLETE

**Implementation Notes**:
- Added npm scripts: `npm run dev`, `npm run build`, `npm test`, `npm run migrate`
- Hot-reload working with nodemon for fast iteration
- ESLint + Prettier configured with team coding standards
- Smoke test validates Stripe connection, database connection, and TypeScript compilation

**Files Modified**:
- `package.json` - Added development scripts
- `.eslintrc.js` - ESLint configuration
- `.prettierrc` - Prettier configuration
- `scripts/smoke-test.ts` - Smoke test for local setup validation
- `README.md` - Updated with development workflow instructions

**Verification**:
- ✅ `npm run dev` starts server with hot-reload
- ✅ `npm test` runs all tests successfully
- ✅ `npm run migrate` applies database migrations
- ✅ Smoke test passes (Stripe + DB + TypeScript all working)
- ✅ All team members successfully completed setup

---

## Task Notes

**Key Decisions**:
- Feature-based directory structure chosen over layer-based structure for better encapsulation
- TypeScript strict mode enabled despite slight learning curve - better type safety worth it
- Jest + simulation scripts hybrid approach for testing - fast unit tests + realistic integration tests

**References**:
- [Stripe Node SDK](https://github.com/stripe/stripe-node): Official SDK documentation
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html): Configuration guide
EXAMPLE_TASK_STANDALONE_EOF
}

get_example_task_iterations() {
  cat <<'EXAMPLE_TASK_ITERATIONS_EOF'
# Task 3: API Integration

**Status**: 🚧 IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API for payment processing

---

## Task Overview

Build a robust Stripe API client with error handling, retry logic for transient failures, and comprehensive integration tests. This is the core integration layer that all payment operations depend on.

**Why This Task**: Payment processing requires reliable communication with Stripe API. Without proper error handling and retry logic, transient network issues or API hiccups would cause payment failures and poor user experience.

**Dependencies**:
- **Requires**: Task 1 (Database Layer) - need PaymentRepository for state persistence
- **Requires**: Task 2 (Business Logic) - need PaymentService interface definitions
- **Blocks**: Task 4 (Webhook Handler) - webhook processing depends on API client
- **Blocks**: Task 5 (Authentication) - auth tokens stored via API calls

**Estimated Complexity**: High (4 iterations expected)

**Risk Level**: High - Core payment functionality depends on this

---

## Iterations

### ✅ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper with authentication and configuration

**Status**: ✅ COMPLETE (2025-01-12)

---

#### Brainstorming Session - REST Client Architecture

**Focus**: Design API client abstraction layer and authentication flow

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ✅ Subject 1: Client Architecture Pattern

**Decision**: Use singleton pattern with lazy initialization

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe SDK maintains connection pool internally
- Multiple client instances would create redundant connections and waste resources
- Lazy initialization delays credential validation until first use (fast app startup)
- Singleton ensures consistent configuration across the application

**Resolution Items**:
- Create `StripeClient` singleton class in src/integrations/stripe/
- Implement lazy initialization in constructor (init on first API call)
- Add credential validation on first API call (fail fast if misconfigured)
- Export singleton instance for import across codebase

---

##### ✅ Subject 2: Authentication Flow

**Decision**: Use API key from environment variable with startup validation

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe best practices recommend environment-based configuration
- Supports different keys per environment (dev/staging/prod)
- Validation at startup prevents runtime errors from missing/invalid keys
- Fails fast with clear error message if key is missing or malformed

**Resolution Items**:
- Load `STRIPE_API_KEY` from environment variables
- Validate key format at startup (must start with `sk_test_` or `sk_live_`)
- Throw descriptive error if key is missing or invalid
- Log masked key on startup for debugging (sk_***...last4chars)

---

##### ✅ Subject 3: API Timeout Configuration

**Decision**: Set 30-second timeout for API calls, configurable via environment

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe recommends 30s timeout for payment operations
- Prevents indefinite hanging on network issues
- Configurable via environment for different deployment scenarios
- Balance between reliability (long enough for legit slow requests) and responsiveness (not too long)

**Resolution Items**:
- Configure default timeout of 30 seconds
- Make timeout configurable via `STRIPE_API_TIMEOUT_MS` env var
- Add timeout handling in API call wrapper
- Log timeout events for monitoring

---

#### Action Items

<!--
  FRAMEWORK PATTERN: Resolution Items → Action Items Flow

  Notice how this Action Items list is a CONSOLIDATION of all Resolution Items from
  the 3 resolved subjects above. This is the core pattern:

  1. During brainstorming: Each subject produces "Resolution Items"
  2. When done brainstorming: Run /flow-brainstorming-review
  3. AI consolidates all Resolution Items into single Action Items list here
  4. During implementation: Work from this consolidated list (NOT from individual subjects)

  This prevents scattered action items and ensures all brainstorming decisions flow
  into implementation in a structured way.
-->

(Consolidated from Resolution Items above by `/flow-brainstorming-review`)

- [x] Create `StripeClient` singleton class in src/integrations/stripe/
- [x] Implement lazy initialization in constructor (init on first API call)
- [x] Add credential validation on first API call (fail fast if misconfigured)
- [x] Export singleton instance for import across codebase
- [x] Load `STRIPE_API_KEY` from environment variables
- [x] Validate key format at startup (must start with `sk_test_` or `sk_live_`)
- [x] Throw descriptive error if key is missing or invalid
- [x] Log masked key on startup for debugging (sk_***...last4chars)
- [x] Configure default timeout of 30 seconds
- [x] Make timeout configurable via `STRIPE_API_TIMEOUT_MS` env var
- [x] Add timeout handling in API call wrapper
- [x] Log timeout events for monitoring

---

#### Implementation - Iteration 1: REST Client Setup

**Status**: ✅ COMPLETE (2025-01-12)

**Implementation Notes**:
- Created `src/integrations/stripe/StripeClient.ts` with singleton pattern
- Implemented lazy initialization - Stripe SDK initialized on first `getInstance()` call
- Added comprehensive key validation (format check + test API call)
- Discovered: Stripe SDK v12 changed API - using `paymentIntents` instead of deprecated `charges`
- Added utility method `maskApiKey()` for safe logging
- Performance: Singleton initialization takes ~50ms (acceptable for lazy init)

**Files Modified**:
- `src/integrations/stripe/StripeClient.ts` - Created new file (187 lines)
- `src/config/env.ts` - Added STRIPE_API_KEY and STRIPE_API_TIMEOUT_MS validation
- `src/integrations/stripe/index.ts` - Barrel export for clean imports
- `scripts/stripe-client.scripts.ts` - Created test file with connection verification

**Verification**:
- ✅ All tests passing in stripe-client.scripts.ts
- ✅ API key validation working correctly (rejects invalid keys)
- ✅ Singleton pattern verified (same instance returned on multiple calls)
- ✅ Timeout configuration working (tested with slow network simulation)
- ✅ Connection to Stripe test API successful
- ✅ Code review completed by team

**Bugs Discovered**:
None in current scope, but found issue in existing ErrorHandler (see Pre-Implementation Tasks in Iteration 2)

---

### 🚧 Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling and error taxonomy mapping

**Status**: 🚧 IN PROGRESS (Implementing)

---

#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

---

##### ✅ Pre-Task 1: Refactor Legacy ErrorHandler

**Completed**: 2025-01-14

**Why Blocking**: Current ErrorHandler class doesn't support async retry logic needed for Stripe API calls

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async error handlers
- Add `retryAsync()` method
- Update 3 existing call sites to use new async pattern

**Files**:
- `src/utils/ErrorHandler.ts` - Add async support
- `src/services/BillingService.ts` - Update to use retryAsync()
- `src/services/PaymentService.ts` - Update to use retryAsync()
- `tests/utils/ErrorHandler.test.ts` - Add async tests

**Test**: Run existing test suite to ensure no regressions

**Changes Made**:
- Added `retryAsync<T>(fn: () => Promise<T>, options)` method to ErrorHandler
- Updated ErrorHandler to handle Promise-based operations
- Migrated BillingService and PaymentService to use retryAsync()
- All existing tests pass + 5 new async tests added
- No breaking changes to existing sync error handling

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design error taxonomy, retry logic, and error recovery patterns

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ✅ Subject 1: Error Taxonomy

**Decision**: Map Stripe errors to domain-specific error types using ErrorMapper class

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Decouples domain logic from Stripe SDK (enables future provider switching)
- Provides consistent error handling across application
- Enables easier testing with mocked errors
- Business logic doesn't need to know about Stripe-specific error codes

**Error Categories**:
- `PaymentDeclinedError` - Card declined (insufficient funds, incorrect details, etc.)
- `PaymentAuthenticationError` - 3D Secure or authentication required
- `PaymentProcessingError` - Stripe API or network error (retryable)
- `PaymentConfigurationError` - API key or configuration issue (not retryable)
- `PaymentValidationError` - Invalid request parameters (not retryable)

**Resolution Items**:
- Create `ErrorMapper` class in src/integrations/stripe/
- Define domain error types in src/errors/
- Map all Stripe error codes to domain errors
- Add tests for error mapping (all Stripe error codes covered)

---

##### ✅ Subject 2: Retry Strategy

**Decision**: Implement exponential backoff with 3 retries for transient errors only

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Exponential backoff prevents overwhelming Stripe API during issues
- 3 retries balances reliability (handle transient failures) with user experience (don't wait too long)
- Retry delays: 1s, 2s, 4s (total 7s max additional wait)
- Only retry transient errors (network issues, 5xx responses), not permanent errors (4xx client errors)

**Retry Decision Logic**:
- Retry: Network timeout, Stripe 500/502/503/504, rate limit (429)
- Don't retry: Card declined (402), invalid request (400), authentication errors (401)

**Resolution Items**:
- Create `RetryPolicy` class with exponential backoff algorithm
- Implement retry logic in StripeClient wrapper
- Add configuration for max retries (default 3, configurable via env)
- Add configuration for base delay (default 1000ms, configurable via env)
- Log retry attempts with attempt number and delay
- Add tests for retry scenarios (success after N retries, exhausted retries)

---

##### ✅ Subject 3: Error Logging

**Decision**: Log all errors with structured logging including request context and retry attempts

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Structured logs enable better monitoring and debugging
- Request context (payment ID, user ID, amount) helps trace issues
- Retry attempt numbers help understand system behavior under failures
- Sensitive data (API keys, card numbers) must be redacted

**Log Format**:
```typescript
{
  level: 'error',
  message: 'Stripe API call failed',
  paymentId: 'pay_123',
  userId: 'user_456',
  stripeErrorCode: 'card_declined',
  retryAttempt: 2,
  timestamp: '2025-01-15T14:30:00Z'
}
```

**Resolution Items**:
- Add structured logging to StripeClient
- Log all API errors with full context
- Redact sensitive data before logging
- Add retry attempt number to logs
- Integrate with existing logging infrastructure

---

##### ✅ Subject 4: Circuit Breaker Pattern

**Decision**: Skip circuit breaker for V1, defer to V2

**Resolution Type**: B (Documentation)

**Rationale**:
- Circuit breaker adds complexity (state management, monitoring, configuration)
- Stripe API has robust rate limiting and rarely has prolonged outages
- Our expected V1 volume (<100 requests/min) is low risk for cascade failures
- Retry logic with exponential backoff provides sufficient resilience for V1
- Can add circuit breaker in V2 when we have production metrics to tune thresholds

**Documentation Update**:
Added circuit breaker to PLAN.md V2 scope with reasoning and implementation notes

---

#### Action Items

<!-- See comment in Iteration 1 for explanation of Resolution Items → Action Items flow -->

(Consolidated from Resolution Items above by `/flow-brainstorming-review`)

- [x] Create `ErrorMapper` class in src/integrations/stripe/
- [x] Define domain error types in src/errors/
- [x] Map all Stripe error codes to domain errors
- [x] Add tests for error mapping (all Stripe error codes covered)
- [x] Create `RetryPolicy` class with exponential backoff algorithm
- [x] Implement retry logic in StripeClient wrapper
- [x] Add configuration for max retries (default 3, configurable via env)
- [x] Add configuration for base delay (default 1000ms, configurable via env)
- [x] Log retry attempts with attempt number and delay
- [x] Add tests for retry scenarios (success after N retries, exhausted retries)
- [x] Add structured logging to StripeClient
- [x] Log all API errors with full context
- [x] Redact sensitive data before logging
- [x] Add retry attempt number to logs
- [x] Integrate with existing logging infrastructure

---

#### Implementation - Iteration 2: Error Handling

**Status**: 🚧 IN PROGRESS (2025-01-15)

**Implementation Notes**:
- Created `src/integrations/stripe/ErrorMapper.ts` (98 lines)
  - Comprehensive mapping of all Stripe error codes
  - Includes error code reference documentation
- Created `src/integrations/stripe/RetryPolicy.ts` (76 lines)
  - Exponential backoff algorithm implementation
  - Configurable via STRIPE_MAX_RETRIES and STRIPE_RETRY_BASE_DELAY_MS env vars
- Updated `src/integrations/stripe/StripeClient.ts` to use ErrorMapper and RetryPolicy
  - All API calls wrapped with retry logic
  - Errors mapped before thrown to service layer
- Created `src/errors/payment/` directory with domain error classes
  - PaymentDeclinedError
  - PaymentProcessingError
  - PaymentConfigurationError
  - PaymentValidationError
  - PaymentAuthenticationError
- Added structured logging to all error paths
  - Using existing logger with additional context fields
  - Sensitive data redaction working correctly
- Discovered: Stripe SDK throws different error types for network vs API errors, needed special handling

**Files Modified**:
- `src/integrations/stripe/StripeClient.ts` - Added error handling and retry (220 lines now, +33)
- `src/integrations/stripe/ErrorMapper.ts` - Created (98 lines)
- `src/integrations/stripe/RetryPolicy.ts` - Created (76 lines)
- `src/errors/payment/PaymentDeclinedError.ts` - Created (18 lines)
- `src/errors/payment/PaymentProcessingError.ts` - Created (18 lines)
- `src/errors/payment/PaymentConfigurationError.ts` - Created (18 lines)
- `src/errors/payment/PaymentValidationError.ts` - Created (18 lines)
- `src/errors/payment/PaymentAuthenticationError.ts` - Created (18 lines)
- `src/errors/payment/index.ts` - Barrel export (8 lines)
- `scripts/error-handling.scripts.ts` - Created test file (156 lines)
  - Tests all error mapping scenarios
  - Tests retry logic with simulated failures
  - Tests exhausted retry scenarios

**Verification** (In Progress):
- ✅ Error mapping tests passing (all Stripe error codes covered)
- ✅ Retry logic tests passing (success after retries, exhausted retries)
- ✅ Exponential backoff working correctly (measured actual delays)
- ✅ Structured logging working (verified log format)
- ✅ Sensitive data redaction working
- [ ] Integration test with real Stripe test API (in progress)
- [ ] Team code review (scheduled for 2025-01-16)

**Next Steps**:
1. Complete integration test with Stripe test API
2. Get code review approval
3. Mark iteration complete
4. Move to Iteration 3

---

### ⏳ Iteration 3: Advanced Retry Logic

**Goal**: Add jitter to exponential backoff and implement retry budget pattern

**Status**: ⏳ PENDING

**Note**: This iteration will be planned after Iteration 2 is complete. Initial thoughts:
- Add jitter to prevent thundering herd problem
- Implement retry budget to prevent excessive retries across all requests
- May defer some advanced features to V2 based on Iteration 2 outcomes

---

### ⏳ Iteration 4: Integration Tests

**Goal**: Comprehensive test coverage with Stripe API simulation

**Status**: ⏳ PENDING

**Note**: This iteration focuses on end-to-end integration testing:
- Simulate all Stripe API responses (success, errors, timeouts)
- Test retry logic with controlled network conditions
- Verify error mapping for all error codes
- Performance testing (measure API call latency with retries)

---

## Task Notes

**Discoveries**:
- Stripe SDK already implements connection pooling internally (no need for custom pool)
- Stripe SDK v12 uses `paymentIntents` API instead of deprecated `charges` API
- Error codes changed in Stripe API v2023-10-16 (updated error taxonomy accordingly)
- Stripe webhooks can deliver out of order (must handle idempotently in Task 4)
- Network timeouts throw different error type than API errors (needed special handling)

**Decisions**:
- Using Stripe Node SDK v12.18.0 (latest stable)
- NOT implementing custom connection pool (Stripe SDK handles it better)
- NOT implementing circuit breaker for V1 (defer to V2)
- Using exponential backoff over fixed delay (more efficient)
- Retry 3 times max (balance between reliability and user experience)

**Performance**:
- Stripe API calls average 200-300ms response time
- With 3 retries and exponential backoff, worst case is ~7s additional wait
- Total max time for payment call: 30s timeout + 7s retry delay = 37s (acceptable)
- Singleton initialization overhead: ~50ms (one-time cost)

**References**:
- Stripe API Docs: https://stripe.com/docs/api
- Stripe Error Codes: https://stripe.com/docs/error-codes
- Stripe Best Practices: https://stripe.com/docs/api/errors/handling
- Existing PayPal integration: `src/legacy/billing.ts` (learned webhook validation pattern)
- Similar retry logic: `src/utils/HttpClient.ts` (reused exponential backoff algorithm)

**Team Feedback**:
- Code review from @alice (2025-01-12): Suggested adding timeout configuration - added ✅
- Code review from @bob (2025-01-14): Requested more comprehensive error tests - added ✅
- Architecture review (2025-01-13): Approved singleton pattern and retry strategy ✅
EXAMPLE_TASK_ITERATIONS_EOF
}

deploy_commands() {
  local target_dir="$1"
  local force="$2"
  local success_count=0

  # If force mode, clean up deprecated commands first
  if [ "$force" = true ]; then
    echo -e "${CYAN}🧹 Cleaning deprecated commands...${NC}"
    for deprecated_cmd in "${DEPRECATED_COMMANDS[@]}"; do
      local deprecated_file="$target_dir/${deprecated_cmd}.md"
      if [ -f "$deprecated_file" ]; then
        rm -f "$deprecated_file"
        echo -e "${YELLOW}🗑️  Removed deprecated: ${deprecated_cmd}.md${NC}"
      fi
    done
    echo ""
  fi

  for cmd in "${COMMANDS[@]}"; do
    local cmd_file="$target_dir/${cmd}.md"

    # If force mode, delete existing file first to ensure clean write
    if [ "$force" = true ] && [ -f "$cmd_file" ]; then
      rm -f "$cmd_file"
    fi

    [ -f "$cmd_file" ] && [ "$force" = false ] && { echo -e "${YELLOW}⏭️  Skip ${cmd}.md${NC}"; continue; }

    local content=$(extract_command "$cmd")
    [ -z "$content" ] && { echo -e "${RED}❌ Failed ${cmd}${NC}"; continue; }

    echo "$content" > "$cmd_file" && { echo -e "${GREEN}✅ ${cmd}.md${NC}"; ((success_count++)); } || echo -e "${RED}❌ ${cmd}.md${NC}"
  done

  echo "$success_count"
}

deploy_framework() {
  local target_dir="$1"
  local force="$2"
  local framework_dir="$target_dir/framework"
  local framework_file="$framework_dir/DEVELOPMENT_FRAMEWORK.md"
  local examples_dir="$framework_dir/examples"

  # Create framework directory
  mkdir -p "$framework_dir" || { echo -e "${RED}❌ mkdir framework/${NC}"; return 1; }

  # If force mode, delete existing files first to ensure clean write
  if [ "$force" = true ]; then
    [ -f "$framework_file" ] && rm -f "$framework_file"
    [ -d "$examples_dir" ] && rm -rf "$examples_dir"
  fi

  # Deploy framework guide
  if [ -f "$framework_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip framework/DEVELOPMENT_FRAMEWORK.md${NC}"
  else
    get_framework_content > "$framework_file" && echo -e "${GREEN}✅ framework/DEVELOPMENT_FRAMEWORK.md${NC}" || { echo -e "${RED}❌ Framework${NC}"; return 1; }
  fi

  # Deploy examples
  if [ -d "$examples_dir" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}⏭️  Skip framework/examples/${NC}"
  else
    # Create examples directory structure
    mkdir -p "$examples_dir/phase-1" || { echo -e "${RED}❌ framework/examples/phase-1${NC}"; return 1; }
    mkdir -p "$examples_dir/phase-2" || { echo -e "${RED}❌ framework/examples/phase-2${NC}"; return 1; }

    # Deploy example files
    get_example_dashboard > "$examples_dir/DASHBOARD.md" && echo -e "${GREEN}✅ framework/examples/DASHBOARD.md${NC}" || { echo -e "${RED}❌ framework/examples/DASHBOARD.md${NC}"; return 1; }
    get_example_plan > "$examples_dir/PLAN.md" && echo -e "${GREEN}✅ framework/examples/PLAN.md${NC}" || { echo -e "${RED}❌ framework/examples/PLAN.md${NC}"; return 1; }
    get_example_task_standalone > "$examples_dir/phase-1/task-1.md" && echo -e "${GREEN}✅ framework/examples/phase-1/task-1.md${NC}" || { echo -e "${RED}❌ framework/examples/phase-1/task-1.md${NC}"; return 1; }
    get_example_task_iterations > "$examples_dir/phase-2/task-3.md" && echo -e "${GREEN}✅ framework/examples/phase-2/task-3.md${NC}" || { echo -e "${RED}❌ framework/examples/phase-2/task-3.md${NC}"; return 1; }
  fi

  return 0
}

validate() {
  local commands_dir="$1"
  local flow_dir="$2"
  local valid=true

  echo -e "\n${CYAN}🔍 Validating...${NC}\n"

  # Check framework
  [ ! -f "$flow_dir/framework/DEVELOPMENT_FRAMEWORK.md" ] && { echo -e "${RED}❌ Framework missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Framework${NC}"

  # Check examples
  [ ! -d "$flow_dir/framework/examples" ] && { echo -e "${RED}❌ Examples missing${NC}"; valid=false; } || echo -e "${GREEN}✅ Examples (4 files)${NC}"

  # Check commands
  local count=0
  for cmd in "${COMMANDS[@]}"; do
    [ -f "$commands_dir/${cmd}.md" ] && ((count++))
  done

  echo -e "${GREEN}✅ Commands: $count/${#COMMANDS[@]}${NC}"
  [ "$count" -eq 0 ] && { echo -e "${RED}❌ No commands${NC}"; valid=false; }

  [ "$valid" = true ]
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) FORCE=true; shift;;
      --version|-v) print_version; exit 0;;
      --help|-h) print_help; exit 0;;
      *) echo -e "${RED}Unknown: $1${NC}"; print_help; exit 1;;
    esac
  done

  echo -e "\n${BLUE}🚀 Flow Framework v$FLOW_VERSION${NC}\n"
  echo -e "Target Project: ${BLUE}$(pwd)${NC}"
  echo -e "Force: $([ "$FORCE" = true ] && echo "${GREEN}Yes${NC}" || echo "${RED}No${NC}")"
  echo -e "Mode: ${CYAN}Self-contained${NC}\n"

  local commands_dir="$(pwd)/.claude/commands"
  local flow_dir="$(pwd)/.flow"

  # Create directories
  mkdir -p "$commands_dir" || { echo -e "${RED}❌ mkdir .claude/commands failed${NC}"; exit 1; }
  mkdir -p "$flow_dir" || { echo -e "${RED}❌ mkdir .flow failed${NC}"; exit 1; }
  echo -e "${BLUE}📁 Created directories${NC}\n"

  # Deploy slash commands
  echo -e "${BLUE}📦 Installing slash commands...${NC}\n"
  local count=$(deploy_commands "$commands_dir" "$FORCE")

  # Deploy framework docs
  echo -e "\n${BLUE}📚 Installing framework documentation...${NC}\n"
  deploy_framework "$flow_dir" "$FORCE"

  # Validate
  if validate "$commands_dir" "$flow_dir"; then
    echo ""
    echo "=================================================="
    echo -e "${GREEN}✅ Flow Framework Installed!${NC}\n"
    echo -e "${CYAN}📂 Structure:${NC}"
    echo "   .claude/commands/       (${#COMMANDS[@]} slash commands)"
    echo "   .flow/                  (your workspace)"
    echo "     └── framework/        (AI reference files)"
    echo "         ├── DEVELOPMENT_FRAMEWORK.md"
    echo "         └── examples/"
    echo "             ├── DASHBOARD.md"
    echo "             ├── PLAN.md"
    echo "             ├── phase-1/task-1.md"
    echo "             └── phase-2/task-3.md"
    echo ""
    echo -e "${CYAN}🚀 Next Steps:${NC}"
    echo "   1. Restart Claude Code (if running)"
    echo "   2. Run: /flow-blueprint <your-feature-name>"
    echo "   3. Read: .flow/framework/DEVELOPMENT_FRAMEWORK.md"
    echo "   4. Examples: .flow/framework/examples/"
    echo ""
    echo "💡 Share this script - it's self-contained!"
    echo "=================================================="
    echo ""
    exit 0
  else
    echo ""
    echo -e "${YELLOW}⚠️  Deployment completed with warnings${NC}"
    echo ""
    exit 1
  fi
}

main "$@"
