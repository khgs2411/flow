#!/usr/bin/env bash

################################################################################
# Flow Framework Deployment Script
#
# Self-contained script with all framework content embedded.
# Distribute this single file to install the Flow framework.
#
# Version: 1.3.5
# Generated by build-standalone.sh
################################################################################

set -e

FLOW_VERSION="1.3.5"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
NC='\033[0m'

COMMANDS=(
  # Plan Initialization (4 commands)
  "flow-blueprint" "flow-migrate" "flow-plan-update" "flow-plan-split"
  # Phase Lifecycle (3 commands)
  "flow-phase-add" "flow-phase-start" "flow-phase-complete"
  # Task Lifecycle (3 commands)
  "flow-task-add" "flow-task-start" "flow-task-complete"
  # Iteration Lifecycle (6 commands: add, start, subject, review, complete, implement-start, implement-complete = 7 total)
  "flow-iteration-add"
  "flow-brainstorm-start" "flow-brainstorm-subject" "flow-brainstorm-review" "flow-brainstorm-complete"
  "flow-implement-start" "flow-implement-complete"
  # Navigation (3 commands)
  "flow-next" "flow-next-subject" "flow-next-iteration"
  # Status & Validation (5 commands)
  "flow-status" "flow-summarize" "flow-verify-plan" "flow-compact" "flow-rollback"
  # Backlog Management (3 commands)
  "flow-backlog-add" "flow-backlog-view" "flow-backlog-pull"
)

# Deprecated commands (renamed/removed in v1.0.11+) - cleaned up during --force
DEPRECATED_COMMANDS=(
  "flow-phase" "flow-task" "flow-iteration"
  "flow-brainstorm_start" "flow-brainstorm_subject" "flow-brainstorm_resolve" "flow-brainstorm_complete"
  "flow-implement_start" "flow-implement_complete"
  "flow-update-plan-version"
  "flow-brainstorm-resolve"  # Removed in v1.0.12 - redundant command
)

FORCE=false

print_help() {
  cat <<EOF

Flow Framework Deployment Script v$FLOW_VERSION

USAGE:
  ./flow.sh [OPTIONS]

OPTIONS:
  --force, -f       Overwrite existing files
  --version, -v     Show version information
  --help, -h        Show this help

DEPLOYMENT STRUCTURE:
  .claude/commands/          Slash commands (\${#COMMANDS[@]} files)
  .claude/skills/            Agent Skills (6 Skills with supporting files)
  .flow/framework/           AI reference files (read-only for user)
    ‚îú‚îÄ‚îÄ DEVELOPMENT_FRAMEWORK.md
    ‚îú‚îÄ‚îÄ skills/SKILLS_GUIDE.md
    ‚îî‚îÄ‚îÄ examples/

This script is SELF-CONTAINED - no external files needed!

EOF
}

print_version() {
  cat <<EOF
Flow Framework v$FLOW_VERSION

A spec-driven iterative development methodology combining
Domain-Driven Design principles with Agile philosophy.

Created by: Liad Goren
Repository: https://github.com/khgs2411/flow
License: Open for personal and commercial use

EOF
}

extract_command() {
  local cmd="$1"
  local marker="## /${cmd}$"
  awk -v marker="$marker" '
    $0 ~ marker {found=1; next}
    found && /<!-- COMMAND_START -->/ {inside=1; next}
    found && inside && /<!-- COMMAND_END -->/ {exit}
    found && inside {print}
  ' <<'COMMANDS_DATA_EOF'
# Flow Framework - Slash Commands File.

This file contains all slash command definitions for the Flow framework. Copy these to `.claude/commands/` when ready to use.

---

## Command Guidelines

**IMPORTANT**: Every command must:

1. **Read the framework guide** at the start to understand patterns and structure
2. **Find and parse .flow/PLAN.md** to understand current state
3. **Follow framework patterns exactly** (status markers, section structure, etc.)
4. **Update .flow/PLAN.md** according to framework conventions
5. **Provide clear next steps** to the user

**File Locations**:

- **Plan File**: `.flow/PLAN.md` (Flow manages the plan from this directory)
- **Framework Guide**: Search in order:
  1. `.flow/framework/DEVELOPMENT_FRAMEWORK.md` (primary - in user's project)
  2. `.claude/DEVELOPMENT_FRAMEWORK.md` (project root)
  3. `./DEVELOPMENT_FRAMEWORK.md` (project root)
  4. `~/.claude/flow/DEVELOPMENT_FRAMEWORK.md` (global)
- **Examples**: `.flow/framework/examples/` (reference files for AI to learn from)

**Finding PLAN.md** (all commands except `/flow-blueprint` and `/flow-migrate`):

- Primary location: `.flow/PLAN.md`
- If not found, search project root and traverse up
- If still not found: Suggest `/flow-blueprint` (new project) or `/flow-migrate` (existing docs)

**Status Markers** (use consistently):

- ‚úÖ Complete
- ‚è≥ Pending
- üöß In Progress
- üé® Ready for Implementation
- ‚ùå Cancelled
- üîÆ Deferred

**Tool Usage for Pattern Matching**:

When commands instruct you to "Find", "Look for", or "Locate" patterns in PLAN.md:

- **Use Grep tool** for:

  - Simple pattern existence checks (does pattern exist?)
  - Counting occurrences (`grep -c`)
  - Reading specific sections with context (`grep -A`, `-B`, `-C`)
  - Examples: Finding phase markers, checking status, locating sections

- **Use awk** ONLY for:

  - Extracting content between two patterns (range extraction)
  - Example: `awk '/start_pattern/,/end_pattern/ {print}'`

- **Prefer Grep over awk** for simple tasks - it's more efficient and clearer

**Examples**:

```bash
# ‚úÖ GOOD - Use Grep for pattern checking
grep "^### Phase 4:" PLAN.md
grep -c "^#### ‚è≥ Task" PLAN.md
grep -A 2 "^## üìã Progress Dashboard" PLAN.md

# ‚úÖ GOOD - Use awk for range extraction
awk '/^##### Iteration 5:/,/^#####[^#]|^####[^#]/ {print}' PLAN.md
awk '/\*\*Subjects to Discuss\*\*:/,/\*\*Resolved Subjects\*\*:/ {print}' PLAN.md

# ‚ùå BAD - Don't use awk for simple existence checks
awk '/^### Phase 4:/ {print}' PLAN.md  # Use grep instead
```

---

## /flow-blueprint

**File**: `flow-blueprint.md`

```markdown
<!-- COMMAND_START -->
---
description: Create new multi-file Flow project structure from scratch
---

You are executing the `/flow-blueprint` command from the Flow framework.

**Purpose**: Create a brand new multi-file Flow project structure from scratch.

**üî¥ REQUIRED: Read Framework Quick Reference & Templates First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-600 (Quick Reference section) - if not already in context
- **Read file templates**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2101-2600 (DASHBOARD.md, PLAN.md, task-N.md templates)
- **Read examples**: `.flow/framework/examples/` directory for real-world examples

**Multi-File Architecture**: This command creates:
- `DASHBOARD.md` - Progress tracking (single source of truth, user's main workspace)
- `PLAN.md` - Static context (overview, architecture, scope)
- `phase-N/` directories (if enough info provided)
- `phase-N/task-M.md` files (if enough info provided)

**IMPORTANT**: This command ALWAYS creates fresh files, overwriting any existing. Use `/flow-migrate` to convert existing docs or `/flow-plan-update` to migrate old single-file plans.

**üí° TIP FOR USERS**: Provide rich context! The more details you provide upfront, the better the plan.

**Good example** (explicit tasks = creates phase directories + task files):
```
/flow-blueprint "WebSocket Chat App

1. Create Bun.js web server with Express
2. Implement Socket.IO for real-time messaging  
3. Build frontend app to communicate with WebSocket server

Testing: Simulation-based per service"
```

**Minimal example** (AI will ask follow-up questions, may only create DASHBOARD + PLAN):
```
/flow-blueprint "websocket server"
```

**Instructions**:

1. **INPUT VALIDATION** (Run BEFORE reading framework):

   **Step 1: Quick Scan**:
   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "‚ùå Missing project description. Provide at least a project name or brief description."
     STOP
   ```

   **Step 2: Detect Blueprint Mode**:

   **Mode A: SUGGEST Structure** (User wants AI to design)
   - Trigger: NO explicit structure markers in $ARGUMENTS
   - Examples: "websocket server", "user auth system"
   - Behavior: Ask questions, generate suggested structure

   **Mode B: CREATE Explicit Structure** (User designed it)
   - Trigger: Contains numbered lists, "Phase N:", "Task N:", or bullet structure
   - Examples: 
     - "1. server, 2. socket.io, 3. frontend"  
     - "Phase 1: Foundation\n- Task 1: Setup\nPhase 2: Implementation"
   - Behavior: Honor user's structure exactly (with [TBD] for missing metadata)

   **Step 3: Semantic Check** (Mode A only):
   - If too vague ("help", "project", "thing"):
     ```
     "ü§î Need more context. What are you building? Examples:
     - 'WebSocket chat server with Socket.IO'
     - 'User authentication system with JWT'
     
     Or provide explicit structure:
     1. [First step]
     2. [Second step]
     3. [Third step]"
     ```

   **Step 4: Dry-Run Preview** (Mode B only):
   - Parse structure and show what will be created:
     ```
     "üìã Detected explicit structure. I will create:
     
     Phase 1: Bun.js Web Server ‚è≥
       - phase-1/task-1.md (Create Express server)
     
     Phase 2: Socket.IO Implementation ‚è≥  
       - phase-2/task-1.md (Implement real-time messaging)
     
     Phase 3: Frontend App ‚è≥
       - phase-3/task-1.md (Build WebSocket client)
     
     Also creating: DASHBOARD.md, PLAN.md
     
     Proceed? (yes/no)"
     ```

2. **Read framework guide AND examples** (after validation):
   - Search for .flow/framework/DEVELOPMENT_FRAMEWORK.md (`.flow/`, `.claude/`, `./`, `~/.claude/flow/`)
   - Search for examples in `.flow/framework/examples/` (DASHBOARD.md, PLAN.md, task files)
   - Read to understand:
     - Multi-file structure (DASHBOARD vs PLAN vs task files)
     - File templates
     - Required sections
     - Status markers

3. **Analyze feature request** (Mode-specific):

   **If Mode A (SUGGEST)**:
   - Extract: requirements, constraints, references, testing
   - If minimal context, prepare to ask questions

   **If Mode B (CREATE)**:
   - Parse structure (phases/tasks from numbered lists or explicit markers)
   - Extract metadata if provided
   - Use [TBD] for missing metadata

4. **Gather information** (Mode A only):

   a. **Reference implementations**:
      - If mentioned in args, read and analyze
      - Otherwise ask: "Reference implementation to analyze? (path or 'no')"

   b. **Testing methodology**:
      - If provided in args, use directly
      - Otherwise ask:
        ```
        "How do you prefer to verify implementations?
        - Simulation-based (per-service): scripts/{service}.scripts.ts
        - Unit tests: Jest/Vitest after implementation
        - TDD: Tests before implementation
        - Manual QA: No automated tests
        - Custom: Describe your approach
        
        Also tell me:
        - Test file naming? (e.g., {service}.scripts.ts, {feature}.test.ts)
        - Test file location? (e.g., scripts/, __tests__/, tests/)
        - When to create NEW vs add to existing?"
        ```

   c. **Estimate phase/task structure** (Mode A only):
      - Based on requirements, estimate phases needed
      - Ask: "I'm thinking X phases: [list]. Does this structure make sense? Any changes?"

   d. **Ask about Key Decisions** (IMPORTANT - human-in-loop):
      - If you identify design decisions during structure creation, **ASK USER IMMEDIATELY**:
        ```
        "I identified a decision point: [question]"
        "- Option A: [description]"
        "- Option B: [description]"
        "Your choice? (or say 'decide later' to add to Key Decisions section)"
        ```
      - **If user chooses**: Document choice in PLAN.md Architecture section or relevant file
      - **If user says "decide later"**: Add to DASHBOARD.md Key Decisions section as unresolved
      - **DO NOT** create unresolved Key Decisions without asking user first
      - Examples of decisions to ask about:
        - Version numbering (v1.X.0 vs v2.0.0)
        - Architecture patterns (REST vs GraphQL, SQL vs NoSQL)
        - Testing approach (if not already gathered in step 4b)
        - Deployment strategy (if relevant to project)

5. **Determine what files to create**:

   **ALWAYS CREATE**:
   - `DASHBOARD.md` (required - single source of truth for progress)
   - `PLAN.md` (required - static context)

   **CREATE phase-N/ directories + task files IF**:
   - Mode B (explicit structure) ‚Üí Always create
   - Mode A with rich context (clear tasks identified) ‚Üí Create
   - Mode A with minimal context ‚Üí Don't create yet (user adds with /flow-phase-add later)

6. **Generate files**:

   **üí° BEST PRACTICE - Turn-Based Approach**:
   For large projects with many phases/tasks, use a turn-based approach to manage context:
   1. **First turn**: Create PLAN.md only (architecture, scope, overview)
   2. **Second turn**: Create DASHBOARD.md (list all phases/tasks structure)
   3. **Third+ turns**: Create task files incrementally (Phase 1, then Phase 2, etc.)

   This prevents context overflow and allows human review between steps.

   **When to use turn-based**:
   - 3+ phases with multiple tasks each
   - Complex projects requiring detailed task descriptions
   - When human wants to review structure before task file creation

   **When to use single-turn**:
   - Small projects (1-2 phases, few tasks)
   - Clear structure from user's description
   - Minimal task file content needed

   a. **Create PLAN.md FIRST** (turn 1 if using turn-based approach):
      - Use template from .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2232-2321
      - Include (MINIMAL - no assumptions):
        - Header with purpose
        - Overview (Purpose, Goals - text format NO checklists, Scope V1 only)
        - Architecture (high-level system context if info provided)
        - DO/DON'T Guidelines
        - Notes & Learnings (empty initially)
      - **DO NOT INCLUDE** (unless user explicitly requests):
        - V2/V3 Scope sections
        - Testing Strategy section (user decides during brainstorming)
        - Development Phases section
        - Future Enhancements section
      - **If turn-based**: Stop here, confirm with user, ask if ready for DASHBOARD

   b. **Create DASHBOARD.md SECOND** (turn 2 if using turn-based approach):
      - Use template from .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2102-2200
      - Fill in project name, purpose
      - Current Work: Set to Phase 1, Task 1, Iteration 1 (if phases created) OR "No phases yet" (if not)
      - Progress Overview: List all phases/tasks structure (with iteration counts)
      - Completion Status: 0% initially
      - Next Actions: "Use /flow-phase-add to add first phase" OR "Use /flow-phase-start to begin"
      - Last Updated: Current timestamp
      - **If turn-based**: Stop here, ask user which phase to create task files for first

   c. **Create phase-N/ directories** (turn 3+ if using turn-based approach):
      - Create one directory per phase
      - Naming: `phase-1/`, `phase-2/`, etc.

   d. **Create phase-N/task-M.md files** (turn 3+ if using turn-based approach):
      - Use template from .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2383-2472 (task with iterations)
      - **ALL tasks have iterations** (no standalone tasks)
      - **CRITICAL: Create task files for EVERY task listed in DASHBOARD.md**
        - If DASHBOARD.md shows "Task 1: Name" under Phase 2, then `phase-2/task-1.md` MUST exist
        - NEVER create incomplete structures where DASHBOARD promises tasks that don't exist
        - If uncertain about task details, use [TBD] placeholders - but file must exist
      - **If turn-based**: Create one phase at a time (e.g., all Phase 1 tasks, then ask before Phase 2)
      - Fill in:
        - Task name and purpose
        - Phase link back to DASHBOARD.md
        - Status: ‚è≥ PENDING initially
        - Task Overview with "Why This Task"
        - Dependencies (if known)
        - At least 1 iteration per task (with placeholder goal)
        - Task Notes section (empty initially)
      - **Context management**: For large projects, ask user after each phase if ready to continue

7. **Verify completeness** (self-check):
   - [ ] DASHBOARD.md created with all required sections?
   - [ ] PLAN.md created with minimal required sections (no assumptions)?
   - [ ] phase-N/ directories created (if applicable)?
   - [ ] phase-N/task-M.md files created with iterations (if applicable)?
   - [ ] **CRITICAL: Every task listed in DASHBOARD.md has a corresponding task file?**
     - Parse DASHBOARD.md "Progress Overview" section
     - For each task entry (e.g., "Task 1: Name"), verify phase-N/task-M.md exists
     - **NEVER create "phantom tasks"** - if DASHBOARD lists it, file MUST exist
   - [ ] DASHBOARD.md Current Work points to correct location?

8. **Confirm to user**:

   **If using turn-based approach**:
   - After PLAN.md: "‚ú® Created PLAN.md. Review the architecture and scope. Ready to create DASHBOARD.md?"
   - After DASHBOARD.md: "‚ú® Created DASHBOARD.md with [X] phases, [Y] tasks. Which phase should I create task files for first? (Suggest: Phase 1)"
   - After each phase's tasks: "‚úÖ Created [N] task files for Phase [X]. Ready to create Phase [X+1] task files?"

   **If Mode A (SUGGEST) with phases created** (single-turn approach):
   ```
   "‚ú® Created multi-file Flow project structure:

   üìÇ Files Created:
   - DASHBOARD.md (your main workspace - single source of truth)
   - PLAN.md (static context - minimal assumptions)
   - phase-1/ with [X] task files (all with iterations)
   - phase-2/ with [Y] task files (all with iterations)
   
   üìä Structure: [X] phases, [Y] tasks, [Z] iterations
   
   üéØ Next Steps:
   - Use `/flow-status` to see current state
   - Use `/flow-phase-start` to begin Phase 1
   - Use `/flow-brainstorm-start` when ready to design first iteration"
   ```

   **If Mode A (SUGGEST) without phases** (minimal context):
   ```
   "‚ú® Created initial Flow project structure:

   üìÇ Files Created:
   - DASHBOARD.md (your main workspace)
   - PLAN.md (static context - V1 scope only)
   
   üìù Note: No phases created yet (need more context)
   
   üéØ Next Steps:
   - Use `/flow-phase-add "Phase Name"` to add your first phase
   - Then use `/flow-task-add "Task Name"` to add tasks
   - Or re-run `/flow-blueprint` with more detailed requirements"
   ```

   **If Mode B (CREATE)**:
   ```
   "‚ú® Created multi-file Flow project from your explicit structure:

   üìÇ Files Created:
   - DASHBOARD.md (single source of truth)
   - PLAN.md (minimal assumptions)
   - phase-1/ ‚Üí [X] tasks (all with iterations)
   - phase-2/ ‚Üí [Y] tasks (all with iterations)
   - phase-3/ ‚Üí [Z] tasks (all with iterations)
   
   üìä Structure: [X] phases, [Y] tasks (as you specified)
   üìù [TBD] placeholders: [list sections with [TBD]]
   
   üéØ Next Steps:
   - Use `/flow-status` to see current state
   - Refine [TBD] sections during brainstorming
   - Use `/flow-phase-start` to begin work"
   ```

<!-- COMMAND_END -->
**Output**: Create multi-file Flow project structure and confirm to user.
## /flow-migrate

**File**: `flow-migrate.md`

```markdown
<!-- COMMAND_START -->
---
description: Migrate existing PRD/PLAN/TODO to Flow's .flow/PLAN.md format
---

You are executing the `/flow-migrate` command from the Flow framework.

**Purpose**: Migrate existing project documentation (PLAN.md, TODO.md, etc.) to Flow's multi-file format (DASHBOARD.md, PLAN.md, phase-N/task-M.md files).

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Multi-File Architecture, File Templates, Task Structure Rules, Status Markers
- **Deep dive if needed**: Read lines 2101-2600 for File Templates using Read(offset=2101, limit=500)

**Multi-File Architecture**: This command creates:
- `DASHBOARD.md` - Progress tracking (single source of truth)
- `PLAN.md` - Static context (overview, architecture, scope)
- `phase-N/` directories
- `phase-N/task-M.md` files for each task (all with iterations)
- `BACKLOG.md` - Deferred tasks (if applicable)

**Framework Reference**: This command requires framework knowledge to convert existing docs to Flow's multi-file structure. See Quick Reference guide above for essential patterns.

**IMPORTANT**: This command ALWAYS creates fresh Flow files, overwriting any existing multi-file structure. It reads your current documentation and converts it to multi-file Flow format.

**Instructions**:

1. **Read the framework guide AND examples** ‚ö†Ô∏è CRITICAL:

   - **Read .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353** (Quick Reference)
   - **Read .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2101-2600** (File Templates)
   - **Read framework/examples/** directory to see multi-file structure:
     - `framework/examples/DASHBOARD.md` - Dashboard format
     - `framework/examples/PLAN.md` - Static plan format
     - `framework/examples/phase-1/task-1.md` - Standalone task example
     - `framework/examples/phase-2/task-3.md` - Task with iterations example
   - **Understand**:
     - Multi-file hierarchy: DASHBOARD.md + PLAN.md + phase-N/task-M.md
     - Flow's hierarchy: PHASE ‚Üí TASK ‚Üí ITERATION ‚Üí BRAINSTORM ‚Üí IMPLEMENTATION
     - All status markers (‚úÖ ‚è≥ üöß üé® ‚ùå üîÆ üéØ)

2. **Discover existing documentation**:

   - Check if user provided path in `$ARGUMENTS`
   - Otherwise, search project root for common files (in order):
     - `PRD.md` (common in TaskMaster AI, Spec-Kit)
     - `PLAN.md`
     - `TODO.md`
     - `DEVELOPMENT.md`
     - `ROADMAP.md`
     - `TASKS.md`
   - If multiple found, list them and ask: "Found [X] files. Which should I migrate? (number or path)"
   - If none found, ask: "No plan files found. Provide path to file you want to migrate, or use `/flow-blueprint` to start fresh."

3. **Read and analyze source file**:

   - Read entire source file
   - Detect structure type:
     - **STRUCTURED** (Path A): Has phases/tasks/iterations or similar hierarchy
     - **FLAT_LIST** (Path B): Simple todo list or numbered items
     - **UNSTRUCTURED** (Path C): Free-form notes, ideas, design docs
   - Extract key information:
     - Project context/purpose
     - Existing work completed
     - Current status/position
     - Remaining work
     - Architecture/design notes
     - V1/V2 splits (if mentioned)
     - Deferred items
     - Cancelled items

4. **Create backup**:

   - Copy source file: `[original].pre-flow-backup-$(date +%Y-%m-%d-%H%M%S)`
   - Confirm: "‚úÖ Backed up [original] to [backup]"

5. **Generate multi-file Flow structure** based on detected structure (ALWAYS overwrites if exists):

   **Multi-File Generation Process**:
   - Create `DASHBOARD.md` with progress tracking (single source of truth)
   - Create `PLAN.md` with overview, architecture, scope (minimal assumptions)
   - Create `phase-N/` directories for each phase
   - Create `phase-N/task-M.md` files for each task (all with iterations)
   - Create `BACKLOG.md` if deferred items exist

   **Path A - STRUCTURED** (already has phases/tasks):

   - Keep existing hierarchy
   - **CRITICAL**: Use framework/examples/ directory as reference for all files
   - **Create DASHBOARD.md** (use framework/examples/DASHBOARD.md as template):
     - "üìç Current Work" section with current phase/task/iteration
     - "üìä Progress Overview" with all phases and tasks
     - "üìà Completion Status" with percentages
   - **Create PLAN.md** (use framework/examples/PLAN.md as template):
     - Overview section with Purpose, Goals (text only, no checklists), Scope (V1 only unless user specifies V2)
     - Architecture section with system context (high-level, not prescriptive)
     - DO/DON'T Guidelines section
     - Notes & Learnings section
   - **Create phase-N/ directories** for each phase
   - **Create task files** (use framework/examples/phase-2/task-3.md as template):
     - Task overview
     - Iterations with brainstorming sessions
     - Pre-implementation tasks (if applicable)
     - Implementation sections
     ```markdown
     > **üìñ Framework Guide**: See .flow/framework/DEVELOPMENT_FRAMEWORK.md for complete methodology and patterns used in this plan
     >
     > **üéØ Purpose**: [Brief description of what this plan covers - extract from existing docs]

     **Created**: [Original date if available]
     **Version**: V1
     **Plan Location**: `.flow/PLAN.md` (managed by Flow)
     ```
   - **Add/enhance Progress Dashboard section** (after Overview, before Architecture):
     - Follow EXAMPLE_PLAN.md lines 29-62 format exactly
     - Include: Last Updated, Current Work (with jump links), Completion Status, Progress Overview
     - **Ensure iteration lists are expanded** (read .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2555-2567 for format)
     - **Remove duplicate progress sections** (search for patterns like "Current Phase:", "Implementation Tasks", old progress trackers)
     - **Update status pointers** (change "Search for 'Current Phase' below" to jump link to Progress Dashboard)
   - **Add Testing Strategy section** if missing (see EXAMPLE_PLAN.md lines 87-129):
     - Ask user about testing methodology if not clear from existing docs
     - Include all required fields: Methodology, Location, Naming, When to create, When to add
   - **Add Changelog section** if missing (see EXAMPLE_PLAN.md lines 544-549):
     - Populate with existing completion dates if available
     - Format: `**YYYY-MM-DD**: - ‚úÖ [Iteration X]: [description]`
   - **Identify redundant framework docs** (ask user if sections like "Brainstorming Framework" should be removed since Flow provides this)
   - Standardize status markers (‚úÖ ‚è≥ üöß üé® ‚ùå üîÆ)
   - Add jump links to Progress Dashboard
   - Preserve all content, decisions, and context
   - Reformat sections to match Flow template
   - Report: "Enhanced existing structure (preserved [X] phases, [Y] tasks, [Z] iterations, added Progress Dashboard, Testing Strategy, Changelog, removed [N] duplicate sections)"

   **Path B - FLAT_LIST** (todos/bullets):

   - Ask: "Group items into phases? (Y/n)"
   - If yes, intelligently group related items
   - If no, create single phase with items as iterations
   - **CRITICAL**: Use EXAMPLE_PLAN.md as reference for all sections
   - **Add framework reference header** (copy format from EXAMPLE_PLAN.md lines 1-11)
   - **Add Progress Dashboard** (follow EXAMPLE_PLAN.md lines 29-62)
   - **Add Testing Strategy section** (ask user about methodology, see EXAMPLE_PLAN.md lines 87-129)
   - **Add Changelog section** (see EXAMPLE_PLAN.md lines 544-549)
   - Convert items to Flow iteration format
   - Add placeholder brainstorming sessions
   - Mark completed items as ‚úÖ, pending as ‚è≥
   - Report: "Converted flat list to Flow structure ([X] phases, [Y] tasks, [Z] iterations, added Progress Dashboard, Testing Strategy, Changelog)"

   **Path C - UNSTRUCTURED** (notes):

   - Extract key concepts and features mentioned
   - **CRITICAL**: Use EXAMPLE_PLAN.md as reference for all sections
   - **Create Framework reference header** (copy format from EXAMPLE_PLAN.md lines 1-11)
   - Create Overview section from notes
   - Create Architecture section if design mentioned
   - **Create Progress Dashboard** (minimal - project just starting, see EXAMPLE_PLAN.md lines 29-62)
   - **Create Testing Strategy section** (ask user about methodology, see EXAMPLE_PLAN.md lines 87-129)
   - **Create Changelog section** with initial entry (see EXAMPLE_PLAN.md lines 544-549)
   - Create initial brainstorming session with subjects from notes
   - Mark everything as ‚è≥ PENDING
   - Report: "Created Flow plan from notes (extracted [X] key concepts as brainstorming subjects, added all required sections)"

6. **Add standard Flow sections** (all paths):

   - **Framework reference header** (follow EXAMPLE_PLAN.md lines 1-11)
   - Progress Dashboard (follow EXAMPLE_PLAN.md lines 29-62)
   - Testing Strategy (follow EXAMPLE_PLAN.md lines 87-129)
   - Changelog (follow EXAMPLE_PLAN.md lines 544-549)
   - Development Plan with proper hierarchy
   - Status markers at every level

7. **Smart content preservation**:

   - NEVER discard user's original content
   - Preserve all decisions, rationale, context
   - Preserve code examples, file paths, references
   - Preserve completion status and dates
   - Enhance with Flow formatting, don't replace

8. **Verify completeness before saving** ‚ö†Ô∏è CRITICAL SELF-CHECK:
   - [ ] Framework reference header present (with üéØ Purpose line)?
   - [ ] Overview section present?
   - [ ] Progress Dashboard present (NOT optional - REQUIRED)?
   - [ ] Testing Strategy section present (ask user if missing)?
   - [ ] Changelog section present?
   - [ ] Development Plan with phases/tasks/iterations?
   - [ ] All iteration lists expanded (NOT "(X iterations total)")?
   - [ ] All original content preserved?
   - **If any checkbox is unchecked, review EXAMPLE_PLAN.md again and add missing section**

9. **Confirm to user**:
```

‚ú® Migration complete!

üìÇ Source: [original file path]
üíæ Backup: [backup file path]
üéØ Output: Multi-file Flow structure created

**Files Created**:
- DASHBOARD.md - Progress tracking dashboard
- PLAN.md - Static overview and architecture
- phase-1/ ‚Üí phase-N/ - Phase directories
- phase-N/task-M.md - Individual task files
- CHANGELOG.md - Historical record
- BACKLOG.md - Deferred tasks (if applicable)

Migration type: [STRUCTURED/FLAT_LIST/UNSTRUCTURED]
Changes: + Created [X] phase directories + Created [Y] task files + Migrated [Z] iterations + Preserved all decisions and context

Next steps:
1. Review: /flow-status
2. Verify structure: ls .flow/
3. Start using Flow: /flow-brainstorm-start [topic]

üìÇ Flow is now managing this project from .flow/ multi-file structure

```

10. **Handle edge cases**:
 - If source file is empty: Suggest `/flow-blueprint` instead
 - If source file is already Flow-compliant: Mention it's already compatible, migrate anyway
 - If can't determine structure: Default to Path C (unstructured)
 - If migration fails: Keep backup safe, report error, suggest manual approach

<!-- COMMAND_END -->
**Output**: Create multi-file Flow structure (DASHBOARD.md, PLAN.md, phase-N/task-M.md files) from existing documentation, create backup, confirm migration to user.
```

---

## /flow-plan-update

**File**: `flow-plan-update.md`

```markdown
<!-- COMMAND_START -->
---
description: Update existing plan to match latest Flow framework structure
---

You are executing the `/flow-plan-update` command from the Flow framework.

**Purpose**: Update an existing multi-file Flow structure to match the latest framework patterns.

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Multi-File Architecture, File Templates
- **Deep dive if needed**: Read lines 2101-2600 for File Templates using Read(offset=2101, limit=500)

**Multi-File Architecture**: This command updates:
- `DASHBOARD.md` - Ensures correct format and sections
- `PLAN.md` - Ensures correct format and sections
- `phase-N/task-M.md` files - Ensures correct format
- Adds missing files (CHANGELOG.md, BACKLOG.md if needed)

**IMPORTANT**: This command updates your current multi-file structure to match framework changes (e.g., new dashboard sections, status markers, structural improvements).

**Instructions**:

1. **Read the framework guide**:
   - Read .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference)
   - Read .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2101-2600 (File Templates)
   - Read framework/examples/ directory for current format

2. **Read current structure**:
   - Read `DASHBOARD.md`
   - Read `PLAN.md`
   - List phase directories: `ls .flow/phase-*/`
   - Sample task files: Read a few `phase-N/task-M.md` files

3. **Create backups**:
   - Create `.flow/backup-$(date +%Y-%m-%d-%H%M%S)/` directory
   - Copy all current files to backup directory
   - Confirm: "‚úÖ Backed up current structure to [backup]"

4. **Update files to match current templates**:

   **DASHBOARD.md**:
   - Ensure "üìç Current Work" section exists and is current
   - Ensure "üìä Progress Overview" section exists with all phases
   - Ensure "üìà Completion Status" section exists with percentages
   - Update "Last Updated" timestamp

   **PLAN.md**:
   - Ensure Overview section exists (Purpose, Scope with V1/V2 split)
   - Ensure Architecture section exists
   - Ensure Testing Strategy section exists
   - Ensure Development Phases section exists (high-level only)
   - NO detailed tasks in PLAN.md (those go in task files)

   **Task Files** (`phase-N/task-M.md`):
   - Ensure each has Task Overview section
   - Ensure each has Iterations section
   - Ensure brainstorming sessions are properly formatted
   - Ensure status markers are correct (‚úÖ ‚è≥ üöß üé® ‚ùå üîÆ)

   **Missing Files**:
   - Create CHANGELOG.md if missing
   - Create BACKLOG.md if deferred tasks exist

5. **Report changes**:

   Compare user's PLAN.md against these patterns and identify what needs updating:

   **‚úÖ CORRECT PATTERNS (v1.2.1+)**:

   **A. Section Order**:
   1. Title + Framework Reference header
   2. Overview (Purpose, Goals, Scope)
   3. Progress Dashboard (after Overview, before Architecture)
   4. Architecture
   5. Testing Strategy
   6. Development Plan (Phases ‚Üí Tasks ‚Üí Iterations)
   7. Changelog

   **B. Implementation Section Pattern** (NO ACTION ITEM DUPLICATION):
   ```markdown
   ### **Implementation - Iteration [N]: [Name]**

   **Status**: üöß IN PROGRESS

   **Action Items**: See resolved subjects above (Type 2/D items)

   **Implementation Notes**:
   [Document progress, discoveries, challenges]

   **Files Modified**:
   - `path/to/file.ts` - Description

   **Verification**: [How verified]
   ```

   **C. Progress Dashboard Jump Links**:
   ```markdown
   **Current Work**:
   - **Phase**: [Phase 2 - Core Implementation](#phase-2-core-implementation-)
   - **Task**: [Task 5 - Error Handling](#task-5-error-handling-)
   - **Iteration**: [Iteration 6 - Circuit Breaker](#iteration-6-circuit-breaker-) üöß IN PROGRESS
   ```

   **D. Iteration Lists** (EXPANDED, not collapsed):
   ```markdown
   - üöß **Task 23**: Refactor Architecture (3/3 iterations)
     - ‚úÖ **Iteration 1**: Separate Concerns - COMPLETE
     - ‚è≥ **Iteration 2**: Extract Logic - PENDING
     - ‚è≥ **Iteration 3**: Optimize - PENDING
   ```

   **E. Status Markers**: ‚úÖ ‚è≥ üöß üé® ‚ùå üîÆ (standardized)

   ---

   **‚ùå DEPRECATED PATTERNS (pre-v1.2.1)**:

   **A. Duplicated Action Items** (REMOVE):
   ```markdown
   ### ‚úÖ Subject 1: Feature X
   **Action Items**:
   - [ ] Item 1
   - [ ] Item 2

   ### **Implementation - Iteration 1**
   **Action Items** (from brainstorming):  ‚Üê DUPLICATE! REMOVE THIS
   - [ ] Item 1
   - [ ] Item 2
   ```
   **FIX**: Replace Implementation action items with "See resolved subjects above"

   **B. Collapsed Iteration Lists** (EXPAND):
   ```markdown
   - üöß Task 23: Architecture (3 iterations total)  ‚Üê WRONG!
   ```
   **FIX**: Expand to show all iterations as sub-bullets

   **C. Duplicate Progress Sections** (REMOVE):
   - Old "Current Phase" headers scattered throughout
   - Multiple "Implementation Tasks" trackers
   - Redundant status summaries
   **FIX**: Single Progress Dashboard after Overview

   **D. Text-based Status Pointers** (REPLACE):
   ```markdown
   Current work: Search for "Current Phase" below  ‚Üê WRONG!
   ```
   **FIX**: Use jump links: `[Progress Dashboard](#-progress-dashboard)`

   **E. Missing Testing Strategy Section** (ADD):
   **FIX**: Add Testing Strategy section (see EXAMPLE_PLAN.md lines 87-129)

6. **Present analysis to user**:

   **DO NOT automatically make changes**. Instead, present findings:

   ```markdown
   ## üìã Plan Structure Analysis

   I've compared your PLAN.md against the latest Flow framework (v1.2.1).

   **‚úÖ Already Correct**:
   - [List patterns that match current framework]

   **‚ùå Needs Updates**:

   1. **Action Item Duplication** (Found in X iterations)
      - Problem: Implementation sections duplicate action items from subjects
      - Fix: Replace with "See resolved subjects above"
      - Saves: ~600-1000 tokens per iteration

   2. **Progress Dashboard Location** (if applicable)
      - Problem: Dashboard is [location]
      - Fix: Move to after Overview, before Architecture

   3. **[Other issues found]**
      - Problem: [description]
      - Fix: [what needs to change]

   **Recommendation**: Should I update your PLAN.md to fix these issues?
   - I'll create a backup first
   - All content will be preserved
   - Only structure/formatting changes
   ```

7. **If user approves, update plan structure** (preserve ALL content):

   **Create backup first**:
   - Copy: `.flow/PLAN.md.version-update-backup-$(date +%Y-%m-%d-%H%M%S)`

   **Apply fixes** based on analysis from step 5:
   - Fix action item duplication (replace with references)
   - Move Progress Dashboard to correct location
   - Remove duplicate progress sections
   - Update status pointers to jump links
   - Add missing sections (Testing Strategy, Changelog)
   - Expand collapsed iteration lists
   - Standardize status markers

   **Preserve ALL**:
   - Decisions and rationale
   - Brainstorming subjects and resolutions
   - Implementation notes
   - Completion dates
   - Bug discoveries
   - Code examples

8. **Verify consistency**:

   - Check Progress Dashboard matches status markers
   - Verify all sections follow framework structure
   - Ensure no content was lost

6. **Confirm to user**:
```

‚ú® Multi-file structure updated to match latest Flow framework!

üíæ Backup: .flow/backup-[timestamp]/
üéØ Updated: All Flow files

**Files Updated**:
- DASHBOARD.md - Updated sections and format
- PLAN.md - Updated sections and format
- phase-N/task-M.md - Updated [X] task files
- Created missing files (if applicable)

Changes made:
+ Updated dashboard sections
+ Ensured all files match current templates
+ Standardized status markers
+ Fixed [N] formatting issues
+ Created [Y] missing files

Next steps:
1. Review changes: diff -r [backup] .flow/
2. Verify: /flow-status
3. Continue work: /flow-next

All your content preserved - only structure enhanced.

```

7. **Handle edge cases**:
- If `.flow/DASHBOARD.md` doesn't exist: Suggest `/flow-blueprint` or `/flow-migrate`
- If structure already matches latest: Report "Already up to date!"
- If can't determine what to update: Ask user for clarification

<!-- COMMAND_END -->
**Output**: Update all Flow files to latest framework structure, create backup, confirm changes to user.
```

---

## /flow-phase-add

**File**: `flow-phase-add.md`

```markdown
<!-- COMMAND_START -->
---
description: Add a new phase directory and update dashboard
---

You are executing the `/flow-phase-add` command from the Flow framework.

**Purpose**: Add a new phase to the project by creating a phase directory and updating DASHBOARD.md.

**üü¢ NO FRAMEWORK READING REQUIRED - Simple structure creation**

**Multi-File Architecture**: This command:
- Creates `phase-N/` directory
- Updates `DASHBOARD.md` with new phase
- Updates `PLAN.md` Development Phases section

**Instructions**:

1. **INPUT VALIDATION**:

   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "‚ùå Missing phase name. Example: /flow-phase-add 'Testing and QA'"
     STOP
   ```

   Accept even minimal input like "Testing" - will use [TBD] for missing metadata.

2. **Find .flow/DASHBOARD.md**:
   ```bash
   Primary location: .flow/DASHBOARD.md

   If not found:
     Suggest: "Run /flow-blueprint first to create project structure"
   ```

3. **Read DASHBOARD.md**:
   - Count existing phases to determine next phase number
   - Example: If "Phase 1" and "Phase 2" exist, new phase is "Phase 3"

4. **Parse arguments and infer metadata**:

   From `$ARGUMENTS`, extract or infer:
   - **Phase name**: Use $ARGUMENTS directly
   - **Strategy**: Try to infer from name:
     - "Foundation" ‚Üí "Setup and establish core architecture"
     - "Implementation" / "Core" ‚Üí "Build main features and functionality"
     - "Testing" / "QA" ‚Üí "Comprehensive testing and quality assurance"
     - "Polish" / "Enhancement" ‚Üí "Refinement and optimization"
     - Can't infer ‚Üí "[TBD] - Define during phase start"
   - **Goal**: Try to infer from name:
     - "Foundation" ‚Üí "Establish solid project foundation"
     - "Implementation" ‚Üí "Complete core feature set"
     - "Testing" ‚Üí "Ensure production-ready quality"
     - Can't infer ‚Üí "[TBD] - Define during phase start"

5. **Create phase directory**:
   ```bash
   mkdir .flow/phase-N/

   # Where N = next phase number (e.g., phase-3/)
   ```

6. **Update DASHBOARD.md**:

   Add to "üìä Progress Overview" section:
   ```markdown
   ### Phase [N]: [Phase Name] ‚è≥ PENDING

   **Goal**: [Inferred or [TBD]]
   **Status**: Not started

   (No tasks yet - use /flow-task-add to add tasks)
   ```

   Update "üìà Completion Status" section:
   - Increment phase count
   - Add phase to breakdown (0% complete initially)

7. **Update PLAN.md**:

   Add to "Development Phases" section:
   ```markdown
   ### Phase [N]: [Phase Name] ‚è≥

   **Strategy**: [Inferred or [TBD]]
   **Goal**: [Inferred or [TBD]]

   **Tasks**: See [phase-N/](phase-N/) directory for detailed task files
   ```

8. **Update DASHBOARD.md timestamp**:
   - Update "Last Updated" to current timestamp

9. **Confirm to user**:
   ```
   "‚úÖ Added Phase [N]: [Phase Name]

   üìÇ Created: .flow/phase-N/ directory
   üìù Updated: DASHBOARD.md, PLAN.md

   [If used [TBD]:]
   üìù Used [TBD] placeholders for: [Strategy/Goal]
   üí° Refine these during phase start

   üéØ Next Steps:
   - Use `/flow-task-add "Task Name"` to add tasks to this phase
   - Use `/flow-phase-start` when ready to begin work"
   ```

<!-- COMMAND_END -->
**Output**: Create phase-N/ directory and update DASHBOARD.md + PLAN.md with new phase.

```

---

## /flow-phase-start

**File**: `flow-phase-start.md`

```markdown
<!-- COMMAND_START -->
---
description: Mark current phase as in progress
---

You are executing the `/flow-phase-start` command from the Flow framework.

**Purpose**: Mark the current phase as üöß IN PROGRESS (when first task starts).

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**
- State transition (‚è≥ PENDING ‚Üí üöß IN PROGRESS)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 567-613 for lifecycle context

**Multi-File Architecture**: This command:
- Updates `DASHBOARD.md` phase status
- No changes to PLAN.md or task files

**üö® SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this phase that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìä Progress Overview" section
   - Locate first ‚è≥ PENDING phase

2. **Update phase status in dashboard**:
   - Change phase marker from ‚è≥ PENDING to üöß IN PROGRESS
   - Example:
     ```markdown
     ### Phase 2: Core Implementation ‚è≥ PENDING
     ```
     Becomes:
     ```markdown
     ### Phase 2: Core Implementation üöß IN PROGRESS
     ```

3. **Update "üìç Current Work" section**:
   - Set current phase to the phase just started
   - Clear task/iteration (no current work yet)
   ```markdown
   ## üìç Current Work
   - **Phase**: [Phase 2 - Core Implementation](phase-2/)
   - **Task**: None yet - use `/flow-task-add [name]` to create first task
   ```

4. **Update "Last Updated" timestamp** at top of dashboard

5. **Confirm to user**:
   ```
   ‚úÖ Started Phase [N]: [Name]

   Next steps:
   - Use `/flow-task-add [name]` to create tasks in this phase
   - Or use `/flow-blueprint` if you want to regenerate the plan structure
   ```

<!-- COMMAND_END -->
**Output**: Updated `DASHBOARD.md` with phase status change.
```

---

## /flow-phase-complete

**File**: `flow-phase-complete.md`

```markdown
<!-- COMMAND_START -->
---
description: Mark current phase as complete
---

You are executing the `/flow-phase-complete` command from the Flow framework.

**Purpose**: Mark the current phase as ‚úÖ COMPLETE (when all tasks done).

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**

- State transition (üöß IN PROGRESS ‚Üí ‚úÖ COMPLETE)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 567-613 for completion criteria

**Multi-File Architecture**: This command:
- Updates `DASHBOARD.md` phase status
- No changes to PLAN.md or task files

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìä Progress Overview" section
   - Locate current phase marked üöß IN PROGRESS

2. **Verify all tasks complete** in dashboard:
   - Check that all tasks in this phase are marked ‚úÖ COMPLETE
   - If incomplete tasks found:
     ```
     ‚ùå Cannot complete phase - incomplete tasks found:
     - Task 3: API Integration (üöß IN PROGRESS)
     - Task 5: Webhook Handler (‚è≥ PENDING)

     Complete all tasks first or mark them as ‚ùå CANCELLED / üîÆ DEFERRED.
     ```

3. **Update phase status in dashboard**:
   - Change phase marker from üöß IN PROGRESS to ‚úÖ COMPLETE
   - Example:
     ```markdown
     ### Phase 2: Core Implementation üöß IN PROGRESS
     ```
     Becomes:
     ```markdown
     ### Phase 2: Core Implementation ‚úÖ COMPLETE
     ```

4. **Update "üìç Current Work" section**:
   - **If next phase exists**: Advance to next phase (‚è≥ PENDING)
     ```markdown
     ## üìç Current Work
     - **Phase**: [Phase 3 - Testing & Hardening](phase-3/) ‚è≥ PENDING
     - **Task**: None yet - use `/flow-phase-start` to begin this phase
     ```
   - **If no next phase**: Mark project complete
     ```markdown
     ## üìç Current Work
     - **Status**: üéâ All phases complete!
     - **Next**: Consider archiving or planning V2
     ```

5. **Update completion percentages**:
   - Recalculate phase percentages
   - Update "üìà Completion Status" section
   - Update overall project percentage

6. **Update "Last Updated" timestamp** at top of dashboard

7. **Confirm to user**:
   ```
   ‚úÖ Completed Phase [N]: [Name]

   **What's Next**:
   - **Next phase exists?** ‚Üí Use `/flow-phase-start` to begin Phase [N+1]: [Name]
   - **All phases complete?** ‚Üí Project finished! üéâ Use `/flow-summarize` to review
   ```

<!-- COMMAND_END -->
**Output**: Updated `DASHBOARD.md` with phase completion and next steps.
```

---

## /flow-task-add

**File**: `flow-task-add.md`

```markdown
<!-- COMMAND_START -->
---
description: Create a new task file in current phase directory
---

You are executing the `/flow-task-add` command from the Flow framework.

**Purpose**: Create a new task file in the current phase directory and update DASHBOARD.md.

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-600 (Quick Reference) - if not already in context
- **Focus on**: Task Structure Rules (lines 164-223) - ALL tasks have iterations
- **Read task template**: Lines 2383-2472 for task file template (with iterations)

**Multi-File Architecture**: This command:
- Creates `phase-N/task-M.md` file
- Updates `DASHBOARD.md` with new task
- Optionally updates `PLAN.md` if phase description needs updating

**Instructions**:

1. **INPUT VALIDATION**:

   ```
   IF $ARGUMENTS is empty OR just whitespace:
     REJECT: "‚ùå Missing task name. Example: /flow-task-add 'User Authentication'"
     STOP
   ```

   Accept minimal input - will use [TBD] for missing metadata.

2. **Read DASHBOARD.md**:
   - Find current phase from "üìç Current Work" section
   - Count existing tasks in current phase to determine next task number
   - Example: If phase-2/ has task-1.md and task-2.md, new task is task-3.md

3. **Parse arguments and infer metadata**:

   From `$ARGUMENTS`, extract or infer:
   - **Task name**: Use $ARGUMENTS directly
   - **Purpose**: Try to infer:
     - "User Authentication" ‚Üí "Implement user authentication system"
     - "API Design" ‚Üí "Design and document API endpoints"
     - "Database Schema" ‚Üí "Design and implement database schema"
     - "Testing" ‚Üí "Implement testing infrastructure"
     - Can't infer ‚Üí "[TBD] - Define during task start"
   - **Task structure**: ALL tasks have iterations (no standalone tasks)
     - Simple tasks ‚Üí 1-2 iterations with direct action items
     - Complex tasks ‚Üí Multiple iterations with brainstorming
     - Always create with at least 1 iteration

4. **Create task file**:

   Create `phase-N/task-M.md` using template from .flow/framework/DEVELOPMENT_FRAMEWORK.md:

   ```markdown
   # Task [M]: [Task Name]

   **Status**: ‚è≥ PENDING
   **Phase**: [Phase N - Name](../DASHBOARD.md#phase-N-name)
   **Purpose**: [Inferred or [TBD]]

   ---

   ## Task Overview

   [Brief description based on task name]

   **Why This Task**: [TBD] - Define during task start or brainstorming

   [If complex task - add Dependencies section:]
   **Dependencies**:
   - **Requires**: [TBD]
   - **Blocks**: [TBD]

   ---

   ## Iterations

   ### ‚è≥ Iteration 1: [TBD]

   **Goal**: [TBD] - Define during brainstorming or task start

   **Status**: ‚è≥ PENDING

   ---

   #### Action Items

   - [ ] [TBD] - Define during brainstorming or add directly

   ---

   ## Task Notes

   **Discoveries**: (To be filled during work)

   **Decisions**: (To be filled during work)

   **References**: (Add relevant code/docs here)
   ```

5. **Update DASHBOARD.md**:

   Add to current phase in "üìä Progress Overview" section:
   ```markdown
   - ‚è≥ **Task [M]**: [Task Name]
   ```

   Update "üìà Completion Status":
   - Increment task count for current phase
   - Update phase completion percentage

   Update "üéØ Next Actions" if this is the first task:
   - "Use /flow-task-start to begin Task [M]"

6. **Update DASHBOARD.md timestamp**:
   - Update "Last Updated" to current timestamp

7. **Confirm to user**:
   ```
   "‚úÖ Created Task [M]: [Task Name]

   üìÇ Created: .flow/phase-N/task-M.md
   üìù Updated: DASHBOARD.md

   [If used [TBD]:]
   üìù Used [TBD] placeholders for: [Purpose/Action Items/Iterations]
   üí° Refine during task start or brainstorming

   üéØ Next Steps:
   - Use `/flow-task-start` to begin work on this task
   - Use `/flow-iteration-add` to add more iterations (if needed)
   - Use `/flow-brainstorm-start` when ready to design"
   ```

<!-- COMMAND_END -->
**Output**: Create phase-N/task-M.md file and update DASHBOARD.md.

```

---

## /flow-task-start

**File**: `flow-task-start.md`

```markdown
<!-- COMMAND_START -->
---
description: Mark current task as in progress
---

You are executing the `/flow-task-start` command from the Flow framework.

**Purpose**: Mark the current task as üöß IN PROGRESS (when first iteration starts).

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**
- State transition (‚è≥ PENDING ‚Üí üöß IN PROGRESS)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 567-613 for lifecycle context

**Multi-File Architecture**: This command:
- Updates task status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` current work section
- Auto-starts parent phase if needed

**üö® SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this task that are NOT part of the current work:
1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìä Progress Overview" section
   - Locate current phase (üöß IN PROGRESS or ‚è≥ PENDING)
   - Find next ‚è≥ PENDING task in that phase

2. **Determine target task**:
   - Use first ‚è≥ PENDING task in current phase
   - Extract phase number N and task number M

3. **Update task file** (`phase-N/task-M.md`):
   - Change task status at top of file:
     ```markdown
     **Status**: ‚è≥ PENDING
     ```
     Becomes:
     ```markdown
     **Status**: üöß IN PROGRESS
     ```

4. **Update parent phase status** (if needed):
   - If phase is ‚è≥ PENDING: Change to üöß IN PROGRESS in DASHBOARD.md
   - If phase already üöß IN PROGRESS: Skip this step

5. **Update DASHBOARD.md**:

   a. **Update "üìç Current Work" section**:
      ```markdown
      ## üìç Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: None yet - use `/flow-iteration-add` or `/flow-brainstorm-start`
      ```

   b. **Update task status in "üìä Progress Overview"**:
      - Change task marker from ‚è≥ to üöß
      - Example:
        ```markdown
        - ‚è≥ **Task 3**: API Integration (0/4 iterations)
        ```
        Becomes:
        ```markdown
        - üöß **Task 3**: API Integration (0/4 iterations) ‚Üê CURRENT
        ```

   c. **Update "Last Updated" timestamp** at top

6. **Confirm to user**:
   ```
   ‚úÖ Started Task [N]: [Name]

   Next steps:
   - Use `/flow-iteration-add [name]` to add iterations
   - Or use `/flow-brainstorm-start [topics]` to plan this task
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` status
- Updated `DASHBOARD.md` current work and task status
```

---

## /flow-task-complete

**File**: `flow-task-complete.md`

```markdown
<!-- COMMAND_START -->
---
description: Mark current task as complete
---

You are executing the `/flow-task-complete` command from the Flow framework.

**Purpose**: Mark the current task as ‚úÖ COMPLETE (when all iterations done).

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- State transition (üöß IN PROGRESS ‚Üí ‚úÖ COMPLETE)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 567-613 for completion criteria

**Multi-File Architecture**: This command:
- Updates task status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with completion and next work

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current task: Phase N, Task M
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Verify all iterations marked ‚úÖ COMPLETE
   - If incomplete iterations found:
     ```
     ‚ùå Cannot complete task - incomplete iterations found:
     - Iteration 2: Error Handling (üöß IN PROGRESS)
     - Iteration 3: Retry Logic (‚è≥ PENDING)

     Complete all iterations first or mark as ‚ùå CANCELLED / üîÆ DEFERRED.
     ```

3. **Update task file** (`phase-N/task-M.md`):
   - Change task status at top:
     ```markdown
     **Status**: üöß IN PROGRESS
     ```
     Becomes:
     ```markdown
     **Status**: ‚úÖ COMPLETE
     ```

4. **Update DASHBOARD.md**:

   a. **Update task status in "üìä Progress Overview"**:
      - Change task marker from üöß to ‚úÖ
      - Remove "‚Üê CURRENT" indicator
      - Example:
        ```markdown
        - üöß **Task 3**: API Integration (4/4 iterations) ‚Üê CURRENT
        ```
        Becomes:
        ```markdown
        - ‚úÖ **Task 3**: API Integration (4/4 iterations)
        ```

   b. **Update "üìç Current Work" section**:
      - **If more tasks in phase**: Advance to next task
        ```markdown
        ## üìç Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 4 - Webhook Handler](phase-2/task-4.md) ‚è≥ PENDING
        - **Next**: Use `/flow-task-start` to begin this task
        ```
      - **If all tasks in phase complete**: Suggest phase completion
        ```markdown
        ## üìç Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/) - All tasks complete!
        - **Next**: Use `/flow-phase-complete` to mark phase as done
        ```

   c. **Update completion percentages**:
      - Recalculate phase percentage
      - Recalculate overall percentage
      - Update "üìà Completion Status" section

   d. **Update "Last Updated" timestamp** at top

5. **Confirm to user**:
   ```
   ‚úÖ Completed Task [N]: [Name]

   **What's Next**:
   - **More tasks in phase?** ‚Üí Use `/flow-task-start` to begin Task [N+1]: [Name]
   - **All tasks complete?** ‚Üí Use `/flow-phase-complete` to mark phase as done
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` status
- Updated `DASHBOARD.md` with completion and next work
```

---

## /flow-iteration-add

**File**: `flow-iteration-add.md`

```markdown
<!-- COMMAND_START -->
---
description: Add a new iteration under the current task
---

You are executing the `/flow-iteration-add` command from the Flow framework.

**Purpose**: Add a new iteration to the current task file and update DASHBOARD.md.

**Multi-File Architecture**: This command:
- Adds iteration section to `phase-N/task-M.md` file
- Updates `DASHBOARD.md` with new iteration

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Iteration Patterns, Task Structure Rules
- **Deep dive if needed**: Read lines 238-566 for Task Structure Rules using Read(offset=238, limit=329)

**üö® SCOPE BOUNDARY RULE**:
If you discover NEW issues while working on this iteration that are NOT part of the current work:

1. **STOP** immediately
2. **NOTIFY** user of the new issue
3. **DISCUSS** what to do (add to brainstorm, create pre-task, defer, or handle now)
4. **ONLY** proceed with user's explicit approval

**Instructions**:

1. **Navigate from dashboard** (dashboard-first pattern):
   - Read `DASHBOARD.md`
   - Find current phase and task from "üìç Current Work" section
   - Extract: Phase number N, Task number M

2. **Parse arguments**:
   - `iteration_name` = Name/goal of iteration (required)
   - `iteration_description` = Optional description

3. **Read current task file**:
   - Open `phase-N/task-M.md`
   - Count existing iterations to determine next iteration number
   - Find "## Iterations" section

4. **Add new iteration section** to task file:

   ```markdown
   ### ‚è≥ Iteration [N]: [iteration_name]

   **Goal**: [iteration_name expanded or iteration_description if provided]
   **Status**: ‚è≥ PENDING

   ---
   ```

   **Template Notes**:
   - Place AFTER last iteration in "## Iterations" section
   - Use `###` heading level (three hashes)
   - Status always starts as ‚è≥ PENDING
   - Infer goal from iteration_name if no description provided

5. **Update DASHBOARD.md**:

   a. **Find current task entry** in "üìä Progress Overview" section

   b. **Update task iteration count**:
      - Change: `- üöß **Task 3**: API Integration (1/3 iterations)`
      - To: `- üöß **Task 3**: API Integration (1/4 iterations)`

   c. **Add iteration to expanded list** (if task is expanded):
      ```markdown
      - üöß **Task 3**: API Integration (1/4 iterations) ‚Üê CURRENT
        - ‚úÖ Iteration 1: REST Client Setup
        - üöß Iteration 2: Error Handling ‚Üê ACTIVE
        - ‚è≥ Iteration 3: Retry Logic
        - ‚è≥ Iteration 4: [NEW ITERATION NAME]
      ```

   d. **Update completion percentages**:
      - Recalculate phase percentage: `(completed_iterations / total_iterations) * 100`
      - Recalculate overall percentage
      - Update "üìà Completion Status" section

   e. **Update "Last Updated" timestamp** at top of dashboard

6. **Confirm to user**:
   ```
   ‚úÖ Added Iteration [N]: [iteration_name] to Task [M]: [Task Name]

   Next steps:
   - Use `/flow-brainstorm-start [topics]` to plan this iteration
   - Or add more iterations with `/flow-iteration-add [name]`
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` with new iteration section
- Updated `DASHBOARD.md` with iteration count and percentages

```

---

## /flow-brainstorm-start

**File**: `flow-brainstorm-start.md`

```markdown
<!-- COMMAND_START -->
---
description: Start brainstorming session with user-provided topics
---

You are executing the `/flow-brainstorm-start` command from the Flow framework.

**Purpose**: Begin a brainstorming session for the current iteration with subjects provided by the user.

**üî¥ REQUIRED: Read Framework Quick Reference First**
- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types, Common Patterns
- **Deep dive if needed**: Read lines 1167-1797 for complete Brainstorming Pattern using Read(offset=1167, limit=631)

**Framework Reference**: This command requires framework knowledge to structure brainstorming session correctly. See Quick Reference guide above for essential patterns.

**Signature**: `/flow-brainstorm-start [optional: free-form text describing topics to discuss]`

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates brainstorming section in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with "üöß BRAINSTORMING" status

**üö® SCOPE BOUNDARY RULE** (CRITICAL - see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues during brainstorming that are NOT part of the current iteration:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Why This Matters**: User stays in control of priorities, AI finds issues proactively but doesn't make scope decisions

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Check status (should be ‚è≥ PENDING or üöß IN PROGRESS)

3. **Determine mode** (two modes available):

   **MODE 1: With Argument** (user provides topics in command)
   - User provided topics in `topics` parameter (free-form text)
   - Parse the user's input and extract individual subjects
   - User controls WHAT to brainstorm, AI structures HOW
   - Example: `/flow-brainstorm-start "API design, database schema, auth flow, error handling"`
   - AI extracts: [API design, database schema, auth flow, error handling]
   - **Proceed to step 4**

   **MODE 2: Without Argument** (interactive) ‚ö†Ô∏è CRITICAL
   - **NO arguments provided** by user
   - **DO NOT** auto-generate subjects from iteration description
   - **DO NOT** read task file and invent subjects automatically
   - **DO NOT** proceed to create brainstorming section yet
   - **STOP and ask the user**:

     Example prompt to user:
     ```
     I'll start a brainstorming session for Iteration [K]: [Name].

     **What subjects would you like to discuss?**

     You can provide:
     - Comma-separated topics: "API design, database, auth"
     - Free-form text describing areas to explore
     - Bullet list of specific topics

     Based on the iteration scope, here are some suggestions:
     - [Suggestion 1 based on iteration goal]
     - [Suggestion 2 based on iteration goal]
     - [Suggestion 3 based on iteration goal]

     Please provide the topics you'd like to brainstorm.
     ```

   - **WAIT for user response** - do NOT proceed without it
   - **After user responds**, extract subjects from their response
   - **Then proceed to step 4**

4. **Extract subjects from user input** (ONLY after user provides topics):
   - Parse natural language text from user's input
   - Identify distinct topics/subjects (comma-separated, "and", bullet points, etc.)
   - Create numbered list
   - Handle 1 to 100+ topics gracefully
   - If ambiguous, ask user for clarification

5. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** to üöß IN PROGRESS (if ‚è≥ PENDING):
      ```markdown
      ### ‚è≥ Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### üöß Iteration 2: Error Handling
      ```

   b. **Create brainstorming section** in iteration:
      ```markdown
      #### Brainstorming Session - Error Handling Strategy

      **Focus**: Design comprehensive error handling for Stripe API integration

      **Subjects to Discuss** (tackle one at a time):

      1. ‚è≥ **API Error Types** - What errors can Stripe return?
      2. ‚è≥ **Error Mapping** - How to map Stripe errors to our domain?
      3. ‚è≥ **Retry Strategy** - When to retry, exponential backoff?
      4. ‚è≥ **User Experience** - How to communicate errors to users?

      **Resolved Subjects**:

      ---
      ```

6. **Update DASHBOARD.md**:

   a. **Update "üìç Current Work" section**:
      ```markdown
      ## üìç Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) üöß BRAINSTORMING
      - **Focus**: Designing comprehensive error handling strategy
      ```

   b. **Update iteration status in "üìä Progress Overview"**:
      - Change iteration marker to show üöß with "BRAINSTORMING" indicator

   c. **Update "Last Updated" timestamp** at top

7. **Confirm to user** (only after creating brainstorming section):
   ```
   ‚úÖ Started brainstorming session with [N] subjects for Iteration [K]: [Name]

   **Subjects**:
   1. [Subject 1]
   2. [Subject 2]
   3. [Subject 3]
   ...

   Use `/flow-next-subject` to start discussing the first subject.
   ```

**Key Principles**:
- ‚úÖ **User always provides topics** (via argument or when prompted)
- ‚ùå **AI NEVER invents subjects** from iteration description without user input
- ‚ùå **AI NEVER auto-generates** a subject list when no argument provided
- ‚úÖ **If no argument**: STOP, suggest topics, WAIT for user response
- ‚úÖ **After user provides topics**: THEN create brainstorming section

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` with brainstorming section
- Updated `DASHBOARD.md` with "üöß BRAINSTORMING" status

```

---

## /flow-brainstorm-subject

**File**: `flow-brainstorm-subject.md`

```markdown
<!-- COMMAND_START -->
---
description: Add a subject to discuss in brainstorming
---

You are executing the `/flow-brainstorm-subject` command from the Flow framework.

**Purpose**: Add a new subject to the current brainstorming session.

**üî¥ REQUIRED: Read Framework Quick Reference First**
- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Creation Patterns (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates "Subjects to Discuss" list in `phase-N/task-M.md`

**üö® SCOPE BOUNDARY RULE** (CRITICAL):

Adding subjects dynamically is a KEY feature of Flow. When you discover NEW issues while discussing current subjects:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking current subject resolution)
   - **B**: Add as new brainstorming subject (this command - design needed)
   - **C**: Handle immediately as part of current subject (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Parse arguments**: `subject_text` = subject name and optional brief description

3. **Read current task file** (`phase-N/task-M.md`):
   - Find current iteration's brainstorming session
   - Locate "Subjects to Discuss" section

4. **Add subject to list** in task file:
   - Count existing subjects
   - Append new subject:
     ```markdown
     5. ‚è≥ **[Subject Text]** - [Brief description if provided]
     ```

5. **Update task file**: Save changes to `phase-N/task-M.md`

6. **Confirm to user**:
   ```
   ‚úÖ Added Subject [N]: [Subject Text] to brainstorming session

   Use `/flow-next-subject` to discuss subjects in order.
   ```

<!-- COMMAND_END -->
**Output**: Updated `phase-N/task-M.md` with new subject in "Subjects to Discuss" list.
```

---

## /flow-brainstorm-review

**File**: `flow-brainstorm-review.md`

```markdown
<!-- COMMAND_START -->
---
description: Review all resolved subjects, suggest follow-up work
---

You are executing the `/flow-brainstorm-review` command from the Flow framework.

**Purpose**: Review all resolved brainstorming subjects, verify completeness, summarize decisions, show action items, and suggest follow-up work (iterations/pre-tasks) before marking the brainstorming session complete.

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types (A/B/C/D) (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Session Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Reads brainstorming session from `phase-N/task-M.md`
- Reviews all resolved subjects and suggests next steps
- **READ-ONLY** - No file changes (user confirms before completing)

**This is the review gate before `/flow-brainstorm-complete`.**

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K's brainstorming session
   - Read all "Subjects to Discuss" and "Resolved Subjects"

3. **Verify all subjects resolved**:

   - Check "Subjects to Discuss" section in task file
   - Count total subjects vs ‚úÖ resolved subjects
   - If ANY subjects remain unmarked (‚è≥ PENDING), warn user: "Not all subjects resolved. Run `/flow-next-subject` to complete remaining subjects."
   - If all subjects are ‚úÖ resolved, proceed to next step

4. **Summarize resolved subjects**:

   - Read all entries in "Resolved Subjects" section
   - Create concise summary of each resolution:
     - Subject name
     - Decision made
     - Key rationale points
   - Present in numbered list format

5. **Show all action items**:

   - Extract all documented action items from resolved subjects
   - Categorize by type:
     - **Pre-Implementation Tasks**: Work that must be done BEFORE implementing this iteration
     - **Follow-up Iterations**: Future work to tackle after this iteration
     - **Documentation Updates**: Files/docs that need changes
     - **Other Actions**: Miscellaneous tasks
   - Present in organized format

6. **Categorize action items** (CRITICAL - Ask user to clarify):

   **The 3 Types of Action Items**:

   **Type 1: Pre-Implementation Tasks (Blockers)**
   - Work that MUST be done BEFORE starting main implementation
   - Examples: Refactor legacy code, fix blocking bugs, setup infrastructure
   - These become separate "Pre-Implementation Tasks" section
   - Must be ‚úÖ COMPLETE before running `/flow-implement-start`

   **Type 2: Implementation Work (The Iteration Itself)**
   - The actual work of the current iteration
   - Examples: Command updates, feature additions, new logic
   - These stay as action items IN the iteration description
   - Work on these AFTER running `/flow-implement-start`

   **Type 3: New Iterations (Future Work)**
   - Follow-up work for future iterations
   - Examples: V2 features, optimizations, edge cases discovered
   - Create with `/flow-iteration-add`

   **Decision Tree for AI**:
   - Extract all action items from resolved subjects
   - For each action item, ask yourself:
     - "Does this BLOCK the main work?" ‚Üí Type 1 (Pre-task)
     - "Is this THE main work?" ‚Üí Type 2 (Implementation)
     - "Is this FUTURE work?" ‚Üí Type 3 (New iteration)
   - **If uncertain, ASK THE USER**: "I found these action items. Are they:
     - A) Blockers that must be done first (pre-tasks)
     - B) The implementation work itself
     - C) Future work for new iterations"

   Present categorization in this format:

     ```
     **Pre-Implementation Tasks** (Type 1 - complete before /flow-implement-start):
     - [Task description] - Why it blocks: [reason]

     **Implementation Work** (Type 2 - these ARE the iteration):
     - [Action item 1]
     - [Action item 2]
     (These stay in iteration, work on after /flow-implement-start)

     **New Iterations** (Type 3 - add with /flow-iteration-add):
     - Iteration N+1: [Name] - [Why it's future work]
     ```

7. **Consolidate Resolution Items into Action Items section** (CRITICAL - NEW PATTERN):

   After user confirms categorization:

   - **Extract all "Resolution Items" from Type D subjects**:
     - Read all resolved subjects with "Resolution Type: D"
     - Each Type D subject has a "Resolution Items" list
     - Collect all Resolution Items into a single consolidated list

   - **Replace iteration's Action Items section**:
     ```markdown
     #### Action Items

     (Consolidated from Resolution Items above by `/flow-brainstorm-review`)

     - [ ] [Resolution Item 1 from Subject 1]
     - [ ] [Resolution Item 2 from Subject 1]
     - [ ] [Resolution Item 1 from Subject 2]
     - [ ] [Resolution Item 2 from Subject 2]
     - [ ] [Resolution Item 1 from Subject 3]
     ```

   - **Key Points**:
     - ONE Action Items section per iteration (single source of truth)
     - Preserves all Resolution Items from all Type D subjects
     - Add header comment: "(Consolidated from Resolution Items above by `/flow-brainstorm-review`)"
     - All checkboxes start as unchecked `- [ ]`
     - Resolution Items in subjects remain unchanged (for context)

   - **If NO Type D items** (all subjects are Type A/B/C):
     - Create minimal Action Items section referencing pre-tasks or other work

8. **Await user confirmation**:
   - Do NOT automatically create iterations or pre-tasks
   - Show categorization above
   - Ask: "Does this categorization look correct? Should I adjust anything?"
   - If user confirms Type 1 (pre-tasks) exist: Ask if they want them created now
   - If user confirms Type 3 (new iterations): Ask if they want them created now
   - After confirmation: Ask about action items consolidation (step 7)

8b. **Reminder**: If you discover new issues during implementation (scope violations), STOP and discuss with the user before proceeding.

9. **Show "What's Next" Section**:
   ```markdown
   ## üéØ What's Next

   **After reviewing**:
   1. If pre-implementation tasks were identified ‚Üí Create them in "Pre-Implementation Tasks" section
   2. If new iterations were suggested ‚Üí Use `/flow-iteration-add` to create each one
   3. Once all pre-tasks are ‚úÖ COMPLETE ‚Üí Run `/flow-brainstorm-complete` to mark iteration üé® READY

   **Decision Tree**:
   - Pre-tasks needed? ‚Üí Create them, complete them, THEN run `/flow-brainstorm-complete`
   - No pre-tasks? ‚Üí Run `/flow-brainstorm-complete` immediately
   - Need more iterations? ‚Üí Use `/flow-iteration-add [description]` first
   ```

<!-- COMMAND_END -->
**Output**:
- **READ-ONLY** - No files modified
- Comprehensive review summary with actionable suggestions, awaiting user confirmation
- User must confirm before proceeding to `/flow-brainstorm-complete`
```

---

## /flow-brainstorm-complete

**File**: `flow-brainstorm-complete.md`

```markdown
<!-- COMMAND_START -->
---
description: Complete brainstorming and generate action items
---

You are executing the `/flow-brainstorm-complete` command from the Flow framework.

**Purpose**: Close the current brainstorming session (only after pre-implementation tasks are done).

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Completion Criteria (lines in Quick Reference)
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Updates iteration status to üé® READY in `phase-N/task-M.md`
- Updates `DASHBOARD.md` with "üé® READY FOR IMPLEMENTATION" status

**IMPORTANT**: Pre-implementation tasks should be documented in task file during brainstorming, then completed BEFORE running this command.

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K
   - Verify all subjects in "Subjects to Discuss" are ‚úÖ resolved

3. **Check for pre-implementation tasks** in task file:

   - Look for "#### Pre-Implementation Tasks" section in iteration
   - If found:
     - Check if all pre-tasks are marked ‚úÖ COMPLETE
     - If any are ‚è≥ PENDING or üöß IN PROGRESS:
       ```
       ‚ùå Pre-implementation tasks exist but are not complete:
       - [Task 1]: ‚è≥ PENDING
       - [Task 2]: üöß IN PROGRESS

       Complete them first, then run this command again.
       ```
     - If all are ‚úÖ COMPLETE: Proceed to step 4
   - If not found: Proceed to step 4

4. **Verify iteration has up-to-date action items**:

   - Read the iteration's goal or action items
   - Check if they reference the brainstorming session:
     - ‚úÖ **Good patterns**:
       - References brainstorming subjects
       - Has action items from Type D resolutions
     - ‚ùå **Outdated patterns**:
       - No reference to brainstorming
       - Action items don't match resolved subjects

   - **If action items are outdated**:
     - Warn user: "The iteration's action items don't reference the brainstorming session. Should I update them to match the brainstorming subjects?"
     - Wait for user confirmation

   - **If action items are up-to-date**: Proceed to step 5

5. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from üöß to üé®:
      ```markdown
      ### üöß Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### üé® Iteration 2: Error Handling
      ```

   b. **Add completion note** after brainstorming session:
      ```markdown
      **Brainstorming Status**: ‚úÖ COMPLETE
      **Pre-Implementation Tasks**: ‚úÖ COMPLETE (if applicable)
      **Ready for**: `/flow-implement-start`
      ```

6. **Update DASHBOARD.md**:

   a. **Update "üìç Current Work" section**:
      ```markdown
      ## üìç Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) üé® READY FOR IMPLEMENTATION
      - **Next**: Use `/flow-implement-start` to begin implementation
      ```

   b. **Update iteration status in "üìä Progress Overview"**:
      - Change iteration marker to show üé® READY

   c. **Update "Last Updated" timestamp** at top

   d. **Reminder**: If you discover new issues during implementation (scope violations), STOP and discuss with the user before proceeding.

7. **Confirm to user**:
   ```
   ‚úÖ Brainstorming session complete! Iteration [K]: [Name] marked üé® READY FOR IMPLEMENTATION

   **Next Step**: Use `/flow-implement-start` to begin implementation

  
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` with üé® READY status
- Updated `DASHBOARD.md` with "üé® READY FOR IMPLEMENTATION"
```

---

## /flow-implement-start

**File**: `flow-implement-start.md`

```markdown
<!-- COMMAND_START -->
---
description: Begin implementation of current iteration
---

You are executing the `/flow-implement-start` command from the Flow framework.

**Purpose**: Begin implementation phase for the current iteration.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task file**

- State transition (üé® READY/‚è≥ PENDING ‚Üí üöß IMPLEMENTING)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1798-1836 for implementation workflow

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current work
- Updates iteration status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` current work section
- **Prerequisite**: Brainstorming must be ‚úÖ COMPLETE and all pre-implementation tasks done

**üö® SCOPE BOUNDARY RULE** (CRITICAL - see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues during implementation that are NOT part of the current iteration's action items:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Exception**: Syntax errors or blocking bugs in files you must modify (document what you fixed in Implementation Notes)

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current task: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Check iteration status (should be üé® READY or ‚è≥ PENDING)

3. **Read Testing Strategy** (CRITICAL):
   - Read `PLAN.md` "## Testing Strategy" section
   - Understand verification methodology (simulation, unit tests, TDD, manual QA)
   - Note file locations, naming conventions
   - **IMPORTANT**: Follow Testing Strategy exactly - do NOT violate conventions

4. **Verify readiness** (if iteration was üé® READY):
   - Brainstorming should be marked ‚úÖ COMPLETE
   - All pre-implementation tasks should be ‚úÖ COMPLETE
   - If not ready: Warn user and ask to complete brainstorming/pre-tasks first

5. **Handle ‚è≥ PENDING iterations** (no brainstorming yet):
   - Ask user: "Previous iteration complete. Do you want to brainstorm this iteration first (recommended) or skip directly to implementation?"
     - **User chooses brainstorm**: "Please run `/flow-brainstorm-start` first"
     - **User chooses skip**: Proceed with implementation

6. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from üé®/‚è≥ to üöß IN PROGRESS:
      ```markdown
      ### üé® Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### üöß Iteration 2: Error Handling
      ```

   b. **Create implementation section** in task file:
      ```markdown
      #### Implementation - Iteration 2: Error Handling

      **Status**: üöß IN PROGRESS (2025-01-15)

      **Action Items**: See resolved subjects above (Type D items)

      **Implementation Notes**:
      [Leave blank - filled during work]

      **Files Modified**:
      [Leave blank - filled as work progresses]

      **Verification**: [Leave blank - how work verified]

      ---
      ```

   **IMPORTANT**: Implementation section REFERENCES subjects (don't duplicate action items)

7. **Update parent task status** (if needed):
   - If task is ‚è≥ PENDING: Change to üöß IN PROGRESS in task file AND DASHBOARD.md
   - If task already üöß: Skip

8. **Update DASHBOARD.md**:

   a. **Update "üìç Current Work" section**:
      ```markdown
      ## üìç Current Work
      - **Phase**: [Phase 2 - Core Implementation](phase-2/)
      - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
      - **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) üöß IMPLEMENTING
      - **Focus**: Implementing comprehensive error handling with retry logic
      ```

   b. **Update iteration status in "üìä Progress Overview"**:
      - Change iteration marker from üé®/‚è≥ to üöß
      - Add "‚Üê ACTIVE" indicator

   c. **Update "Last Updated" timestamp** at top

9. **Confirm to user**:
   ```
   ‚úÖ Started implementation of Iteration [K]: [Name]

   Action items from brainstorming subjects:
   - [List Type D action items from resolved subjects]

   Follow Testing Strategy in PLAN.md for verification.
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` with implementation section
- Updated `DASHBOARD.md` current work

```

---

## /flow-implement-complete

**File**: `flow-implement-complete.md`

```markdown
<!-- COMMAND_START -->
---
description: Mark current iteration as complete
---

You are executing the `/flow-implement-complete` command from the Flow framework.

**Purpose**: Mark the current iteration as complete.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task file**
- State transition (üöß IMPLEMENTING ‚Üí ‚úÖ COMPLETE)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1798-1836 for completion criteria

**Multi-File Architecture**: This command:
- Updates iteration status in `phase-N/task-M.md`
- Updates `DASHBOARD.md` completion percentages
- Advances to next iteration or suggests task completion

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K
   - Navigate to task file link

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K in "## Iterations" section
   - Verify iteration marked üöß IN PROGRESS

3. **Verify completion**:
   - Check brainstorming action items (if brainstorming was done)
   - If unchecked items remain: Ask "There are unchecked action items. Are you sure you want to mark complete?"

4. **Check for existing verification information**:
   - Read Implementation Notes section in task file
   - Review recent conversation (last 5-10 messages) for testing/verification discussion
   - If verification info found: Skip to step 6 (don't ask redundant questions)
   - If NO verification info found: Proceed to step 5

5. **Prompt for verification notes** (ONLY if not already available):
   ```
   How did you verify this iteration works?
   - Tests run? (unit, integration, simulation)
   - Manual checks?
   - Code review?
   ```

6. **Update task file** (`phase-N/task-M.md`):

   a. **Update iteration status** from üöß to ‚úÖ:
      ```markdown
      ### üöß Iteration 2: Error Handling
      ```
      Becomes:
      ```markdown
      ### ‚úÖ Iteration 2: Error Handling
      ```

   b. **Update implementation section**:
      ```markdown
      #### Implementation - Iteration 2: Error Handling

      **Status**: ‚úÖ COMPLETE (2025-01-15)

      **Implementation Notes**:
      - Created `src/integrations/stripe/ErrorMapper.ts` (98 lines)
      - Created `src/integrations/stripe/RetryPolicy.ts` (76 lines)
      - Updated StripeClient with error handling and retry

      **Files Modified**:
      - `src/integrations/stripe/StripeClient.ts` - Added error handling
      - `src/integrations/stripe/ErrorMapper.ts` - Created
      - [... more files ...]

      **Verification**:
      - ‚úÖ All error mapping tests passing
      - ‚úÖ Retry logic tests passing
      - ‚úÖ Integration test with Stripe API successful
      ```

7. **Check if task/phase complete**:
   - Count iterations: How many ‚úÖ COMPLETE vs total?
   - If all iterations complete: Task is ready for `/flow-task-complete`

8. **Update DASHBOARD.md**:

   a. **Update iteration status in "üìä Progress Overview"**:
      - Change iteration marker from üöß to ‚úÖ
      - Update iteration count: `(1/4 iterations)` ‚Üí `(2/4 iterations)`

   b. **Update "üìç Current Work" section**:
      - **If more iterations**: Advance to next iteration
        ```markdown
        ## üìç Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 3 - API Integration](phase-2/task-3.md)
        - **Iteration**: [Iteration 3 - Retry Logic](phase-2/task-3.md#iteration-3-retry-logic) ‚è≥ PENDING
        - **Next**: Use `/flow-brainstorm-start` or `/flow-implement-start`
        ```
      - **If all iterations complete**:
        ```markdown
        ## üìç Current Work
        - **Phase**: [Phase 2 - Core Implementation](phase-2/)
        - **Task**: [Task 3 - API Integration](phase-2/task-3.md) - All iterations complete!
        - **Next**: Use `/flow-task-complete` to mark task as done
        ```

   c. **Update completion percentages**:
      - Recalculate phase percentage
      - Recalculate overall percentage
      - Update "üìà Completion Status" section

   d. **Update "Last Updated" timestamp** at top

9. **Confirm to user**:
   ```
   ‚úÖ Completed Iteration [K]: [Name]

   **What's Next**:
   - **More iterations?** ‚Üí Use `/flow-brainstorm-start` or `/flow-implement-start` for next iteration
   - **All iterations done?** ‚Üí Use `/flow-task-complete` to mark task as complete

   **Current state**: [X]/[Y] iterations complete
   ```

<!-- COMMAND_END -->
**Output**:
- Updated `phase-N/task-M.md` with completion status
- Updated `DASHBOARD.md` with progress and next work

```

---

## /flow-status

**File**: `flow-status.md`

```markdown
<!-- COMMAND_START -->
---
description: Show current position and project progress
---

You are executing the `/flow-status` command from the Flow framework.

**Purpose**: Display current work position and project progress from the dashboard.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md**
- Dashboard-first approach - reads ONLY DASHBOARD.md
- Extremely efficient: <100 lines to read vs thousands in old architecture
- This is the REFERENCE MODEL command - simplest example of multi-file navigation

**Multi-File Architecture**: Flow now uses separate files:
- `DASHBOARD.md` - Progress tracking (‚≠ê read by this command)
- `PLAN.md` - Static context (not read by this command)
- `phase-N/task-M.md` - Task details (not read by this command)

**Instructions**:

1. **Find .flow/DASHBOARD.md**:
   ```bash
   # Primary location
   .flow/DASHBOARD.md

   # If not found
   Suggest: "/flow-blueprint to create new project" or "/flow-plan-update to migrate old single-file plan"
   ```

2. **Read DASHBOARD.md** (entire file):
   ```bash
   # Simply read the whole file - it's small and focused
   Read: .flow/DASHBOARD.md
   ```

   DASHBOARD.md contains everything you need:
   - Current work pointer (Phase/Task/Iteration)
   - Progress overview for all phases
   - Completion percentages
   - Next actions
   - Recent activity
   - Last updated timestamp

3. **Extract key information**:

   From "üìç Current Work" section:
   - Current Phase (number and name)
   - Current Task (number and name)
   - Current Iteration (number and name)
   - Current status emoji (‚è≥ üöß üé® ‚úÖ etc.)
   - Focus description

   From "üìä Progress Overview" section:
   - All phases with their status
   - Tasks within each phase
   - Iteration counts per task
   - Completion indicators

   From "üìà Completion Status" section:
   - Phases: X/Y complete
   - Tasks: X/Y complete
   - Iterations: X/Y complete
   - Overall percentage

   From "üéØ Next Actions" section:
   - Immediate actions (today)
   - Short-term actions (this week)
   - Upcoming milestones

4. **Display formatted status**:

   ```
   # [Project Name] - Status

   üìç **Current Work**
   Phase [N]: [Name] [Status]
     ‚îî‚îÄ Task [M]: [Name] [Status]
         ‚îî‚îÄ Iteration [K]: [Name] [Status]

   **Focus**: [Current focus description from dashboard]

   ---

   üìä **Progress Overview**

   ### Phase 1: [Name] [Status]
   - Task 1: [Name] [Status] ([X/Y iterations])
   - Task 2: [Name] [Status] ([X/Y iterations])

   ### Phase 2: [Name] [Status] ‚Üê CURRENT
   - Task 1: [Name] [Status] ([X/Y iterations])
   - Task 2: [Name] [Status] ([X/Y iterations]) ‚Üê CURRENT

   ### Phase 3: [Name] [Status]
   ...

   ---

   üìà **Completion**
   - Phases: [X/Y] ([percentage]%)
   - Tasks: [X/Y] ([percentage]%)
   - Iterations: [X/Y] ([percentage]%)
   - **Overall**: [percentage]%

   ---

   üéØ **Next Actions**
   Immediate:
   - [Action 1]
   - [Action 2]

   Short-term:
   - [Goal 1]
   - [Goal 2]

   ---

   üìù **Recent Activity**
   [Show 3-5 most recent items from dashboard]

   ---

   **Last Updated**: [Timestamp from dashboard]
   ```

5. **Suggest next action** (based on current iteration status):

   Read the current iteration status from dashboard and suggest:

   **If ‚è≥ PENDING**:
   ‚Üí "Use `/flow-brainstorm-start` to begin brainstorming this iteration"

   **If üöß IN PROGRESS (Brainstorming)**:
   ‚Üí "Use `/flow-next-subject` to continue brainstorming"
   ‚Üí Or check "Next Actions" section in dashboard for specific guidance

   **If üöß IN PROGRESS (Implementing)**:
   ‚Üí "Continue implementation. Use `/flow-implement-complete` when done"

   **If üé® READY**:
   ‚Üí "Use `/flow-implement-start` to begin implementation"

   **If ‚úÖ COMPLETE**:
   ‚Üí "Use `/flow-iteration-add` to add next iteration"
   ‚Üí Or if task complete: "Use `/flow-task-complete` to finish this task"

6. **Optional: Verify dashboard is up-to-date**:

   Check "Last Updated" timestamp:
   - If recent (< 1 hour): All good
   - If stale (> 24 hours): Suggest running `/flow-verify-plan` to check consistency

   Note: Don't read task files to verify - that's `/flow-verify-plan`'s job. This command trusts the dashboard.

**Key Principle**: DASHBOARD.md is the source of truth for current state. This command simply displays what's in the dashboard - it doesn't validate against task files (that's what `/flow-verify-plan` does).

<!-- COMMAND_END -->
**Output**: Formatted status display with current position, progress overview, completion stats, and next action suggestion.

```

---

## /flow-summarize

**File**: `flow-summarize.md`

```markdown
<!-- COMMAND_START -->
---
description: Generate summary of all phases/tasks/iterations
---

You are executing the `/flow-summarize` command from the Flow framework.

**Purpose**: Generate high-level overview of entire project structure and completion state.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task files**
- Uses DASHBOARD.md for high-level view
- Reads task files for detailed iteration status
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 105-179 for hierarchy context

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` for overall structure
- Reads all `phase-N/task-M.md` files for detailed status
- Generates comprehensive summary from all files

**Use case**: "Bird's eye view" of project health, progress across all phases, quick status reports

**Comparison to other commands**:
- `/flow-status` = "Where am I RIGHT NOW?" (micro view - reads DASHBOARD.md only)
- `/flow-summarize` = "What's the WHOLE PICTURE?" (macro view - reads all files)
- `/flow-verify-plan` = "Is this accurate?" (validation)

**Instructions**:

1. **Read DASHBOARD.md**:
   - Extract current work position
   - Get all phases and tasks from "üìä Progress Overview"
   - Get completion percentages from "üìà Completion Status"

2. **Read all task files**:
   - List all phase directories: `ls .flow/phase-*/`
   - For each phase, list task files: `ls .flow/phase-N/`
   - Read each `phase-N/task-M.md` to get:
     - Task status
     - All iterations with status markers
     - Brainstorming status (if applicable)

3. **Generate structured summary** (compact, scannable format):

```

üìä Flow Summary

Version: [V1/V2/V3]
Status: [Current phase/task/iteration from metadata]

Phase [N]: [Name] [Status] [%]

- Task [N]: [Name] [Status]
  - Iter [N-N] [Status]: [Concise description]
  - Iter [N] üöß CURRENT: [What you're working on]
  - Iter [N] ‚è≥: [What's next]

Phase [N]: [Name] [Status] [%]

- Task [N-N]: [Grouped if similar] [Status]
- Task [N]: [Name] [Status]

Deferred to V2:

- [Iteration/feature name]
- [Iteration/feature name]

---

TL;DR: [One punchy sentence about overall state]

```

4. **Formatting rules**:
- **Compact**: Group consecutive completed iterations (e.g., "Iter 1-5 ‚úÖ")
- **Scannable**: Use emojis (‚úÖ ‚è≥ üöß üé®) and percentages prominently
- **Highlight**: Mark CURRENT work explicitly in bold or with flag
- **Indent**: Phase (no indent), Task (- prefix), Iteration (-- or nested -)
- **Defer section**: Show V2/future items at bottom
- **Skip noise**: Don't list every task name if they're obvious/sequential
- **Focus on active work**: Emphasize in-progress and next items

5. **Example output** (payment gateway):

```

üìä Flow Summary

Version: V1
Status: Phase 2, Task 5, Iteration 2 - In Progress

Phase 1: Foundation ‚úÖ 100%

- Task 1-2: Setup, API, Database schema ‚úÖ

Phase 2: Core Implementation üöß 75%

- Task 3-4: Payment processing, Webhooks ‚úÖ
- Task 5: Error Handling
  - Iter 1 ‚úÖ: Retry logic
  - Iter 2 üöß CURRENT: Circuit breaker
  - Iter 3 ‚è≥: Dead letter queue

Phase 3: Testing & Integration ‚è≥ 0%

- Task 6: Integration tests (pending)

Deferred to V2:

- Advanced features (monitoring, metrics)
- Name generation

---

TL;DR: Foundation done, core payment flow working, currently building circuit breaker for error handling.

```

**Example output** (RED project - showing V1/V2 split):

```

üìä Flow Summary - RED Ability Generation

=== V1 - Core System ===

Phase 1: Foundation ‚úÖ 100%

- Task 1-4: Constants, enums, types, refactoring ‚úÖ

Phase 2: Core Implementation üöß 85%

- Iter 1-5 ‚úÖ: Tier gen, slots, filtering, selection, template parsing
- Iter 6 üöß NEXT: Green.generate() integration (ties everything together)
- Iter 7 ‚è≥: Blue validation (input guards)
- Iter 9 ‚è≥ LAST: Red API wrapper (exposes Blue ‚Üí Green)

Phase 3: Testing

- Script-based testing (Blue ‚Üí Green flow)

Deferred to V2:

- Iter 8: Name generation (stub returns "Generated Ability")
- Database persistence
- Stats-based damage calculations

=== V2 - Enhanced System (Phase 4) ===

Enhancements:

- Potency system (stats √ó formulas replace fixed damage)
- Name generation (124 weighted prefix/suffix combos)
- 12 new placeholders (conditionals, resources, targeting)
- Damage variance (¬±10% for crits)
- Points & Luck systems
- Database persistence

---

TL;DR:
V1 = Basic working system with hardcoded damage ranges (85% done, integration next)
V2 = Dynamic formulas, character stats integration, full feature set

```

6. **Add deferred/cancelled sections**:
```

üîÆ Deferred Items:

- Iteration 10: Name Generation (V2 - complexity, needs 124 components)
- Task 12: Advanced Features (V2 - out of V1 scope)
- Feature X: Multi-provider support (V3 - abstraction layer)

‚ùå Cancelled Items:

- Task 8: Custom HTTP Client (rejected - SDK is better)
- Subject 3: GraphQL API (rejected - REST is sufficient)

```

7. **Smart verification** (active work only):
- Skip ‚úÖ COMPLETE items (verified & frozen)
- Verify üöß ‚è≥ üé® items match Progress Dashboard
- Check ‚ùå items have reasons
- Check üîÆ items have reasons + destinations
- Report:
  ```
  üîç Verification (Active Work Only):
  ‚úÖ All active markers (üöß ‚è≥) match Progress Dashboard
  ‚è≠Ô∏è  Skipped 18 completed items (verified & frozen)
  ```

8. **Handle multiple versions**:
- If PLAN.md has V2/V3 sections, use `=== V1 Summary ===` separator
- V1 gets full Phase/Task/Iteration breakdown
- V2+ get high-level "Enhancements" list (not full iteration tree)
- Separate TL;DR line for each version

9. **After generating summary**:
- "Use `/flow-status` to see detailed current position"
- "Use `/flow-verify-plan` to verify accuracy against actual code"

**Manual alternative**:
- Read entire PLAN.md manually
- Create outline of all phases/tasks/iterations
- Count completions and calculate percentages
- Format into hierarchical view

<!-- COMMAND_END -->
**Output**: Hierarchical summary of entire project structure with completion tracking.
```

---

## /flow-next-subject

**File**: `flow-next-subject.md`

```markdown
<!-- COMMAND_START -->
---
description: Discuss next subject, capture decision, and mark resolved
---

You are executing the `/flow-next-subject` command from the Flow framework.

**Purpose**: Show next unresolved subject, present options collaboratively, wait for user decision, then mark as ‚úÖ resolved.

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Subject Resolution Types (lines in Quick Reference) - Types A/B/C/D decision matrix
- **Deep dive if needed**: Read lines 1167-1797 for Brainstorming Pattern using Read(offset=1167, limit=631)

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current iteration
- Reads/updates brainstorming session in `phase-N/task-M.md`
- Marks subjects ‚úÖ resolved in task file

**Framework Reference**: This command requires framework knowledge to properly categorize resolution types. See Quick Reference guide above for essential patterns.

**üö® SCOPE BOUNDARY RULE** (CRITICAL - see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 339-540):

If you discover NEW issues while discussing subjects that are NOT part of the current iteration:

1. **STOP** immediately - Don't make assumptions or proceed
2. **NOTIFY** user - Present discovered issue(s) with structured analysis
3. **DISCUSS** - Provide structured options (A/B/C/D format):
   - **A**: Create pre-implementation task (< 30 min work, blocking)
   - **B**: Add as new brainstorming subject (design needed)
   - **C**: Handle immediately (only if user approves)
   - **D**: Defer to separate iteration (after current work)
4. **AWAIT USER APPROVAL** - Never proceed without explicit user decision

**Use the Scope Boundary Alert Template** (see .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 356-390)

**Why This Matters**: User stays in control of priorities. AI finds issues proactively but doesn't make scope decisions.

**New Collaborative Workflow** (two-phase approach):
```

Phase 1 (Present):
/flow-next-subject ‚Üí present subject + options ‚Üí ask user ‚Üí üõë STOP & WAIT

Phase 2 (Capture - triggered by user response):
User responds ‚Üí capture decision ‚Üí document ‚Üí mark ‚úÖ ‚Üí auto-advance to next

```

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K's brainstorming session
   - Locate "Subjects to Discuss" section

3. **Find first unresolved subject**: Look for first ‚è≥ subject in the list

4. **If found** (subject needs discussion):

   **Step A: Present subject**
   - Display subject name and description
   - Present relevant context from iteration goal
   - **DO NOT read codebase files**
   - **DO NOT analyze existing implementation**
   - **DO NOT create detailed solutions**
   - Keep it brief - this is just presenting the topic

   **Step B: Present options and STOP** ‚ö†Ô∏è CRITICAL
   - **DO NOT research code** before presenting options
   - **DO NOT read files** to understand current implementation
   - **DO NOT create detailed architecture diagrams**
   - Suggest 2-4 high-level options/approaches based on GENERAL knowledge
   - Present each option with brief pros/cons (1-2 sentences each)
   - Format as numbered list for clarity
   - Include option for "Your own approach"
   - Ask user explicitly: "Which option do you prefer? Or provide your own approach."
   - **üõë STOP HERE - Wait for user response (do NOT proceed to capture decision)**
   - **DO NOT** decide on behalf of user
   - **DO NOT** document any decision yet
   - **DO NOT** create massive detailed resolutions
   - Command execution ends here - user will respond in next message

   **Step C: Capture user's decision** (only execute AFTER user responds)
   - Read user's response from their message
   - If decision is clear: proceed to document it
   - If unclear: ask clarifying questions
   - If rationale not provided: ask "What's your reasoning for this choice?"
   - Optional: "Any action items to track for this decision?"
   - **KEEP DOCUMENTATION CONCISE** (1-3 paragraphs, not 336 lines!)
   - **NO massive architecture diagrams** unless user explicitly provides one
   - **NO detailed implementation plans** - save for implementation phase
   - Capture: Decision + Rationale + Action Items (if any)

   **Step D: Document resolution in task file**
   - Mark subject ‚úÖ in "Subjects to Discuss" list (in `phase-N/task-M.md`)
   - Add **CONCISE** resolution section under "Resolved Subjects":
     ```markdown
     ### ‚úÖ **Subject [N]: [Name]**

     **Decision**: [User's decision from their response - 1-2 sentences]

     **Rationale**:
     - [Reason 1 from user or follow-up]
     - [Reason 2]

     **Action Items** (if any):
     - [ ] [Item 1 - brief, not detailed implementation steps]
     - [ ] [Item 2]

     ---
     ```
   - **Example of TOO MUCH**: 336 line resolution with interfaces, diagrams, detailed architecture
   - **Example of GOOD**: 10-20 line resolution with decision, rationale, 3-5 action items

   **Step E: Auto-advance OR prompt for review**
   - Save changes to `phase-N/task-M.md`
   - Show progress: "[N] of [Total] subjects resolved"
   - Check if more ‚è≥ subjects exist:
     - **If YES** (more pending): Auto-show next unresolved subject
     - **If NO** (all resolved): Show workflow prompt below

5. **If all resolved** (this was the last subject):
   - **Show brief summary** of decisions made
   - **‚ö†Ô∏è CRITICAL - Show "What's Next" Section (MANDATORY - AI MUST NOT SKIP THIS)**:
     ```markdown
     ‚úÖ All subjects resolved!

     ## üéØ What's Next

     **REQUIRED NEXT STEP**: Run `/flow-brainstorm-review` to:
     - Analyze all resolved subjects
     - Categorize action items (pre-tasks vs implementation vs new iterations)
     - Generate follow-up work suggestions
     - Prepare for implementation

     **DO NOT run `/flow-brainstorm-complete` yet** - review comes first!

     **Workflow Reminder**:
     1. ‚úÖ NOW: `/flow-brainstorm-review` (analyze & suggest)
     2. THEN: Create any pre-tasks if needed
     3. THEN: Complete pre-tasks (if any)
     4. FINALLY: `/flow-brainstorm-complete` (mark üé® READY)

     **Why this order matters**: Review identifies blockers (pre-tasks) that must be done before implementation starts.
     ```
   - **AI BEHAVIOR**: Do NOT suggest `/flow-brainstorm-complete` or any other command. The "What's Next" section MUST explicitly guide to `/flow-brainstorm-review` first.

**Key Principle**: Moving to next subject implies current is resolved. No separate "resolve" command needed.

<!-- COMMAND_END -->
**Output**: Updated `phase-N/task-M.md` with subject resolution and show next subject.
```

---

## /flow-next-iteration

**File**: `flow-next-iteration.md`

```markdown
<!-- COMMAND_START -->
---
description: Show next iteration details
---

You are executing the `/flow-next-iteration` command from the Flow framework.

**Purpose**: Display details about the next pending iteration in the current task.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- Finds next ‚è≥ PENDING iteration in current task
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 567-613 for iteration context

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current task
- Reads `phase-N/task-M.md` to find next pending iteration

**Pattern**: Works like `/flow-next-subject` but for iterations - shows what's coming next.

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current task: Phase N, Task M

2. **Read current task file** (`phase-N/task-M.md`):
   - Find "## Iterations" section
   - Look for first iteration marked ‚è≥ PENDING

3. **Find next pending iteration**: First ‚è≥ PENDING iteration in task file

4. **If found, display iteration details**:
```

üìã Next Iteration:

**Iteration [N]**: [Name]

**Goal**: [What this iteration builds]

**Status**: ‚è≥ PENDING

**Approach**: [Brief description from iteration section if available]

---

Ready to start? Use `/flow-brainstorm-start [topic]` to begin.

```

5. **If NOT found (no pending iterations)**:
- Check if current iteration is in progress: "Still working on Iteration [N]: [Name]. Use `/flow-implement-complete` when done."
- Otherwise: "No more iterations in current task. Use `/flow-iteration-add [description]` to create next iteration, or `/flow-task-complete` if task is done."

6. **Show progress**: "Iteration [current] of [total] in current task"

<!-- COMMAND_END -->
**Output**: Display next iteration details and suggest appropriate next action.
```

---

## /flow-next

**File**: `flow-next.md`

```markdown
<!-- COMMAND_START -->
---
description: Smart helper - suggests next action based on current context
---

You are executing the `/flow-next` command from the Flow framework.

**Purpose**: Auto-detect current context and suggest the next logical step.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works entirely from DASHBOARD.md and task file**

- Smart navigation using Dashboard and current context
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 3277-3356 for decision tree reference

**Multi-File Architecture**: This command:
- Reads `DASHBOARD.md` to find current work
- Reads `phase-N/task-M.md` to determine current state
- Suggests next command based on context

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current iteration: Phase N, Task M, Iteration K

2. **Read current task file** (`phase-N/task-M.md`):
   - Find iteration K
   - Check iteration status (‚è≥ üöß üé® ‚úÖ)

3. **Determine current context**:

   - Check if in brainstorming session:
     - Look for "Subjects to Discuss" section
     - Count unresolved subjects (‚è≥ markers)
   - Check for pre-implementation tasks:
     - Look for "#### Pre-Implementation Tasks" section
     - Count pending vs complete
   - Check if in main implementation:
     - Look for "#### Implementation" section

4. **Suggest next command based on context**:

   **Determine exact state**:

   **If status = ‚è≥ PENDING**:
   ‚Üí "Use `/flow-brainstorm-start [topic]` to begin this iteration"

   **If status = üöß IN PROGRESS**:
   **Check phase progression** (in this order):

   1. **Check unresolved subjects**:
      If any "‚è≥" subjects in "Subjects to Discuss":
      ‚Üí "Use `/flow-next-subject` to resolve next subject"
      Show: "X subjects remaining: [list]"

   2. **Check pre-implementation tasks**:
      If "### **Pre-Implementation Tasks:**" section exists:
      Count pending tasks (^#### ‚è≥)

      If pending > 0:
      ‚Üí "Continue with Task X: [Name]"
      Show: "[X/Y] pre-implementation tasks complete"

      If pending = 0:
      ‚Üí "Pre-implementation complete. Use `/flow-brainstorm-complete`"

   3. **Check main implementation**:
      If "### **Implementation**" section exists:
      ‚Üí "Continue main implementation"
      Show: "Use `/flow-implement-complete` when done"

   4. **Default** (subjects resolved, no pre-tasks):
      ‚Üí "Use `/flow-brainstorm-complete` to finish brainstorming"

   **If status = üé® READY**:
   ‚Üí "Use `/flow-implement-start` to begin implementation"

   **If status = ‚úÖ COMPLETE**:
   ‚Üí "Use `/flow-next-iteration` to move to next iteration"

4. **Show current status summary**: Brief summary of where you are

<!-- COMMAND_END -->
**Output**: Suggest appropriate next command based on context.
```

---

## /flow-rollback

**File**: `flow-rollback.md`

```markdown
<!-- COMMAND_START -->
---
description: Undo last plan change
---

You are executing the `/flow-rollback` command from the Flow framework.

**Purpose**: Undo the last change made to plan files (DASHBOARD.md or task files).

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Undoes last change using CHANGELOG.md
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1969-2014 for rollback patterns

**Multi-File Architecture**: This command can rollback:
- DASHBOARD.md status updates (phase/task/iteration status changes)
- Task file changes (iteration added, status updated)
- File moves (task archived, moved to backlog)

**Instructions**:

1. **Read CHANGELOG.md**:
   - Look for "üìù Recent Activity" section
   - If no CHANGELOG.md or no recent entries: "No recent changes to rollback."

2. **Identify last change**:

   - Parse last entry in CHANGELOG.md
   - Extract what was changed:
     - "Phase N started" ‚Üí DASHBOARD.md phase status
     - "Task M completed" ‚Üí DASHBOARD.md + task file status
     - "Iteration K added" ‚Üí Task file iteration section
     - "Task M moved to backlog" ‚Üí File moved to backlog/
     - "Task M archived" ‚Üí File moved to archive/

3. **Ask for confirmation**:

   - Display last change details:
     ```
     Last change ([Date/Time]):
     - Action: [Description]
     - File(s): [Affected files]
     - Change: [What was modified]

     Rollback this change? (yes/no)
     ```

4. **If confirmed, revert change based on type**:

   **A. Status change rollback**:
   - Read DASHBOARD.md
   - Revert status marker to previous state
   - Example: `üöß IN PROGRESS` ‚Üí `‚è≥ PENDING`
   - Update task file status marker if applicable

   **B. File move rollback**:
   - Move file back: `backlog/phase-N-task-M.md` ‚Üí `phase-N/task-M.md`
   - Or: `archive/phase-N/task-M.md` ‚Üí `phase-N/task-M.md`
   - Update DASHBOARD.md to remove archived/backlog markers
   - Update BACKLOG.md or CHANGELOG.md accordingly

   **C. Section added rollback**:
   - Remove last added section from task file
   - Example: Remove last iteration, pre-task, or brainstorm subject
   - Update DASHBOARD.md if iteration count changed

   **D. Checkbox rollback**:
   - Uncheck last checked checkbox in task file
   - Find Implementation section, uncheck last ‚úÖ item

5. **Update CHANGELOG.md**: Add rollback entry

   ```markdown
   ### [Date/Time]
   - üîÑ Rolled back: [Description of reverted change]
   ```

6. **Confirm to user**:

   ```
   ‚úÖ Rolled back: [Description of change]

   **Reverted**:
   - File: [file path]
   - Change: [what was undone]

   CHANGELOG.md updated with rollback entry.
   ```

**Limitation**: Can only rollback one step at a time. For major reverts, manually edit files or use git to revert commits.

<!-- COMMAND_END -->
**Output**: Revert last change in plan files, update CHANGELOG.md.
```

---

## /flow-verify-plan

**File**: `flow-verify-plan.md`

```markdown
<!-- COMMAND_START -->
---
description: Verify plan file matches actual codebase state
---

You are executing the `/flow-verify-plan` command from the Flow framework.

**Purpose**: Verify that plan files (DASHBOARD.md, PLAN.md, task files) are synchronized with actual project state.

**üî¥ REQUIRED: Read Framework Quick Reference First**

- **Read once per session**: .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 1-353 (Quick Reference section) - if not already in context from earlier in session, read it now
- **Focus on**: Framework Structure validation, Status Markers (in Quick Reference)
- **Deep dive if needed**: Read lines 105-179 for Framework Structure using Read(offset=105, limit=75)

**Multi-File Architecture**: This command verifies:
- `DASHBOARD.md` - Progress tracking and current work pointers
- `PLAN.md` - Static overview (architecture, testing, constraints)
- `phase-N/task-M.md` - Individual task files with iterations
- Task files contain actual action items and implementation details

**Context**:

- **Framework Guide**: .flow/framework/DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/PLAN.md, .flow/phase-N/task-M.md
- **Use case**: Run before starting new AI session or compacting conversation to ensure context is accurate

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section for current phase/task/iteration
   - Extract current phase number, task number, iteration number
   - Note current iteration status (üöß IN PROGRESS or üé® READY)

2. **Read current task file**:
   - Locate `.flow/phase-N/task-M.md` based on DASHBOARD.md
   - Find current iteration section (marked üöß IN PROGRESS or üé® READY)
   - Read "Implementation - Iteration [N]" section
   - Identify all action items
   - Note which items are marked as ‚úÖ complete

3. **Verify claimed completions against actual project state**:

   - For each ‚úÖ completed action item, check if it actually exists:
     - "Create UserAuth.ts" ‚Üí Verify file exists using Glob or Read
     - "Add login endpoint" ‚Üí Search for login endpoint in code using Grep
     - "Update database schema" ‚Üí Check schema files exist
   - List any discrepancies found

4. **Check for unreported work**:

   - Look for modified files that aren't mentioned in task file
   - Check git status (if available) for uncommitted changes
   - Identify files that were changed but not documented

5. **Verify DASHBOARD.md accuracy**:
   - Check that current work pointers match actual task file statuses
   - Verify completion percentages align with actual work done
   - Check that phase/task/iteration hierarchy is consistent

6. **Report findings**:
```

üìã Plan Verification Results:

**Current Work** (from DASHBOARD.md):
- Phase [N], Task [M], Iteration [K]

**Task File**: [phase-N/task-M.md](phase-N/task-M.md)

‚úÖ Verified Complete:
- [List action items that are correctly marked complete]

‚ùå Discrepancies Found:
- [List action items marked complete but evidence not found]
- [List DASHBOARD.md pointers that don't match task files]

üìù Unreported Work:
- [List files changed but not mentioned in task file]

Status: [SYNCHRONIZED / NEEDS UPDATE]

```

7. **If discrepancies found**:
- Ask user: "Plan files are out of sync with project state. Update files now? (yes/no)"
- If yes: Update plan files to reflect actual state:
  - Update task file (phase-N/task-M.md): Uncheck items that aren't actually done
  - Update DASHBOARD.md: Fix current work pointers, completion percentages
  - Add notes about files modified in task file "Implementation Notes" section
  - Update status markers if needed
- If no: "Review discrepancies above and update plan files manually."

8. **If synchronized**:
- "Plan files are synchronized with project state. Ready to continue work."

**Manual alternative**:
- Review DASHBOARD.md for current work location
- Read current task file manually
- Check each completed action item exists in codebase
- Use `git status` and `git diff` to verify changes
- Update task file and DASHBOARD.md to match reality

<!-- COMMAND_END -->
**Output**: Verification report and optional plan file updates.
```

---

## /flow-compact

**File**: `flow-compact.md`

```markdown
<!-- COMMAND_START -->
You are executing the `/flow-compact` command from the Flow framework.

**Purpose**: Generate comprehensive conversation report for context transfer to new AI instance.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Generates comprehensive report using DASHBOARD.md, PLAN.md, and task file content
- Uses `/flow-status` dashboard-first logic for current position
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2327-2362 for context preservation patterns

**Multi-File Architecture**: This command reads:
- `DASHBOARD.md` - Current work location and progress overview
- `PLAN.md` - Architecture, testing strategy, constraints (static context)
- `phase-N/task-M.md` - Current task file with iterations, brainstorming, implementation

**Context**:

- **Framework Guide**: .flow/framework/DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/PLAN.md, .flow/phase-N/task-M.md
- **Use case**: Before compacting conversation or starting new AI session - ensures zero context loss

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section for current phase/task/iteration
   - Read "üìä Progress Overview" for completed work
   - Read "üéØ Next Actions" for pending items
   - Read "üìù Recent Activity" for conversation history
   - Read "üí° Key Decisions This Week" for important context

2. **Read PLAN.md**:
   - Extract "## üéØ Project Goal" for feature overview
   - Read "## üèóÔ∏è Architecture" section for technical context
   - Read "## üß™ Testing Strategy" for quality requirements
   - Read "## üìã Constraints" for limitations
   - Read "## üéì Learning Goals" for educational objectives

3. **Read current task file** (from DASHBOARD.md pointers):
   - Locate `.flow/phase-N/task-M.md`
   - Read "Task Overview" section (purpose, dependencies, scope)
   - Read current iteration brainstorming subjects (decisions, rationale)
   - Read "Implementation - Iteration [N]" section (action items, progress)
   - Read "Task Notes" section (discoveries, decisions, references)

4. **Generate comprehensive report covering**:

   **Current Work Context**:

   - What feature/task are we working on? (from DASHBOARD.md)
   - What phase/task/iteration are we in? (with status)
   - What was the original goal? (from PLAN.md + task Purpose)

   **Conversation History**:

   - What decisions were made during brainstorming? (from task file subjects)
   - What subjects were discussed and resolved? (with resolution types)
   - What pre-implementation tasks were identified and completed? (from task file)
   - What action items were generated? (from Implementation section)

   **Implementation Progress**:

   - What has been implemented so far? (from task file Implementation Notes)
   - What files were created/modified? (from Files Modified section)
   - What verification was done? (from Verification section)
   - What remains incomplete? (unchecked action items)

   **Challenges & Solutions**:

   - What blockers were encountered? (from Implementation Notes)
   - How were they resolved? (from Pre-Implementation Tasks or notes)
   - What design trade-offs were made? (from brainstorming rationale)

   **Next Steps**:

   - What is the immediate next action? (from DASHBOARD.md "üéØ Next Actions")
   - What are the pending action items? (from current iteration)
   - What should the next AI instance focus on?

   **Important Context**:

   - Any quirks or special considerations (from Task Notes)
   - Technical constraints (from PLAN.md + Task Overview dependencies)
   - User preferences or decisions that must be preserved (from decisions)

5. **Report format**:
```

# Context Transfer Report

## Generated: [Date/Time]

## Current Status

[Phase/Task/Iteration with status markers]

## Feature Overview

[What we're building and why]

## Conversation Summary

[Chronological summary of discussions and decisions]

## Implementation Progress

[What's done, what's in progress, what's pending]

## Key Decisions & Rationale

[Critical decisions made with reasoning]

## Files Modified

[List with brief description of changes]

## Challenges Encountered

[Problems and how they were solved]

## Next Actions

[Immediate next steps for new AI instance]

## Critical Context

[Must-know information for continuation]

```

5. **Important guidelines**:
- **Do NOT include generic project info** (tech stack, architecture overview, etc.)
- **Focus ENTIRELY on the feature at hand** and this conversation
- **Do NOT worry about token output length** - comprehensive is better than brief
- **Include WHY, not just WHAT** - decisions need context
- **Be specific** - reference exact file names, function names, line numbers
- **Preserve user preferences** - if user made specific choices, document them

6. **After generating report**:
- "Context transfer report generated. Copy this report to a new AI session to continue work with zero context loss."
- "Use `/flow-verify-plan` before starting new session to ensure plan files (DASHBOARD.md, task files) are synchronized."

**Manual alternative**:
- Read entire conversation history manually
- Read DASHBOARD.md for current status
- Read current task file for detailed context
- Read PLAN.md for architectural constraints
- Summarize key points, decisions, and progress
- Document in separate notes file

<!-- COMMAND_END -->
**Output**: Comprehensive context transfer report.
```

---

## Installation Instructions

To use these commands:

1. **Copy individual command files** to `.claude/commands/`:

   ```bash
   mkdir -p .claude/commands
   # Copy each command section above into separate .md files
   # Example: flow-blueprint.md, flow-phase.md, etc.
   ```

2. **Or use the copy-paste method**:

   - Copy the content between the code blocks for each command
   - Create corresponding `.md` files in `.claude/commands/`
   - File names should match command names (e.g., `flow-blueprint.md`)

3. **Test with `/help`**: Run `/help` in Claude Code to see your new commands listed

---

## Command Execution Flow

```
/flow-blueprint
    ‚Üì
Creates PLAN.md with skeleton
    ‚Üì
/flow-brainstorm_start
    ‚Üì
/flow-brainstorm-subject (repeat as needed)
    ‚Üì
/flow-brainstorm_resolve (for each subject)
    ‚Üì
Complete pre-implementation tasks (if any)
    ‚Üì
/flow-brainstorm_complete
    ‚Üì
/flow-implement-start
    ‚Üì
Work through action items (check them off)
    ‚Üì
/flow-implement-complete
    ‚Üì
Repeat for next iteration
```

**Helper commands** available at any time:

- `/flow-status` - Check current position
- `/flow-next` - Auto-advance to next step
- `/flow-rollback` - Undo last change
- `/flow-phase-add`, `/flow-task-add`, `/flow-iteration-add` - Add structure as needed
- `/flow-plan-split` - Archive old completed tasks to reduce PLAN.md size

---

## /flow-plan-split

**File**: `flow-plan-split.md`

```markdown
<!-- COMMAND_START -->
---
description: Archive old completed tasks to reduce PLAN.md size
---

You are executing the `/flow-plan-split` command from the Flow framework.

**Purpose**: Archive old completed tasks to reduce DASHBOARD.md clutter while preserving full project history in `archive/` directory.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from plan files**

- Moves completed task FILES to archive/ directory (keeps recent 3 tasks visible)
- Updates DASHBOARD.md and CHANGELOG.md to reflect archived tasks
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 2363-2560 for archival patterns

**Multi-File Architecture**: This command:
- Moves `phase-N/task-M.md` files to `archive/phase-N/task-M.md`
- Updates `DASHBOARD.md` to mark tasks as archived
- Updates `CHANGELOG.md` to reference archived task files

**Context**:

- **Framework Guide**: .flow/framework/DEVELOPMENT_FRAMEWORK.md (auto-locate in `.claude/`, project root, or `~/.claude/flow/`)
- **Working Files**: .flow/DASHBOARD.md, .flow/phase-N/task-M.md
- **Archive Directory**: .flow/archive/ (task files moved here)
- **Changelog**: .flow/CHANGELOG.md (updated with archive references)

**When to Use**: When DASHBOARD.md has 10+ completed tasks, causing clutter or difficult navigation.

**Archiving Strategy - Recent Context Window**:

- **Keep visible in DASHBOARD.md**: Current task + 3 previous tasks (regardless of status)
- **Archive**: All ‚úÖ COMPLETE tasks older than "current - 3"
- **Always Keep Visible**: Non-complete tasks (‚è≥ üöß ‚ùå üîÆ üé®) regardless of age

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìç Current Work" section
   - Extract current task number (e.g., Task 13)
   - Find "üìä Progress Overview" to list all tasks

2. **Calculate archiving threshold**:

   - Threshold = Current task number - 3
   - Example: Current = 13, Threshold = 10
   - **Archive candidates**: Tasks 1-9 (if ‚úÖ COMPLETE)
   - **Keep visible**: Tasks 10, 11, 12, 13 (current + 3 previous)

3. **Identify archivable tasks**:

   - Find all tasks with number < threshold AND status = ‚úÖ COMPLETE
   - List task files: `phase-N/task-M.md` for each archivable task
   - **IMPORTANT**: Keep non-complete tasks visible (‚è≥ üöß ‚ùå üîÆ üé®) even if old

4. **Move task files to archive**:

   - Create `archive/` directory if doesn't exist
   - For each archivable task:
     - Create phase directory in archive: `archive/phase-N/` if needed
     - Move `phase-N/task-M.md` to `archive/phase-N/task-M.md`
     - Preserve full task content (iterations, brainstorming, everything)

5. **Update CHANGELOG.md**:

   **If .flow/CHANGELOG.md does NOT exist** (first archive):

   ```markdown
   # Project Changelog

   This file contains historical records of completed tasks moved to archive.

   ## üì¶ Archived Tasks

   ### Phase N: [Phase Name]

   - **Task M**: [Task Name] - [archive/phase-N/task-M.md](archive/phase-N/task-M.md)
     - Completed: [Date]
     - Archived: [Date]

   ---

   **Last Updated**: [Date]
   **Total Archived**: [Count] tasks
   ```

   **If .flow/CHANGELOG.md ALREADY exists**:
   - Read existing CHANGELOG.md
   - Add new archived tasks under appropriate phase sections
   - Update "Last Updated" and "Total Archived" count
   - Maintain phase hierarchy (don't duplicate phase headers)

6. **Update DASHBOARD.md**:

   **A. Update Progress Overview**:
   - Add üì¶ marker to archived tasks
   - Format: `- ‚úÖüì¶ Task 5: Feature Name (archived)`
   - Keep task in list but mark as archived
   - Update completion percentages to reflect remaining visible tasks

   **B. Update phase headers** (if all phase tasks archived):
   ```markdown
   ### Phase 1: Foundation ‚úÖ COMPLETE

   **Goal**: [Phase goal]
   **Status**: 100% complete ([N] tasks archived to [archive/phase-1/](archive/phase-1/))
   ```

7. **Verify and confirm**:

   - Count archived files
   - Calculate DASHBOARD.md size reduction
   - Confirm to user:

     ```
     ‚úÖ Plan split complete!

     **Archived**: [X] tasks to .flow/archive/
     **Files moved**:
       - phase-1/task-1.md ‚Üí archive/phase-1/task-1.md
       - phase-1/task-2.md ‚Üí archive/phase-1/task-2.md
       ...

     **DASHBOARD.md**: Updated to mark [X] tasks as üì¶ archived
     **CHANGELOG.md**: Updated with archive references
     **Recent context**: Kept Task [threshold] through Task [current] visible

     Your Progress Dashboard still shows complete project history.
     Archived task files available in .flow/archive/
     ```

**Edge Cases**:

- **No old completed tasks**: "No tasks to archive. All completed tasks are within recent context window (current + 3 previous)."
- **Current task < 4**: "Current task is Task [N]. Need at least Task 4 to enable archiving (keeps current + 3 previous)."
- **Non-complete old tasks**: Keep visible in DASHBOARD.md: "Task [N] kept visible (not complete - status: [status])"

<!-- COMMAND_END -->
**Output**: Move task files to archive/, update DASHBOARD.md and CHANGELOG.md (full history preserved).

```

---

## /flow-backlog-add

**File**: `flow-backlog-add.md`

```markdown
<!-- COMMAND_START -->
---
description: Move task(s) to backlog to reduce active plan clutter
---

You are executing the `/flow-backlog-add` command from the Flow framework.

**Purpose**: Move pending tasks to BACKLOG.md to reduce active dashboard clutter while preserving all task content.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md and task files**

- Moves task files to backlog directory (token efficiency feature)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog management patterns

**Multi-File Architecture**: This command:
- Moves `phase-N/task-M.md` files to `backlog/` directory
- Updates `DASHBOARD.md` to remove tasks from active view
- Creates/updates `BACKLOG.md` with references to backogged tasks

**Key Insight**: Backlog is for **token efficiency**, not prioritization. Tasks aren't "low priority" - they're just "not now" (weeks/months away).

**Signature**: `/flow-backlog-add <task-number>` or `/flow-backlog-add <start>-<end>`

**Examples**:
- `/flow-backlog-add 14` - Move Task 14 to backlog
- `/flow-backlog-add 14-22` - Move Tasks 14 through 22 to backlog

**Instructions**:

1. **Read DASHBOARD.md**:
   - Find "üìä Progress Overview" section
   - Locate tasks by number

2. **Parse arguments**:
   - Single task: `task_numbers` = task number (e.g., "14")
   - Range: `task_numbers` = start-end (e.g., "14-22")
   - Extract task number(s) to move

3. **Validate tasks**:
   - Find task files: `phase-N/task-M.md`
   - Check task status - warn if moving tasks that are üöß IN PROGRESS or ‚úÖ COMPLETE
   - Recommended: Only move ‚è≥ PENDING tasks
   - If user confirms moving non-pending tasks, proceed

4. **Move task files to backlog**:
   - Create `backlog/` directory if doesn't exist
   - For each task:
     - Move `phase-N/task-M.md` to `backlog/phase-N-task-M.md`
     - Preserve all content (iterations, brainstorming, everything)

5. **Update BACKLOG.md**:

   **If BACKLOG.md does NOT exist** (first time):

   ```markdown
   # Project Backlog

   This file lists tasks moved to backlog/ directory to reduce active dashboard size.

   **Backlog Info**:
   - Task files moved to backlog/ directory
   - Tasks retain original numbers for easy reference
   - Full content preserved (brainstorming, iterations, everything)
   - Pull tasks back when ready to work on them

   **Last Updated**: [Current date]
   **Tasks in Backlog**: [Count]

   ---

   ## üìã Backlog Tasks

   - **Task [N]**: [Name] - [backlog/phase-N-task-M.md](backlog/phase-N-task-M.md)
   - **Task [N]**: [Name] - [backlog/phase-N-task-M.md](backlog/phase-N-task-M.md)
   ```

   **If BACKLOG.md ALREADY exists**:
   - Read existing BACKLOG.md
   - Update "Last Updated" timestamp
   - Update "Tasks in Backlog" count
   - Add tasks to "üìã Backlog Tasks" list

6. **Update DASHBOARD.md**:
   - Remove tasks from "üìä Progress Overview" section
   - Or mark as moved: `- ‚è≥ Task 14: Potency system (moved to backlog)`
   - Update completion percentages

7. **Reset task status to ‚è≥ PENDING** (in backlog files):
   - Open each backlog file
   - Change task status to ‚è≥ PENDING
   - Fresh start when pulled back

8. **Verify and confirm**:
   - Count moved files
   - Confirm to user:

     ```
     ‚úÖ Moved to backlog!

     **Backlogged**: [N] task(s) to backlog/ directory
     **Files moved**: Task [list of numbers]
     **Location**: backlog/phase-N-task-M.md

     Use `/flow-backlog-view` to see backlog contents.
     Use `/flow-backlog-pull <task-number>` to bring a task back when ready.
     ```

**Edge Cases**:
- **Task doesn't exist**: "Task [N] not found"
- **Invalid range**: "Invalid range format. Use: /flow-backlog-add 14-22"
- **Empty range**: "No tasks found in range 14-22"
- **Already in backlog**: Check backlog/ directory first, warn if task already there

<!-- COMMAND_END -->
**Output**: Move task files to backlog/ directory, update DASHBOARD.md and BACKLOG.md.

```

---

## /flow-backlog-view

**File**: `flow-backlog-view.md`

```markdown
<!-- COMMAND_START -->
---
description: Show backlog contents (tasks waiting)
---

You are executing the `/flow-backlog-view` command from the Flow framework.

**Purpose**: Display backlog showing all tasks currently in backlog directory.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from BACKLOG.md and backlog/ directory**

- Simple read operation (shows backlog list)
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog context

**Multi-File Architecture**: This command:
- Reads `BACKLOG.md` for task list
- Lists files in `backlog/` directory

**Instructions**:

1. **Check if BACKLOG.md exists**:
   - If NOT found: "üì¶ Backlog is empty. Use `/flow-backlog-add <task>` to move tasks."
   - If found: Proceed to step 2

2. **Read BACKLOG.md**:
   - Extract "Last Updated" timestamp
   - Extract "Tasks in Backlog" count
   - Read "üìã Backlog Tasks" section for task list

3. **Verify backlog/ directory**:
   - List files in `backlog/` directory
   - Confirm task files exist: `backlog/phase-N-task-M.md`

4. **Display backlog contents**:

   ```
   üì¶ Backlog Contents ([N] tasks):

   **Last Updated**: [Date]

   **Tasks Waiting**:
   - **Task 14**: Potency system - [backlog/phase-2-task-14.md](backlog/phase-2-task-14.md)
   - **Task 15**: Points & Luck systems - [backlog/phase-2-task-15.md](backlog/phase-2-task-15.md)
   - **Task 16**: Database persistence - [backlog/phase-3-task-16.md](backlog/phase-3-task-16.md)

   ---

   **Next Steps**:
   - Use `/flow-backlog-pull <task-number>` to move a task back to active work
   - Example: `/flow-backlog-pull 14` brings Task 14 back to its original phase
   ```

5. **Optional: Show task details** (if user wants more info):
   - Can read full task file from backlog/ on request
   - Default view is just list (lightweight)

<!-- COMMAND_END -->
**Output**: Display backlog list with task files and guidance.

```

---

## /flow-backlog-pull

**File**: `flow-backlog-pull.md`

```markdown
<!-- COMMAND_START -->
---
description: Pull task from backlog back into active plan
---

You are executing the `/flow-backlog-pull` command from the Flow framework.

**Purpose**: Move a task from BACKLOG.md back to PLAN.md with sequential renumbering in active phase.

**üü¢ NO FRAMEWORK READING REQUIRED - This command works from DASHBOARD.md, BACKLOG.md, and task files**

- Moves task file back from backlog/ to phase directory
- Optional background reading (NOT required): .flow/framework/DEVELOPMENT_FRAMEWORK.md lines 3407-3682 for backlog patterns

**Multi-File Architecture**: This command:
- Moves `backlog/phase-N-task-M.md` back to `phase-N/task-M.md`
- Updates `DASHBOARD.md` to show task
- Updates `BACKLOG.md` to remove task

**Signature**: `/flow-backlog-pull <task-number> [position]`

**Examples**:
- `/flow-backlog-pull 14` - Pull Task 14 back to its original phase
- `/flow-backlog-pull 14 add to phase 5` - Pull Task 14 to Phase 5 instead

**Instructions**:

1. **Check if BACKLOG.md exists**:
   - If NOT found: "üì¶ Backlog is empty. Nothing to pull."
   - If found: Proceed

2. **Parse arguments**:
   - Required: `task_number` - Task number to pull (e.g., "14")
   - Optional: `position` - Positioning instruction (e.g., "add to phase 5")

3. **Validate task exists in backlog**:
   - Read BACKLOG.md to find task entry
   - Find backlog file: `backlog/phase-N-task-M.md`
   - If NOT found: "Task [N] not found in backlog. Use `/flow-backlog-view` to see available."
   - If found: Proceed

4. **Determine target phase**:
   - **Default**: Use task's original phase (from filename `phase-N-task-M.md`)
   - **With position instruction**: Parse for target phase
     - "add to phase 5" ‚Üí Move to phase-5/
   - **If phase doesn't exist**: Create phase directory

5. **Determine new task number**:
   - List existing tasks in target phase
   - Find highest task number
   - New task number = highest + 1
   - Example: phase-2/ has task-1.md, task-2.md ‚Üí new task is task-3.md

6. **Move task file back**:
   - Move `backlog/phase-N-task-M.md` to `phase-N/task-K.md` (K = new number)
   - Update task metadata in file:
     - Update task number in header
     - Reset status to ‚è≥ PENDING
   - Preserve all content (iterations, brainstorming, everything)

7. **Update BACKLOG.md**:
   - Remove task from "üìã Backlog Tasks" list
   - Decrement "Tasks in Backlog" count
   - Update "Last Updated" timestamp

8. **Update DASHBOARD.md**:
   - Add task to "üìä Progress Overview" in target phase
   - Mark as ‚è≥ PENDING
   - Update phase task count
   - Update completion percentages

9. **Verify and confirm**:
   ```
   ‚úÖ Pulled from backlog!

   **Task**: Task [old-number] ‚Üí Task [new-number]
   **File**: backlog/phase-N-task-M.md ‚Üí phase-N/task-K.md
   **Phase**: Phase [N]: [Name]
   **Status**: ‚è≥ PENDING (ready to start)

   **Backlog**: [N-1] tasks remaining

   Use `/flow-task-start` to begin this task when ready.
   ```

**Edge Cases**:
- **Backlog empty**: "Backlog is empty. Nothing to pull."
- **Task not in backlog**: "Task [N] not in backlog."
- **Target phase doesn't exist**: Create phase directory
- **No active phase**: Ask user which phase to add task to

<!-- COMMAND_END -->
**Output**: Move task file from backlog/ to phase directory, update DASHBOARD.md and BACKLOG.md.

```

COMMANDS_DATA_EOF
}

get_framework_content() {
  cat <<'FRAMEWORK_DATA_EOF'
<!-- AI_SCAN:QUICK_REFERENCE:1-600 -->
# Quick Reference for AI (Read This First!!)

> **Purpose**: This section provides essential Flow framework knowledge in ~600 lines instead of reading the entire file. Read this first, then use the Section Index to jump to specific sections only when needed.

> **NEW in Multi-File Architecture**: Flow now uses separate files (`DASHBOARD.md`, `PLAN.md`, `phase-N/task-N.md`) instead of a single monolithic `PLAN.md`. All commands follow a **dashboard-first** navigation pattern.

---

<!-- AI_SCAN:MULTI_FILE_STRUCTURE:12-85 -->
## Multi-File Structure Overview

Flow uses a **multi-file architecture** where work is split across focused files:

```
.flow/
‚îú‚îÄ‚îÄ DASHBOARD.md              # ‚≠ê USER'S MAIN WORKSPACE (single source of truth for progress)
‚îú‚îÄ‚îÄ PLAN.md                   # üìñ Static context (overview, architecture, scope)
‚îú‚îÄ‚îÄ BACKLOG.md                # üì¶ Deferred/future tasks
‚îú‚îÄ‚îÄ ARCHIVE.md                # üóÑÔ∏è Completed work (created by /flow-plan-split)
‚îú‚îÄ‚îÄ phase-1/                  # üë§ USER'S WORK FILES
‚îÇ   ‚îú‚îÄ‚îÄ task-1.md            # üìù Task with iterations, brainstorming, implementation
‚îÇ   ‚îú‚îÄ‚îÄ task-2.md
‚îÇ   ‚îî‚îÄ‚îÄ task-3.md
‚îú‚îÄ‚îÄ phase-2/                  # üë§ USER'S WORK FILES
‚îÇ   ‚îú‚îÄ‚îÄ task-1.md
‚îÇ   ‚îî‚îÄ‚îÄ task-2.md
‚îî‚îÄ‚îÄ framework/                # ü§ñ AI REFERENCE FILES (read-only for user)
    ‚îú‚îÄ‚îÄ DEVELOPMENT_FRAMEWORK.md  # üéì Complete methodology guide
    ‚îî‚îÄ‚îÄ examples/             # üìö Example files for AI to learn from
        ‚îú‚îÄ‚îÄ DASHBOARD.md
        ‚îú‚îÄ‚îÄ PLAN.md
        ‚îú‚îÄ‚îÄ phase-1/
        ‚îÇ   ‚îî‚îÄ‚îÄ task-1.md
        ‚îî‚îÄ‚îÄ phase-2/
            ‚îî‚îÄ‚îÄ task-3.md
```

### File Purposes

**üë§ USER'S FILES** (What you work in):

**DASHBOARD.md** (‚≠ê Most Important - Single Source of Truth):
- User spends most time here
- Shows current work pointer (Phase/Task/Iteration)
- Displays progress overview with ALL phases/tasks/iterations
- Key decisions needing user input
- **This is the ONLY place progress is tracked** - no duplication

**PLAN.md** (Static Context - Rarely Changes):
- Like CLAUDE.md but for this specific feature/project
- Purpose, Goals (text only, no checklists), Scope (V1 only)
- Architecture overview
- DO/DON'T guidelines
- Minimal and focused - no assumptions about future work

**phase-N/task-N.md** (Work Files - All Tasks Have Iterations):
- Contains task overview and dependencies
- **All tasks have iterations** (no standalone tasks)
- Each iteration has: Pre-tasks (optional) ‚Üí Brainstorming (optional) ‚Üí Action Items
- One Action Items section per iteration
- Brainstorming subjects produce "Resolution Items" ‚Üí consolidated into Action Items

**BACKLOG.md** (Future Work):
- Tasks moved out of active plan
- Deferred features
- V2/V3 items (if user explicitly wants to track them)

**ARCHIVE.md** (Completed Work):
- Created by `/flow-plan-split`
- Archives all completed tasks
- Task files become references: "See ARCHIVE.md"

**ü§ñ AI REFERENCE FILES** (Read-only, for AI agents):

**framework/DEVELOPMENT_FRAMEWORK.md** (This File):
- Complete Flow methodology
- Templates, patterns, best practices
- AI reads this to understand how Flow works

**framework/examples/** (Example Project):
- Real example of Flow in use (payment gateway project)
- AI learns patterns from these examples
- Shows DASHBOARD.md, PLAN.md, and task file formats

---

<!-- AI_SCAN:CORE_HIERARCHY:88-110 -->
## Core Hierarchy

```
PHASE ‚Üí TASK ‚Üí ITERATION ‚Üí BRAINSTORM ‚Üí IMPLEMENTATION ‚Üí COMPLETE
```

**Structure**:
- **PHASE**: High-level milestone (e.g., "Core Implementation", "Testing")
  - Lives in: DASHBOARD.md (overview) + `phase-N/` directory
- **TASK**: Feature/component to build (e.g., "Database Schema", "API Endpoints")
  - Lives in: `phase-N/task-N.md` file
- **ITERATION**: Incremental buildout (e.g., "V1: Basic validation", "V2: Advanced rules")
  - Lives in: Inside task file (`phase-N/task-N.md`)
- **BRAINSTORM**: Design before code (subjects ‚Üí decisions ‚Üí action items)
  - Lives in: Inside iteration section of task file
- **IMPLEMENTATION**: Execute action items from brainstorming
  - Lives in: Inside iteration section of task file

**Golden Rule**: Brainstorm ‚Üí Pre-Tasks ‚Üí Implementation (never skip brainstorming for complex work)

---

<!-- AI_SCAN:DASHBOARD_FIRST_PATTERN:113-165 -->
## Dashboard-First Navigation Pattern

**ALL commands follow this pattern**:

```
1. Read DASHBOARD.md (source of truth)
2. Extract current context:
   - Phase: Phase N
   - Task: Task M (in phase-N/ directory)
   - Iteration: Iteration K
3. Navigate to task file: phase-N/task-M.md
4. Perform operation (read/edit task file)
5. Update DASHBOARD.md with new state
```

**Example: `/flow-implement-start`**:
```
1. Read DASHBOARD.md
   ‚Üí Current: Phase 2, Task 3, Iteration 2
2. Construct path: phase-2/task-3.md
3. Read phase-2/task-3.md
   ‚Üí Find Iteration 2 section
4. Add Implementation subsection
5. Update DASHBOARD.md:
   - Change Iteration 2 status: ‚è≥ ‚Üí üöß
   - Update "Current Work" pointer
```

**Why Dashboard-First?**
- Single source of truth for project state
- User always knows where they are
- Commands don't need to search multiple files
- Consistent navigation across all commands

**Key Insight**: DASHBOARD.md is like an index - it tells you WHERE to find detailed work (which task file, which iteration).

---

<!-- AI_SCAN:STATUS_MARKERS:168-195 -->
## Status Markers

| Marker | Meaning | When to Use |
|--------|---------|-------------|
| ‚úÖ | COMPLETE | Finished and verified (frozen, skip re-verification) |
| ‚è≥ | PENDING | Not started yet |
| üöß | IN PROGRESS | Currently working on this |
| üé® | READY | Brainstorming done, ready to implement |
| ‚ùå | CANCELLED | Decided against (must document WHY) |
| üîÆ | DEFERRED | Moved to V2/V3/later (must document WHY + WHERE - usually moved to BACKLOG.md) |
| üéØ | ACTIVE | Current focus (optional, used in DASHBOARD.md) |

**Rules**:
- Every Phase/Task/Iteration/Subject MUST have a status marker
- ‚úÖ COMPLETE items are verified & frozen (skip re-verification)
- ‚ùå CANCELLED and üîÆ DEFERRED must document reason
- Status appears in BOTH:
  - DASHBOARD.md (for overview)
  - Task file header (phase-N/task-M.md)

**Status Lifecycle**:
```
‚è≥ PENDING ‚Üí üöß IN PROGRESS ‚Üí ‚úÖ COMPLETE
                ‚Üì
              üé® READY (for iterations with brainstorming)
```

---

<!-- AI_SCAN:TASK_STRUCTURE_QUICK:198-270 -->
## Task Structure Rules

**The Golden Rule**: **ALL tasks have iterations** - this provides consistent structure and enables iterative development.

### Task with Iterations (The Only Pattern)

**File**: `phase-N/task-N.md`
```markdown
# Task 3: Implement Payment Gateway

**Status**: üöß IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate Stripe API for payment processing

---

## Task Overview

Build production-ready payment gateway integration.

**Why This Task**: Current system has no payment processing capability.

**Dependencies**:
- Requires: Task 1 (Database Layer)
- Blocks: Task 4 (Subscription System)

---

## Iterations

### ‚úÖ Iteration 1: API Setup

**Goal**: Configure Stripe SDK and credentials
**Status**: ‚úÖ COMPLETE

[Brainstorming ‚Üí Action Items ‚Üí Implementation sections below]

---

### üöß Iteration 2: Payment Processing

**Goal**: Implement charge creation and webhooks
**Status**: üöß IN PROGRESS

[Currently brainstorming...]
```

**Why iterations-only**:
- Consistent structure across all tasks
- Enables human-in-loop iteration (plan ‚Üí brainstorm ‚Üí implement ‚Üí complete)
- Clear progress tracking (iteration status)
- Simple tasks just have 1-2 iterations with action items
- Complex tasks have multiple iterations with brainstorming

**Structure per iteration**:
1. **Pre-Implementation Tasks** (optional) - Quick fixes before starting
2. **Brainstorming Session** (optional) - Design decisions ‚Üí Resolution Items
3. **Action Items** (required) - ONE list per iteration, consolidated from brainstorming or direct
4. **Implementation** - Track work, files modified, discoveries

---

<!-- AI_SCAN:SUBJECT_RESOLUTION:273-300 -->
## Subject Resolution Types

When brainstorming (inside task file), every resolved subject falls into ONE of these types:

| Type | Name | When | Action | Example |
|------|------|------|--------|---------|
| **A** | Pre-Implementation Task | Small code changes needed BEFORE iteration | Create pre-task (< 30 min work) | Fix interface, rename file, update enum |
| **B** | Immediate Documentation | Architectural decision, no code yet | Update PLAN.md Architecture section NOW | Design pattern choice, API contract |
| **C** | Auto-Resolved | Answered by another subject's decision | Mark as resolved by Subject N | Cascade decisions |
| **D** | Iteration Action Items | Substantial feature work that IS the iteration | Create "Resolution Items" list in subject | Build API endpoint, implement validator |

**Decision Flow**:
1. Does subject require code changes?
   - **NO** ‚Üí Type B (Documentation) or Type C (Auto-resolved)
   - **YES** ‚Üí Continue to #2
2. Is it small quick task (< 30 min)?
   - **YES** ‚Üí Type A (Pre-task)
   - **NO** ‚Üí Type D (Resolution Items ‚Üí Action Items)

**Where They Live**:
- Type B decisions ‚Üí Update `PLAN.md` Architecture section immediately
- Type A pre-tasks ‚Üí Pre-Implementation Tasks section (before brainstorming complete)
- Type D Resolution Items ‚Üí Listed in subject, then `/flow-brainstorm-review` consolidates them into iteration's Action Items section

**Key Insight**: Brainstorming creates "Resolution Items" per subject. The `/flow-brainstorm-review` command consolidates all Resolution Items ‚Üí single Action Items list per iteration.

---

<!-- AI_SCAN:COMMON_PATTERNS:303-410 -->
## Common Patterns Quick Reference

### Creating a New Project

```bash
# Option 1: From scratch
/flow-blueprint

# Option 2: Convert existing docs
/flow-migrate

# Option 3: Convert old single-file PLAN.md
/flow-plan-update
```

**Result**: Creates DASHBOARD.md, PLAN.md, phase-1/ directory with initial task files

---

### Starting Work on a Phase

```bash
/flow-phase-add "Phase 2: Core Implementation"
/flow-phase-start
```

**Files Created/Updated**:
- `phase-2/` directory created
- DASHBOARD.md updated with new phase section

---

### Adding a Task

```bash
/flow-task-add "API Integration"
```

**Files Created/Updated**:
- `phase-N/task-M.md` created (N = current phase, M = next task number)
- DASHBOARD.md updated with new task entry

---

### Working on an Iteration

```bash
# 1. Add iteration to current task
/flow-iteration-add "Error Handling"

# 2. Start brainstorming
/flow-brainstorm-start

# 3. Resolve subjects one by one
/flow-next-subject
# [Discuss subject, choose Type A/B/C/D, document decision]

# 4. After all subjects resolved, review
/flow-brainstorm-review
# [AI suggests iterations/pre-tasks based on decisions]

# 5. Complete any pre-tasks, then close brainstorming
/flow-brainstorm-complete

# 6. Start implementation
/flow-implement-start

# 7. Do the work...

# 8. Complete implementation
/flow-implement-complete
```

**Files Updated**:
- Current `phase-N/task-M.md` (brainstorming, implementation sections added)
- DASHBOARD.md (status updates throughout)
- Possibly PLAN.md (if Type B decisions made)

---

### Checking Status

```bash
/flow-status
```

**Result**: Reads DASHBOARD.md, shows formatted current state
- Current work pointer
- Progress overview

**This is the REFERENCE MODEL command** - simple dashboard read, no complex logic needed.

---

### Finding Next Work

```bash
/flow-next
```

**Logic**:
1. Read DASHBOARD.md
2. Check current iteration status
3. Suggest appropriate next command based on state

---

<!-- AI_SCAN:BRAINSTORMING_WORKFLOW:413-480 -->
## Brainstorming Workflow Pattern

**Context**: Happens inside `phase-N/task-M.md` file, within an iteration section.

### Structure in Task File

```markdown
### üöß Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling

**Status**: üöß IN PROGRESS (Brainstorming)

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design retry logic, error recovery patterns

**Subjects to Discuss**:
1. ‚è≥ Retry Strategy
2. ‚è≥ Circuit Breaker Pattern
3. ‚è≥ Error Logging

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: Retry Strategy

**Decision**: Use exponential backoff with 3 retries

**Resolution Type**: D (Iteration Action Items)

**Rationale**: Balances reliability with user experience

**Action Items**:
- [ ] Implement RetryPolicy class
- [ ] Add exponential backoff logic
- [ ] Configure max retry count

---

##### ‚úÖ Subject 2: Circuit Breaker Pattern

**Decision**: Skip circuit breaker for V1, defer to V2

**Resolution Type**: B (Documentation)

**Rationale**: V1 scope is tight, circuit breaker adds complexity

**Documentation Update**: Added to PLAN.md V2 scope
```

### Workflow Commands

1. **Start**: `/flow-brainstorm-start`
   - Adds brainstorming section to current iteration
   - Creates "Subjects to Discuss" list

2. **Resolve**: `/flow-next-subject`
   - Picks next ‚è≥ subject
   - Discuss with user
   - Document decision + choose Type A/B/C/D
   - Add action items if needed

3. **Review**: `/flow-brainstorm-review` (CRITICAL STEP!)
   - After all subjects resolved
   - AI analyzes all decisions
   - Suggests if more iterations needed
   - Identifies pre-implementation tasks
   - **Always suggest this BEFORE /flow-brainstorm-complete**

4. **Complete**: `/flow-brainstorm-complete`
   - Marks brainstorming ‚úÖ COMPLETE
   - Changes iteration status to üé® READY
   - Only call AFTER completing pre-tasks

---

<!-- AI_SCAN:PRE_IMPLEMENTATION_PATTERN:483-540 -->
## Pre-Implementation Tasks Pattern

**Context**: Discovered during brainstorming (Type A subjects). Must be completed BEFORE starting iteration implementation.

### Structure in Task File

```markdown
### üöß Iteration 2: Error Handling

[... Brainstorming section above ...]

---

#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

##### ‚è≥ Pre-Task 1: Refactor Legacy Error Handler

**Why Blocking**: Current ErrorHandler doesn't support async retry logic

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async
- Add retryAsync() method
- Update 3 existing call sites

**Files**:
- src/utils/ErrorHandler.ts
- src/services/BillingService.ts
- tests/utils/ErrorHandler.test.ts

**Test**: Run existing tests to ensure no regressions

---

##### ‚úÖ Pre-Task 2: Update Type Definitions

**Completed**: 2025-01-15

**Changes Made**:
- Added ErrorType enum
- Updated function signatures
- All tests passing
```

### Workflow

1. During brainstorming, identify Type A subjects (small < 30 min tasks)
2. `/flow-brainstorm-review` creates pre-implementation tasks section
3. Complete all pre-tasks (mark each ‚úÖ with completion date)
4. Only then call `/flow-brainstorm-complete`
5. Then call `/flow-implement-start`

**Why This Matters**: Pre-tasks unblock the main implementation. Doing them early prevents getting stuck mid-iteration.

---

<!-- AI_SCAN:SECTION_INDEX:543-600 -->
## Section Index (Use Read Tool with Offset/Limit)

**How to Use**: When you need deep details, use `Read(file_path, offset=X, limit=Y)` to read ONLY the specific section.

### Quick Reference Sections (You Just Read These!)
- Lines 1-600: This Quick Reference (current section)

### Core Framework Sections
- Lines 601-850: **Framework Philosophy & Principles**
  - Domain-Driven Design approach
  - Agile iterative philosophy
  - When to use Flow

- Lines 851-1100: **Multi-File Architecture Deep Dive**
  - File responsibilities in detail
  - Cross-file references
  - Directory structure rules
  - File naming conventions

- Lines 1101-1400: **Task Structure Rules (Complete Guide)**
  - Iterations-only architecture
  - When to split tasks
  - Task size guidelines
  - Nested iteration patterns

- Lines 1401-1700: **Brainstorming Pattern (Complete Guide)**
  - Full brainstorming workflow
  - Subject resolution types deep dive
  - Pre-implementation task patterns
  - Bugs discovered pattern

- Lines 1701-1900: **Implementation Pattern (Complete Guide)**
  - Implementation structure
  - Notes and discoveries
  - Verification checklist
  - When to mark complete

- Lines 1901-2100: **Status Management**
  - Status marker lifecycle
  - State transitions
  - Common pitfalls
  - Recovery from incorrect states

- Lines 2101-2600: **File Templates**
  - DASHBOARD.md template (complete)
  - PLAN.md template (complete)
  - task-N.md template (complete)
  - Copy-paste ready templates

- Lines 2601-2900: **Command Patterns**
  - Dashboard-first navigation (detailed)
  - Structure creation pattern
  - Full traversal pattern
  - Cross-file search pattern

- Lines 2901-3200: **Complete Workflow Examples**
  - Full feature implementation walkthrough
  - File updates at each step
  - Real-world example with payment gateway

- Lines 3201-3500: **Backlog Management**
  - BACKLOG.md structure
  - Moving tasks to backlog
  - Pulling tasks back
  - Archiving with /flow-plan-split

- Lines 3501-3800: **Best Practices & Pitfalls**
  - Common mistakes
  - How to recover
  - Performance tips
  - Multi-developer workflows

---

**End of Quick Reference** - Continue reading below for complete framework documentation ‚Üí


<!-- AI_SCAN:FRAMEWORK_PHILOSOPHY:620-850 -->
# Framework Philosophy & Principles

## What is Flow?

Flow is a **specification-driven iterative development methodology** that combines:
- **Domain-Driven Design** principles (understand before building)
- **Agile philosophy** (iterative shipping, adapt to feedback)
- **Progressive disclosure** (V1 ‚Üí V2 ‚Üí V3, defer complexity)

### Core Metaphor: Building a Human Body

**Skeleton** (Phase 1) ‚Üí **Veins** (Phase 2) ‚Üí **Flesh** (Phase 3) ‚Üí **Fibers** (Phase 4)

- **Skeleton**: Basic structure and foundation
  - Minimal working version
  - Core data models
  - Basic happy path

- **Veins**: Core data flow and connections
  - Main feature workflows
  - Critical integration points
  - Error handling basics

- **Flesh**: Incremental complexity
  - Additional features
  - Edge cases
  - Performance optimization

- **Fibers**: Refinement and optimization
  - Polish and UX improvements
  - Advanced edge cases
  - Production hardening

### Multi-File Architecture Philosophy

**Problem**: Monolithic `PLAN.md` files grow to 500-5000+ lines, becoming:
- Hard to navigate
- Slow to load/edit
- Git merge nightmares
- Context overload for AI

**Solution**: Split into focused files:
- **DASHBOARD.md**: User's active workspace (what's happening NOW)
- **PLAN.md**: Static context (WHY we're building this, HOW it fits together)
- **phase-N/task-N.md**: Detailed work files (what's IN each task)
- **BACKLOG.md**: Future work (what's DEFERRED)

**Benefits**:
- Smaller files = faster to read/edit
- Each file has single responsibility
- Git conflicts are localized
- AI can focus on relevant file only
- User knows where to look for information

### When to Use Flow

**‚úÖ Use Flow For**:
- Complex features requiring design decisions
- Multi-phase projects (> 2 weeks)
- Features with unclear requirements (need exploration)
- Team projects (shared context needed)
- Features requiring iterative refinement

**‚ùå Don't Use Flow For**:
- Simple bug fixes (< 1 hour)
- Trivial features (< 5 steps)
- Well-defined copy-paste implementations
- One-off scripts

### Key Principles

#### 1. Plan-Before-Code

**Never start coding without understanding the problem domain.**

- Brainstorming is NOT optional for complex work
- Document decisions and rationale
- Identify pre-implementation tasks early
- Update architecture documentation (PLAN.md) for major decisions

#### 2. Context Preservation

**The plan files ARE the memory of the project.**

- DASHBOARD.md: Current state (always up-to-date)
- PLAN.md: Static context (reference docs)
- Task files: Complete work history per task
- CHANGELOG.md: Historical decisions
- Everything is documented, nothing is forgotten

#### 3. Iterative Refinement

**Ship V1, then V2, then V3 - don't try to build perfect V1.**

- V1: Minimum viable (skeleton + veins)
- V2: Enhancements (flesh)
- V3: Optimization (fibers)
- Defer complexity to later versions

#### 4. Progressive Disclosure

**Focus only on what's needed NOW.**

- Each iteration is focused and shippable
- Don't design V3 during V1 brainstorming
- Document V2/V3 ideas in PLAN.md or BACKLOG.md
- Revisit deferred decisions when actually needed

#### 5. State Preservation

**Status markers track progress across sessions.**

- ‚úÖ COMPLETE: Frozen, verified, skip re-verification
- üöß IN PROGRESS: Currently active work
- ‚è≥ PENDING: Not started yet
- üé® READY: Brainstorming done, ready to code
- Status in both DASHBOARD.md (overview) and task files (details)

#### 6. Dashboard-First Navigation

**DASHBOARD.md is the single source of truth for "where are we?"**

- All commands read DASHBOARD.md first
- Dashboard points to current task file
- Task file contains detailed work
- Consistent navigation pattern across all commands

---

<!-- AI_SCAN:MULTI_FILE_ARCHITECTURE:852-1100 -->
# Multi-File Architecture Deep Dive

## File Responsibilities

### DASHBOARD.md (Progress Tracking)

**Purpose**: User's main workspace - shows current work and overall progress

**Sections**:
1. **Current Work** - Pointer to active Phase/Task/Iteration
2. **Progress Overview** - All phases with task completion status
3. **Key Decisions** - Outstanding decisions needing user input
4. **Success Criteria** - Definition of done for phases
5. **Related Resources** - Links to docs, examples

**Update Frequency**: Every command that changes state

**User Interaction**: User reads this constantly to understand where they are

**Example Structure**:
```markdown
# Project Dashboard

**Last Updated**: 2025-01-15 14:30

## üìç Current Work
- **Phase**: [Phase 2 - Core Implementation](phase-2/)
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
- **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) üöß

## üìä Progress Overview

### Phase 1: Foundation ‚úÖ COMPLETE
- ‚úÖ Task 1: Project Setup (3/3 iterations)
- ‚úÖ Task 2: Core Models (2/2 iterations)

### Phase 2: Core Implementation üöß IN PROGRESS (2/5 tasks)
- ‚úÖ Task 1: Database Layer (2/2 iterations)
- ‚úÖ Task 2: Business Logic (3/3 iterations)
- üöß Task 3: API Integration (1/4 iterations) ‚Üê CURRENT
- ‚è≥ Task 4: Authentication
- ‚è≥ Task 5: Caching Layer


## üí° Key Decisions

**Decision Needed**: Should Skills be included in flow.sh or distributed separately?
- Option A: Include in flow.sh (150KB ‚Üí 180KB) - Users get Skills automatically, easier onboarding
- Option B: Separate distribution (skills.zip) - Keeps flow.sh lean, users opt-in to Skills
- **Recommendation**: Option A - Skills are lightweight (~30KB total), automatic deployment enhances AI experience

**Decision Needed**: Which Skills to create first?
- Option A: Start with 3 core Skills (navigator, planner, implementer) - MVP approach, faster testing
- Option B: Create all 6 Skills upfront - Complete experience from day 1, but longer Phase 2
- **Recommendation**: Option A - Iterate on core 3, add remaining 3 based on real usage feedback

**Resolved**:
- **2025-10-30**: Skills Complement Commands - Skills = model-invoked (AI decides when), Commands = user-invoked (human triggers explicitly). This maintains human-in-loop philosophy.
- **2025-10-30**: Human Still Drives - Skills give AI *awareness* of Flow patterns, not *authority* to make architectural decisions. Descriptions emphasize "when user wants..." patterns.

---

## üéØ Success Criteria

**Phase 1 Complete When**:
- `.claude/skills/` directory structure exists
- Skill templates documented in framework/
- build-standalone.sh embeds Skills in flow.sh
- Skills deploy correctly to test project

**Phase 2 Complete When**:
- 6 Core Skills created with SKILL.md files
- Each Skill has clear description triggering appropriate context
- Skills reference framework patterns correctly
- Skills tested individually

**Phase 3 Complete When**:
- Skills activate based on user requests (not manual invocation)
- Real-world workflow test completed (plan ‚Üí implement ‚Üí complete)
- Documentation updated (README, new SKILLS.md guide)
- Example Skills added to framework/examples/

---

## üìö Related Resources

- **Agent Skills Documentation**: https://docs.claude.com/en/docs/claude-code/skills
- **Flow Framework**: framework/DEVELOPMENT_FRAMEWORK.md
- **Slash Commands**: framework/SLASH_COMMANDS.md
- **Build System**: build-standalone.sh (deployment logic)

```

### PLAN.md (Static Context)

**Purpose**: Like CLAUDE.md but for this specific feature/project

**Sections**:
1. **Overview** - Purpose, Goals, Scope (V1/V2/V3)
2. **Architecture** - System design, components, data flow
3. **Testing Strategy** - How to test this feature
4. **Development Phases** - High-level phase descriptions (NOT detailed tasks)

**Update Frequency**: Rarely (only when architecture changes or Type B brainstorming decisions)

**User Interaction**: User reads at start of project, refers back occasionally

**Key Insight**: This is the "WHY" and "HOW" documentation - it explains the big picture

**Example Structure**:
```markdown
# Payment Gateway Integration - Development Plan

> **üìç Current Progress**: See [DASHBOARD.md](DASHBOARD.md)
> **üéØ Purpose**: Integrate Stripe payment processing

**Created**: 2025-01-10
**Version**: V1

## Overview

### Purpose
Build production-ready payment gateway integration supporting credit cards and subscriptions.

### Goals
- [ ] Process credit card payments via Stripe API
- [ ] Handle webhook events for async notifications
- [ ] Implement retry logic for failed payments

### Scope

**V1 (Included)**:
- Credit card payment processing
- Basic subscription support
- Webhook handler
- Retry logic (3 attempts)

**V2 (Future)**:
- ACH/bank transfer support
- Multi-currency
- Saved payment methods

## Architecture

### System Design

**Components**:
- `PaymentService` - Core payment orchestration
- `StripeClient` - API wrapper with retry logic
- `WebhookHandler` - Event processing
- `PaymentRepository` - Database persistence

### Data Flow
[Diagram or description]

## Testing Strategy

**Methodology**: Simulation-based per-service testing
**Location**: `scripts/` directory
**Naming**: `{service}.scripts.ts`

## Development Phases

### Phase 1: Foundation
Setup project structure and dependencies

### Phase 2: Core Implementation
Build payment processing functionality

### Phase 3: Testing & Hardening
Comprehensive testing and edge cases
```

### phase-N/task-N.md (Work Files)

**Purpose**: Container for all work related to a specific task

**Sections**:
1. **Task Header** - Status, Phase link, Purpose
2. **Task Overview** - Description, dependencies, why this task
3. **Iterations** - All tasks have iterations (1+ iterations per task)
4. **Task Notes** - Discoveries, decisions, references

**Update Frequency**: Constantly during work on this task

**User Interaction**: User works in this file during active development

**Key Insight**: This is the "WHAT" and "HOW SPECIFICALLY" - all the detailed work

**Example Structure** (Task with Iterations):
```markdown
# Task 3: API Integration

**Status**: üöß IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API

---

## Task Overview

Build robust Stripe API client with error handling and retry logic.

**Why This Task**: Need payment processing capability

**Dependencies**:
- Requires: Task 1 (Database Layer)
- Blocks: Task 4 (Authentication)

---

## Iterations

### ‚úÖ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper

**Status**: ‚úÖ COMPLETE

[Brainstorming, Implementation sections below]

---

### üöß Iteration 2: Error Handling

**Goal**: Implement error handling

**Status**: üöß IN PROGRESS

[Currently working on this iteration]

---

## Task Notes

**Discoveries**:
- Stripe SDK handles connection pooling automatically

**Decisions**:
- Using Stripe Node SDK v12.x

**References**:
- Stripe API Docs: https://stripe.com/docs/api
```

### BACKLOG.md (Future Work)

**Purpose**: Storage for deferred tasks and V2/V3 features

**Sections**:
1. **Backlog Dashboard** - Summary of backlog items
2. **Backlog Items** - Deferred tasks with reasoning

**Update Frequency**: When moving tasks out of active plan or adding future work

**Example Structure**:
```markdown
# Project Backlog

## üìã Backlog Dashboard

**Total Items**: 8
**V2 Features**: 5
**V3 Features**: 2
**Deferred Bugs**: 1

## Backlog Items

### ‚è≥ Task: Multi-Currency Support

**Originally Planned**: Phase 2, Task 6
**Deferred To**: V2
**Reasoning**: V1 scope focuses on USD only, multi-currency adds significant complexity
**Estimated Effort**: 2 weeks
**Dependencies**: Core payment processing complete
```

### CHANGELOG.md (History)

**Purpose**: Historical record of completed work

**Example**:
```markdown
# Changelog

## [V1.2.0] - 2025-01-15
### Added
- Retry logic for failed payments
- Webhook signature validation

### Fixed
- Race condition in payment processing

## [V1.1.0] - 2025-01-10
### Added
- Basic payment processing
- Stripe API integration
```

### ARCHIVE.md (Completed Work)

**Purpose**: Created by `/flow-plan-split` - archives completed tasks

**Structure**: Flat list of completed tasks with all iterations

**Effect**: Original task files become references:
```markdown
# Task 1: Project Setup

**Status**: ‚úÖ COMPLETE (Archived)

See [ARCHIVE.md](../ARCHIVE.md#task-1-project-setup) for complete details.
```

## Cross-File References

### Linking Between Files

**Dashboard ‚Üí Task File**:
```markdown
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
```

**Task File ‚Üí Dashboard**:
```markdown
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
```

**Task File ‚Üí PLAN.md**:
```markdown
See [PLAN.md Architecture section](../PLAN.md#architecture) for system design
```

**PLAN.md ‚Üí Backlog**:
```markdown
Multi-currency support deferred to V2 (see [BACKLOG.md](BACKLOG.md))
```

### Reference Patterns

**Current Work Pointer** (in DASHBOARD.md):
```markdown
## üìç Current Work
- **Phase**: Phase 2 - Core Implementation
- **Task**: Task 3 - API Integration
- **Iteration**: Iteration 2 - Error Handling
- **File**: [phase-2/task-3.md](phase-2/task-3.md#iteration-2-error-handling)
```

This pointer is the SOURCE OF TRUTH for "where are we right now?"

## Directory Structure Rules

### Phase Directories

**Naming**: `phase-N/` where N is the phase number (1, 2, 3, ...)
**Created**: When `/flow-phase-add` is run
**Contains**: Task files for that phase

```
phase-1/
‚îú‚îÄ‚îÄ task-1.md
‚îú‚îÄ‚îÄ task-2.md
‚îî‚îÄ‚îÄ task-3.md
```

### Task File Naming

**Format**: `task-N.md` where N is the task number within the phase
**Numbering**: Sequential within each phase (task-1, task-2, task-3, ...)
**Name in Content**: Task file contains descriptive name in header

**Example**:
- File: `phase-2/task-3.md`
- Header: `# Task 3: API Integration`

### File Naming Conventions

**DO**:
- ‚úÖ Use `phase-N/` for phase directories
- ‚úÖ Use `task-N.md` for task files
- ‚úÖ Keep all Flow files in `.flow/` directory
- ‚úÖ Use lowercase for filenames

**DON'T**:
- ‚ùå Don't put task name in filename (`task-3-api-integration.md`)
- ‚ùå Don't nest deeper than `phase-N/task-N.md`
- ‚ùå Don't create subdirectories under phase directories


<!-- AI_SCAN:TASK_STRUCTURE_COMPLETE:1101-1400 -->
# Task Structure Rules (Complete Guide)

## The Golden Rule

**ALL Tasks Have Iterations**

This provides consistent structure and enables human-in-loop iterative development.

## Why Iterations-Only?

- **Consistent structure** - Every task follows same pattern, easier to navigate
- **Human-in-loop** - Enables plan ‚Üí brainstorm ‚Üí implement ‚Üí complete cycle
- **Progress tracking** - Clear iteration status shows where you are
- **Flexibility** - Simple tasks have 1-2 iterations, complex tasks have many
- **No special cases** - One pattern to learn and follow

## Task Pattern (The Only Pattern)

**File**: `phase-N/task-N.md`

### Complete Example

```markdown
# Task 3: API Integration

**Status**: üöß IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API for payment processing

---

## Task Overview

Build robust Stripe API client with error handling, retry logic, and webhooks.

**Why This Task**: Core payment functionality depends on reliable API integration.

**Dependencies**:
- **Requires**: Task 1 (Database Layer) - need PaymentRepository
- **Requires**: Task 2 (Business Logic) - need PaymentService interface
- **Blocks**: Task 4 (Authentication) - auth tokens stored via this API

**Estimated Complexity**: High (3-4 iterations expected)

---

## Iterations

### ‚úÖ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper with authentication

**Status**: ‚úÖ COMPLETE (2025-01-12)

---

#### Brainstorming Session - REST Client Architecture

**Focus**: Design API client abstraction and authentication flow

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: Client Architecture Pattern

**Decision**: Use singleton pattern with lazy initialization

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe SDK maintains connection pool internally
- Multiple instances would create redundant connections
- Lazy init delays credential validation until first use

**Resolution Items**:
- Create `StripeClient` singleton class
- Implement lazy initialization in constructor
- Add credential validation on first API call

---

##### ‚úÖ Subject 2: Authentication Flow

**Decision**: Use API key from environment variable with validation

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Follows Stripe best practices
- Supports different keys per environment
- Fails fast if key missing or invalid

**Resolution Items**:
- Load `STRIPE_API_KEY` from env
- Validate key format at startup
- Throw clear error if key missing

---

#### Action Items

(Consolidated from Resolution Items above by `/flow-brainstorm-review`)

- [x] Create `StripeClient` singleton class
- [x] Implement lazy initialization in constructor
- [x] Add credential validation on first API call
- [x] Load `STRIPE_API_KEY` from env
- [x] Validate key format at startup
- [x] Throw clear error if key missing

---

#### Implementation - Iteration 1: REST Client Setup

**Status**: ‚úÖ COMPLETE (2025-01-12)

**Implementation Notes**:
- Created `src/payment/StripeClient.ts` with singleton pattern
- Implemented environment-based key loading
- Added validation for API key format (starts with `sk_`)
- Discovered bug in existing error handling (see Pre-Implementation Tasks in Iteration 2)

**Files Modified**:
- `src/payment/StripeClient.ts` - Created (142 lines)
- `src/config/env.ts` - Added STRIPE_API_KEY validation
- `scripts/payment.scripts.ts` - Created test file

**Verification**:
- ‚úÖ All tests passing in payment.scripts.ts
- ‚úÖ API key validation working correctly
- ‚úÖ Singleton pattern verified

---

### üöß Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling and retry logic

**Status**: üöß IN PROGRESS (Brainstorming)

---

#### Pre-Implementation Tasks

##### ‚è≥ Pre-Task 1: Refactor Legacy Error Handler

**Why Blocking**: Current ErrorHandler doesn't support async retry logic

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async
- Add retryAsync() method
- Update 3 existing call sites

**Files**:
- src/utils/ErrorHandler.ts
- src/services/BillingService.ts
- tests/utils/ErrorHandler.test.ts

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design retry logic, error recovery patterns

**Subjects to Discuss**:
1. ‚è≥ Retry Strategy
2. ‚è≥ Circuit Breaker Pattern
3. ‚è≥ Error Logging

**Resolved Subjects**:
(To be filled during brainstorming)

---

### ‚è≥ Iteration 3: Retry Logic

**Goal**: Add exponential backoff retry for transient failures

**Status**: ‚è≥ PENDING

---

### ‚è≥ Iteration 4: Integration Tests

**Goal**: Comprehensive test coverage with Stripe API simulation

**Status**: ‚è≥ PENDING

---

## Task Notes

**Discoveries**:
- Stripe SDK already implements connection pooling (no need for custom)
- Error codes changed in Stripe API v2023-10-16 (updated error taxonomy)

**Decisions**:
- Using Stripe Node SDK v12.x (latest stable)
- Not implementing custom connection pool (SDK handles it)

**References**:
- Stripe API Docs: https://stripe.com/docs/api
- Existing billing: `src/legacy/billing.ts` (PayPal integration pattern)
- Similar webhook: `src/webhooks/shipment.ts` (signature validation example)
```

### Completion Criteria

Task is ‚úÖ COMPLETE when:
- ALL iterations are ‚úÖ COMPLETE
- Task Notes updated with discoveries
- All dependencies satisfied

## Exception: Pre-Implementation Tasks

**Only exception to "no direct action items" rule**:

Pre-implementation tasks are discovered during brainstorming (Type A subjects) and must be completed BEFORE iteration implementation starts.

**Structure**:
```
Task
‚îú‚îÄ‚îÄ Iteration N
‚îÇ   ‚îú‚îÄ‚îÄ Pre-Implementation Tasks ‚Üê EXCEPTION: Action items at iteration level
‚îÇ   ‚îú‚îÄ‚îÄ Brainstorming Session
‚îÇ   ‚îî‚îÄ‚îÄ Implementation
```

**Why Allowed**: These are blocking tasks that unblock the iteration. They're scoped to < 30 min and must be done before `/flow-implement-start`.

## When to Split a Task

### Task Too Large?

**Signals**:
- More than 5 iterations planned
- Iterations span multiple unrelated concerns
- Task takes > 4 weeks
- Task description is vague ("Implement everything...")

**Solution**: Split into multiple tasks

**Example**:
```
Before:
- Task: Payment System (10 iterations)

After:
- Task 1: Payment Processing (4 iterations)
- Task 2: Webhook Handling (3 iterations)
- Task 3: Payment Analytics (3 iterations)
```

### Task Too Small?

**Signals**:
- Only 1 iteration with 2-3 action items
- No brainstorming needed
- Can complete in < 1 hour

**Solution**: Use Single Iteration with Direct Action Items

**Example**:
```
Task: Add Logging
- Iteration 1: Logging Implementation
  - Action Items (no brainstorming):
    - Add logger configuration
    - Update main entry points
    - Add log rotation
```

## Nested Iteration Pattern

**Question**: Can iterations have sub-iterations?

**Answer**: No. Keep structure flat.

**Why**: Two levels (Task ‚Üí Iteration) is enough. If you need more nesting, split the task.

**If You Feel You Need More Nesting**:
1. You probably need multiple tasks instead
2. Or your brainstorming subjects should become separate iterations

---

<!-- AI_SCAN:BRAINSTORMING_COMPLETE:1402-1700 -->
# Brainstorming Pattern (Complete Guide)

## What is Brainstorming?

**Brainstorming** is the design-before-code phase where you:
1. Identify questions/decisions (subjects)
2. Discuss each subject
3. Document decisions
4. Generate action items
5. Identify pre-implementation work

**Location**: Inside task file, within iteration section

**Mandatory For**: Complex iterations requiring design decisions

## Brainstorming Structure

### Complete Brainstorming Section

```markdown
#### Brainstorming Session - [Topic]

**Focus**: [What we're designing/deciding]

**Subjects to Discuss**:
1. ‚è≥ [Subject name]
2. ‚è≥ [Subject name]
3. ‚è≥ [Subject name]

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: [Name]

**Decision**: [Your decision]

**Resolution Type**: A / B / C / D

**Rationale**: [Why this decision]

**Action Items** (if Type A or D):
- [ ] Item 1
- [ ] Item 2

**Documentation Update** (if Type B):
[What was updated in PLAN.md]

---

##### ‚úÖ Subject 2: [Name]

[... same structure ...]
```

## Subject Resolution Types (Deep Dive)

### Type A: Pre-Implementation Task

**When**: Small code change needed BEFORE iteration starts

**Criteria**:
- Required for iteration (blocking)
- Small scope (< 30 min)
- Can be done independently
- Examples: Fix interface, rename file, update enum, fix bug

**Action**:
1. Document decision
2. Create action items
3. Add to "Pre-Implementation Tasks" section
4. Complete BEFORE `/flow-brainstorm-complete`

**Example**:
```markdown
##### ‚úÖ Subject 3: Type Definition Updates

**Decision**: Need to update PaymentStatus enum to include new states

**Resolution Type**: A (Pre-Implementation Task)

**Rationale**: Current enum missing "pending_retry" and "failed_permanent" states needed for retry logic

**Action Items**:
- [ ] Update PaymentStatus enum in types.ts
- [ ] Update 4 switch statements to handle new states
- [ ] Add tests for new states

**Note**: Must complete before implementing retry logic
```

### Type B: Immediate Documentation

**When**: Architectural decision that affects system design

**Criteria**:
- No code changes yet
- Updates PLAN.md Architecture section
- Examples: Design pattern choice, API contract, data model

**Action**:
1. Document decision
2. Update PLAN.md Architecture section NOW
3. Reference update in subject

**Example**:
```markdown
##### ‚úÖ Subject 1: Error Recovery Strategy

**Decision**: Implement retry with exponential backoff, no circuit breaker for V1

**Resolution Type**: B (Documentation)

**Rationale**:
- Exponential backoff handles transient failures well
- Circuit breaker adds complexity, defer to V2
- Stripe API has good rate limiting, low risk of cascade failures

**Documentation Update**:
Updated PLAN.md Architecture section with retry strategy diagram and V2 scope for circuit breaker
```

### Type C: Auto-Resolved

**When**: Subject answered by another subject's decision

**Criteria**:
- No independent decision needed
- Cascade from another subject
- Examples: Implementation detail determined by architecture choice

**Action**:
1. Note which subject resolved this
2. No additional action items

**Example**:
```markdown
##### ‚úÖ Subject 4: Retry Delay Calculation

**Decision**: Use exponential backoff as decided in Subject 1

**Resolution Type**: C (Auto-Resolved by Subject 1)

**Rationale**: Subject 1 already decided on exponential backoff strategy, this subject is implementation detail
```

### Type D: Iteration Action Items

**When**: Substantial feature work that IS the iteration

**Criteria**:
- Main implementation work
- Takes significant time (> 30 min)
- Examples: Build API endpoint, implement validator, create service

**Action**:
1. Document decision
2. Create action items
3. These become implementation action items

**Example**:
```markdown
##### ‚úÖ Subject 2: Retry Implementation

**Decision**: Implement RetryPolicy class with configurable backoff strategy

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Separate class for testability
- Configurable for different API endpoints
- Can swap strategies (exponential, linear, fixed)

**Action Items**:
- [ ] Create RetryPolicy class
- [ ] Implement exponential backoff algorithm
- [ ] Add configuration for max retries, base delay
- [ ] Integrate with StripeClient
- [ ] Add tests for retry scenarios
```

## Brainstorming Workflow Commands

### 1. `/flow-brainstorm-start`

**When**: Starting brainstorming for current iteration

**Effect**:
- Adds brainstorming section to current iteration
- Prompts user for subjects to discuss
- Creates "Subjects to Discuss" list

**Example**:
```
User: /flow-brainstorm-start
AI: Let's start brainstorming for Iteration 2: Error Handling.

What subjects should we discuss? (e.g., "Retry strategy, Error logging, Circuit breaker")

User: Retry strategy, Error taxonomy, Logging format, Integration with existing error handler

AI: Added 4 subjects to brainstorming session in phase-2/task-3.md
```

### 2. `/flow-next-subject`

**When**: Ready to discuss next subject

**Effect**:
- Finds next ‚è≥ PENDING subject
- Discusses with user
- Documents decision
- User/AI chooses Type A/B/C/D
- Creates action items if needed
- Marks subject ‚úÖ COMPLETE

**Example**:
```
User: /flow-next-subject
AI: Let's discuss Subject 1: Retry Strategy

[Discussion happens...]

AI: Decision: Use exponential backoff with 3 retries

Is this:
A) Pre-implementation task (< 30 min, blocking)
B) Documentation update (update PLAN.md Architecture)
C) Auto-resolved by another subject
D) Main iteration work (implementation action items)

User: D

AI: What are the action items?

User: Create RetryPolicy class, implement backoff algorithm, integrate with client, add tests

AI: Documented. Subject 1 marked complete. 3 subjects remaining.
```

### 3. `/flow-brainstorm-review` (CRITICAL!)

**When**: After ALL subjects resolved, BEFORE `/flow-brainstorm-complete`

**Why Critical**:
- AI reviews all decisions holistically
- Suggests if more iterations needed
- Identifies pre-implementation tasks
- Catches missing subjects

**Effect**:
- AI reads all resolved subjects
- Suggests additional iterations if decisions reveal more work
- Creates "Pre-Implementation Tasks" section if Type A subjects found
- Confirms readiness to close brainstorming

**Example**:
```
User: /flow-brainstorm-review
AI: Reviewing all 4 resolved subjects...

Summary:
- Subject 1: Retry strategy (Type D) ‚Üí Main iteration work
- Subject 2: Error taxonomy (Type B) ‚Üí Updated PLAN.md
- Subject 3: Logging format (Type D) ‚Üí Main iteration work
- Subject 4: Integration with error handler (Type A) ‚Üí Pre-implementation task

Analysis:
Based on the decisions, I recommend:

1. Pre-Implementation Task Identified:
   - Subject 4 requires updating ErrorHandler.ts before implementing retry logic
   - Estimated: 20 minutes
   - Action: Update ErrorHandler to support async operations

2. Current Iteration Scope Confirmed:
   - Implementing RetryPolicy and logging is appropriate for this iteration
   - Estimated: 3-4 hours of work

3. No Additional Iterations Needed:
   - All error handling concerns addressed
   - Circuit breaker deferred to V2

Next Steps:
1. Complete pre-implementation task (update ErrorHandler.ts)
2. Run /flow-brainstorm-complete
3. Run /flow-implement-start

Ready to proceed?
```

### 4. `/flow-brainstorm-complete`

**When**: After completing ALL pre-implementation tasks

**Effect**:
- Marks brainstorming ‚úÖ COMPLETE
- Changes iteration status to üé® READY
- Updates DASHBOARD.md

**Example**:
```
User: /flow-brainstorm-complete
AI: Verifying pre-implementation tasks...
‚úÖ Pre-Task 1: Update ErrorHandler.ts - COMPLETE

Brainstorming complete! Iteration 2 is now üé® READY.

Next: /flow-implement-start to begin coding.
```

## Pre-Implementation Tasks Pattern

### Structure

```markdown
#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

##### ‚è≥ Pre-Task 1: [Name]

**Why Blocking**: [Explanation of why this blocks implementation]

**Scope** (< 30 min):
- [What needs to be done]
- [Specific changes]

**Files**:
- [List of files to modify]

**Test**: [How to verify it's done]

---

##### ‚úÖ Pre-Task 2: [Name]

**Completed**: [Date]

**Changes Made**:
- [What was actually done]
- [Any deviations from plan]
```

### Workflow

1. During brainstorming, Type A subjects are identified
2. `/flow-brainstorm-review` creates "Pre-Implementation Tasks" section
3. User completes each pre-task (or AI helps)
4. Mark each pre-task ‚úÖ with completion date
5. Only after ALL pre-tasks done ‚Üí `/flow-brainstorm-complete`

### Why This Pattern Exists

**Problem**: During brainstorming, you discover small blocking issues:
- Interface signature is wrong
- Enum is missing a value
- Legacy code doesn't support new pattern
- Type definitions need update

**Without Pre-Tasks**:
- Start implementation
- Hit blocker
- Stop to fix blocker
- Lose context
- Take longer overall

**With Pre-Tasks**:
- Identify blockers upfront during brainstorming
- Fix them while context is fresh
- Start implementation with clean path
- No interruptions

## Bugs Discovered Pattern

**Use Case**: During brainstorming, you analyze reference implementations and find bugs

**Pattern**:
```markdown
#### Bugs Discovered in Reference Implementation

##### Bug 1: Race Condition in PaymentService

**Location**: `src/services/PaymentService.ts:145`

**Problem**:
```typescript
// Current code (buggy)
async processPayment(amount: number) {
  const status = await this.checkStatus();
  // Race condition: status can change between check and update
  await this.updatePayment(status);
}
```

**Fix**:
```typescript
// Fixed code
async processPayment(amount: number) {
  await this.db.transaction(async (tx) => {
    const status = await this.checkStatus(tx);
    await this.updatePayment(status, tx);
  });
}
```

**Impact**: Could cause duplicate charges in concurrent requests

**Action**: Add to Pre-Implementation Tasks
```

**Why Document This**:
- Shows thorough analysis
- Prevents reintroducing same bugs
- Helps team learn from reference code
- Documents why certain patterns are used


<!-- AI_SCAN:IMPLEMENTATION_PATTERN:1880-1970 -->
# Implementation Pattern (Complete Guide)

## What is Implementation?

**Implementation** is the coding phase where you execute action items from brainstorming.

**Location**: Inside task file, within iteration section, after brainstorming

**Prerequisite**: Brainstorming must be ‚úÖ COMPLETE (status üé® READY)

## Implementation Structure

```markdown
#### Implementation - Iteration [N]: [Name]

**Status**: üöß IN PROGRESS

**Action Items**: See resolved subjects above

**Implementation Notes**:
[Document discoveries, decisions, challenges during work]

**Files Modified**:
- [file1.ts] - [what changed]
- [file2.ts] - [what changed]

**Verification**:
- ‚úÖ [verification step 1]
- ‚úÖ [verification step 2]
```

## Implementation Workflow

### 1. `/flow-implement-start`

**Prerequisites**:
- Brainstorming ‚úÖ COMPLETE
- All pre-implementation tasks ‚úÖ COMPLETE
- Iteration status is üé® READY

**Effect**:
- Adds "Implementation" section to current iteration
- Changes iteration status: üé® READY ‚Üí üöß IN PROGRESS
- Updates DASHBOARD.md

### 2. Do the Work

**During Implementation**:
- Work through action items from resolved subjects
- Document discoveries in "Implementation Notes"
- Track files modified
- Note any deviations from plan

**Good Implementation Notes**:
```markdown
**Implementation Notes**:
- Discovered Stripe SDK v12 deprecated `charges.create()`, using `paymentIntents.create()` instead
- Added StripeErrorMapper class to convert SDK errors to domain errors (not in original plan, but needed)
- Performance: API calls taking 200-300ms, added caching layer (will document in Architecture)
- Bug found: Existing PaymentRepository missing transaction support, added in separate commit
```

### 3. `/flow-implement-complete`

**Prerequisites**:
- All action items done
- Code works (tests pass)
- Implementation notes updated

**Effect**:
- Marks iteration ‚úÖ COMPLETE
- Updates DASHBOARD.md
- Moves to next iteration or completes task

## Verification Checklist

Before marking iteration complete, verify:

**Code Quality**:
- [ ] All action items implemented
- [ ] Code follows project style guide
- [ ] No commented-out code or TODOs left behind
- [ ] Error handling in place

**Testing**:
- [ ] Unit tests written and passing
- [ ] Integration tests if needed
- [ ] Manual testing done
- [ ] Edge cases covered

**Documentation**:
- [ ] Implementation notes updated
- [ ] Files modified list complete
- [ ] Any architecture changes documented in PLAN.md
- [ ] Code comments for complex logic

**Integration**:
- [ ] Works with existing code
- [ ] No breaking changes (or documented if intentional)
- [ ] Dependencies satisfied
- [ ] Performance acceptable

## When to Mark Complete

**‚úÖ Mark Complete When**:
- All verification checklist items done
- You would be comfortable shipping this
- Another developer could understand what was done
- No blocking issues remain

**‚ùå Don't Mark Complete When**:
- Tests are failing
- Code is partially implemented
- "TODO: finish this later" comments exist
- Blocking bugs discovered but not fixed

---

<!-- AI_SCAN:STATUS_MANAGEMENT:1972-2100 -->
# Status Management

## Status Marker Lifecycle

### Phase Lifecycle

```
‚è≥ PENDING (created)
    ‚Üì
    /flow-phase-start
    ‚Üì
üöß IN PROGRESS (working on tasks)
    ‚Üì
    /flow-phase-complete (all tasks done)
    ‚Üì
‚úÖ COMPLETE
```

**Alternative Endings**:
- ‚ùå CANCELLED (decided not to do this phase)
- üîÆ DEFERRED (moved to V2/V3, added to BACKLOG.md)

### Task Lifecycle (with Iterations)

```
‚è≥ PENDING (created)
    ‚Üì
    /flow-task-start
    ‚Üì
üöß IN PROGRESS (working on iterations)
    ‚Üì
    /flow-task-complete (all iterations done)
    ‚Üì
‚úÖ COMPLETE
```

### Iteration Lifecycle

```
‚è≥ PENDING (created)
    ‚Üì
    /flow-brainstorm-start
    ‚Üì
üöß IN PROGRESS (brainstorming)
    ‚Üì
    /flow-brainstorm-complete (all subjects resolved, pre-tasks done)
    ‚Üì
üé® READY (ready to implement)
    ‚Üì
    /flow-implement-start
    ‚Üì
üöß IN PROGRESS (implementing)
    ‚Üì
    /flow-implement-complete (all action items done, verified)
    ‚Üì
‚úÖ COMPLETE
```

**Simplified Path** (no brainstorming):
```
‚è≥ PENDING
    ‚Üì
    /flow-implement-start (if no brainstorming needed)
    ‚Üì
üöß IN PROGRESS
    ‚Üì
    /flow-implement-complete
    ‚Üì
‚úÖ COMPLETE
```

## State Transitions

### Valid Transitions

**Phase**:
- ‚è≥ ‚Üí üöß (start)
- üöß ‚Üí ‚úÖ (complete)
- üöß ‚Üí ‚ùå (cancel)
- üöß ‚Üí üîÆ (defer)
- ‚è≥ ‚Üí ‚ùå (cancel before starting)
- ‚è≥ ‚Üí üîÆ (defer before starting)

**Task**:
- ‚è≥ ‚Üí üöß (start)
- üöß ‚Üí ‚úÖ (complete)
- üöß ‚Üí ‚ùå (cancel)
- üöß ‚Üí üîÆ (defer)

**Iteration**:
- ‚è≥ ‚Üí üöß (start brainstorming or implementing)
- üöß ‚Üí üé® (finish brainstorming)
- üé® ‚Üí üöß (start implementing)
- üöß ‚Üí ‚úÖ (finish implementing)

### Invalid Transitions

**Never Do This**:
- ‚ùå ‚úÖ ‚Üí üöß (reopening completed work - create new iteration instead)
- ‚ùå ‚è≥ ‚Üí ‚úÖ (skipping work - mark cancelled or remove if never needed)
- ‚ùå üé® ‚Üí ‚è≥ (moving backwards - if brainstorming wrong, add new iteration)

## Common Pitfalls

### Pitfall 1: Marking Complete Too Early

**Problem**:
```markdown
### Iteration 2: Error Handling ‚úÖ COMPLETE

**Implementation Notes**:
- Started implementing retry logic
- TODO: finish exponential backoff
- TODO: add tests
```

**Why Bad**: Work is not done, tests missing, TODOs present

**Fix**: Keep status üöß IN PROGRESS until ALL work done

### Pitfall 2: Not Updating DASHBOARD.md

**Problem**: Update task file status but forget DASHBOARD.md

**Effect**: DASHBOARD.md shows wrong current work, user is confused

**Fix**: Commands automatically update both files

### Pitfall 3: Skipping Brainstorming

**Problem**:
```markdown
### Iteration 2: Complex Feature ‚è≥

[Immediately start implementing without design]
```

**Why Bad**: No decisions documented, will need refactoring later

**Fix**: Always brainstorm for complex work, only skip for trivial iterations

### Pitfall 4: Mixing Status in DASHBOARD and Task File

**Problem**:
- DASHBOARD.md shows Iteration 2 üöß IN PROGRESS
- Task file shows Iteration 2 ‚úÖ COMPLETE

**Why Bad**: Source of truth is inconsistent

**Fix**: `/flow-verify-plan` detects this, always update both together

## Recovery from Incorrect States

### Reopening Completed Work

**Scenario**: Marked iteration complete, but found bugs/issues

**Wrong Approach**: Change ‚úÖ ‚Üí üöß

**Right Approach**:
1. Keep original iteration ‚úÖ COMPLETE
2. Add new iteration: "Iteration N+1: Fix Issues from Iteration N"
3. Document what needs fixing

**Why**: Preserves history, shows work progression

### Abandoned Work

**Scenario**: Started iteration, decided not to finish

**Options**:
1. **Cancel**: Mark ‚ùå CANCELLED with reason
2. **Defer**: Mark üîÆ DEFERRED, move to BACKLOG.md with reason
3. **Remove**: If truly never started, just delete iteration

**Choose Cancel/Defer**: When some work was done or decision has value

**Choose Remove**: When created by mistake, no work done

### Stuck in Brainstorming

**Scenario**: Brainstorming taking too long, can't resolve subjects

**Solution**:
1. Review resolved subjects
2. Identify if subject should be Type C (auto-resolved)
3. Consider if subject should move to separate iteration
4. If truly stuck, add subject as "Research spike" iteration

---

<!-- AI_SCAN:FILE_TEMPLATES:2102-2600 -->
# File Templates

## DASHBOARD.md Template

```markdown
# [Project Name] - Dashboard

**Last Updated**: [Date & Time]

**Project**: [Brief one-liner]
**Status**: [Overall status]
**Version**: [V1/V2/V3]

---

## üìç Current Work

- **Phase**: [Phase N - Name](phase-N/)
- **Task**: [Task M - Name](phase-N/task-M.md)
- **Iteration**: [Iteration K - Name](phase-N/task-M.md#iteration-K) [Status Emoji]
- **Focus**: [One sentence describing current work]

---

## üìä Progress Overview

### Phase 1: [Name] [Status Emoji]

**Goal**: [One sentence phase goal]
**Status**: [Completion summary, e.g., "3/3 tasks complete"]

**Tasks**:
- [Status Emoji] **Task 1**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]
  - [Status Emoji] Iteration 2: [Name]
- [Status Emoji] **Task 2**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]

### Phase 2: [Name] [Status Emoji]

**Goal**: [One sentence phase goal]
**Status**: [Completion summary]

**Tasks**:
- [Status Emoji] **Task 1**: [Name] ([X/Y iterations])
  - [Status Emoji] Iteration 1: [Name]
  - üöß Iteration 2: [Name] ‚Üê **CURRENT**
  - ‚è≥ Iteration 3: [Name]

---

## üí° Key Decisions

**Decision Needed**: [Question for user]
- Option A: [Choice] - [Rationale]
- Option B: [Choice] - [Rationale]
- **Recommendation**: [If AI has suggestion]

**Resolved**:
- **[Date]**: [Decision made] - [Brief rationale]
```

---

## PLAN.md Template

```markdown
# [Feature/Project Name] - Development Plan

> **üìñ Framework Guide**: See [DEVELOPMENT_FRAMEWORK.md](DEVELOPMENT_FRAMEWORK.md) for complete methodology
> **üìç Current Progress**: See [DASHBOARD.md](DASHBOARD.md) for real-time status tracking
> **üéØ Purpose**: [One sentence describing what this feature/project does]

**Created**: [Date]
**Version**: [V1/V2/V3]
**Plan Location**: `.flow/` (managed by Flow framework)

---

## Overview

### Purpose

[2-3 paragraphs explaining WHY this feature exists and WHAT problem it solves]

### Goals

[Describe what success looks like - text format, NOT checklists]

**Primary Goals**:
- [Measurable goal 1]
- [Measurable goal 2]
- [Measurable goal 3]

**Success Criteria**:
- [How we know this is successful]
- [Performance targets, if applicable]
- [User experience goals]

### Scope

**V1 Scope** (Current Session):
- [Feature 1]
- [Feature 2]
- [Feature 3]
- [Constraint/limitation]

**Note**: V2/V3/Out-of-Scope sections only included if user explicitly requests them. Default to V1-only scope for minimal planning overhead.

---

## Architecture

### System Context

[High-level description of how this feature fits into the system - describe WHAT exists, NOT prescriptive current-vs-desired with line numbers]

**Components**:
- **[ComponentName]**: [Responsibility]
- **[ComponentName]**: [Responsibility]

**Key Dependencies**:
- [Internal service/module]: [What we need from it]
- [External library/API]: [Why we need it, version if relevant]

**Reference Implementations** (if relevant):
- [Existing code to learn from]: [File path or description]
- [Similar feature]: [What to reuse/avoid]

---

## DO / DON'T Guidelines

**‚úÖ DO**:
- [Best practice for this project]
- [Quality standard to maintain]
- [Pattern to follow]

**‚ùå DO NOT**:
- [Anti-pattern to avoid]
- [Common mistake to prevent]
- [Constraint to respect]

---

## Notes & Learnings

**Design Decisions**:
- [Date]: [Decision made and rationale]

**References**:
- [External doc]: [URL]
- [Internal doc]: [Path]
```

---

## task-N.md Template (With Iterations)

```markdown
# Task [N]: [Task Name]

**Status**: ‚è≥ PENDING
**Phase**: [Phase M - Name](../DASHBOARD.md#phase-M-name)
**Purpose**: [One sentence - what this task accomplishes]

---

## Task Overview

[2-3 paragraphs describing this task in detail]

**Why This Task**: [Explanation of why this task is necessary]

**Dependencies**:
- **Requires**: [Task name/number] - [What we need from it]
- **Blocks**: [Task name/number] - [What depends on this]

**Estimated Complexity**: [Low/Medium/High] ([X iterations expected])

---

## Iterations

### ‚è≥ Iteration 1: [Name]

**Goal**: [One sentence - what this iteration achieves]

**Status**: ‚è≥ PENDING

---

#### Brainstorming Session - [Iteration Name]

(Optional - design decisions will be documented here if needed)

**Focus**: [What we're designing - TBD]

**Subjects to Discuss**:
- (Add subjects with /flow-brainstorm-subject)

**Resolved Subjects**:
- (Filled during brainstorming)

---

#### Action Items

- [ ] [TBD - Define during brainstorming or add directly]

---

### ‚è≥ Iteration 2: [Name]

**Goal**: [One sentence - what this iteration achieves]

**Status**: ‚è≥ PENDING

---

#### Brainstorming Session - [Iteration Name]

(Optional - design decisions will be documented here if needed)

**Focus**: [What we're designing - TBD]

**Subjects to Discuss**:
- (Add subjects with /flow-brainstorm-subject)

**Resolved Subjects**:
- (Filled during brainstorming)

---

#### Action Items

- [ ] [TBD - Define during brainstorming or add directly]

---

## Task Notes

**Discoveries**:
- [Things learned while working on this task]

**Decisions**:
- [Task-specific decisions made]

**References**:
- [Relevant code]: [Path]
- [Documentation]: [URL]
```

---

## Iteration Section Template (Full)

```markdown
### [Status Emoji] Iteration [N]: [Name]

**Goal**: [One sentence]

**Status**: [Status]

---

#### Pre-Implementation Tasks

(Optional - only if Type A subjects identified during brainstorming)

##### ‚è≥ Pre-Task 1: [Name]

**Why Blocking**: [Explanation]

**Scope** (< 30 min):
- [What to do]

**Files**:
- [file1]

**Test**: [How to verify]

---

#### Brainstorming Session - [Topic]

(Optional - only for complex iterations requiring design decisions)

**Focus**: [What we're designing]

**Subjects to Discuss**:
1. ‚è≥ [Subject name]
2. ‚è≥ [Subject name]

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: [Name]

**Decision**: [The decision made]

**Resolution Type**: [A/B/C/D]

**Rationale**: [Why this decision]

**Resolution Items** (if Type D):
- [Item to do]
- [Item to do]

**Note**: Type A creates Pre-Tasks. Type B updates PLAN.md immediately. Type C references other subjects. Type D creates Resolution Items.

---

#### Action Items

(Required - ONE list per iteration)

**If brainstorming**: `/flow-brainstorm-review` consolidates all Resolution Items into this list
**If no brainstorming**: List action items directly

- [ ] [Action item 1]
- [ ] [Action item 2]
- [ ] [Action item 3]

---

#### Implementation - Iteration [N]: [Name]

(Added by `/flow-implement-start`, updated during work, completed by `/flow-implement-complete`)

**Status**: üöß IN PROGRESS

**Implementation Notes**:
- [Discovery during implementation]
- [Change from plan]

**Files Modified**:
- [file1.ts] - [what changed]
- [file2.ts] - [what changed]

**Verification**:
- ‚úÖ [Test passed]
- ‚úÖ [Manual verification done]
```


<!-- AI_SCAN:COMMAND_PATTERNS:2726-2900 -->
# Command Patterns

## Dashboard-First Navigation Pattern (Detailed)

**Used By**: 16 commands (brainstorming, implementation, state management)

### Pattern Steps

```
1. Read DASHBOARD.md
2. Extract current context from "üìç Current Work" section:
   - Phase number (e.g., "Phase 2")
   - Task number (e.g., "Task 3")
   - Iteration number (e.g., "Iteration 2")
3. Construct task file path: phase-{N}/task-{M}.md
4. Read task file
5. Locate relevant section (e.g., Iteration K)
6. Perform operation (read/edit)
7. Update DASHBOARD.md with new state
```

### Example Implementation

**Command**: `/flow-implement-start`

```
Step 1: Read DASHBOARD.md
‚Üí Extract: Phase 2, Task 3, Iteration 2

Step 2: Construct path
‚Üí phase-2/task-3.md

Step 3: Read phase-2/task-3.md
‚Üí Find "### Iteration 2: Error Handling"

Step 4: Check prerequisites
‚Üí Brainstorming status: ‚úÖ COMPLETE
‚Üí Iteration status: üé® READY

Step 5: Add Implementation section
‚Üí Insert "#### Implementation - Iteration 2: Error Handling"
‚Üí Add structure (Status, Action Items, Implementation Notes, etc.)

Step 6: Update DASHBOARD.md
‚Üí Change "Iteration 2" status: üé® READY ‚Üí üöß IN PROGRESS
‚Üí Update "Last Updated" timestamp
‚Üí Update "Current Work" section if needed

Step 7: Notify user
‚Üí "Started implementation of Iteration 2. See phase-2/task-3.md for details."
```

### Commands Using This Pattern

- `/flow-brainstorm-start`
- `/flow-brainstorm-subject`
- `/flow-next-subject`
- `/flow-brainstorm-review`
- `/flow-brainstorm-complete`
- `/flow-implement-start`
- `/flow-implement-complete`
- `/flow-iteration-add`
- `/flow-task-start`
- `/flow-task-complete`
- `/flow-next`
- `/flow-next-iteration`

---

## Structure Creation Pattern

**Used By**: 4 commands (blueprint, phase-add, task-add, migrate)

### Pattern Steps

```
1. Read DASHBOARD.md (or create if missing for blueprint)
2. Determine what to create:
   - New phase directory?
   - New task file?
   - Initial project structure?
3. Create directory/file with template content
4. Update DASHBOARD.md to include new structure
5. Notify user with file paths created
```

### Example: `/flow-task-add "API Integration"`

```
Step 1: Read DASHBOARD.md
‚Üí Current phase: Phase 2

Step 2: Determine next task number
‚Üí Read phase-2/ directory
‚Üí Find existing files: task-1.md, task-2.md
‚Üí Next task number: 3

Step 3: Create phase-2/task-3.md
‚Üí Use "Task with Iterations" template
‚Üí Fill in: Task name, Phase link, Status ‚è≥

Step 4: Update DASHBOARD.md
‚Üí Add to Phase 2 section:
  "- ‚è≥ **Task 3**: API Integration"

Step 5: Notify user
‚Üí "Created phase-2/task-3.md. Use /flow-task-start to begin work."
```

---

## Full Traversal Pattern

**Used By**: 4 commands (status, summarize, verify-plan, plan-split)

### Pattern Steps

```
1. Read DASHBOARD.md
2. Extract all phases from "Progress Overview" section
3. For each phase:
   a. Read phase directory (phase-N/)
   b. List all task files (task-*.md)
   c. Read each task file
   d. Extract relevant information (status, iterations, completion)
4. Aggregate information
5. Generate report or perform validation
6. Return result to user
```

### Example: `/flow-summarize`

```
Step 1: Read DASHBOARD.md
‚Üí Find phases: Phase 1, Phase 2, Phase 3

Step 2: For Phase 1:
‚Üí Read phase-1/ directory
‚Üí Files: task-1.md, task-2.md, task-3.md
‚Üí Read each file, extract:
  - Task name
  - Status
  - Iteration count
  - Key decisions from brainstorming

Step 3: For Phase 2:
‚Üí (repeat same process)

Step 4: For Phase 3:
‚Üí (repeat same process)

Step 5: Generate summary
‚Üí Format output:
  # Project Summary
  
  ## Phase 1: Foundation ‚úÖ COMPLETE
  - Task 1: Project Setup (3 iterations) ‚úÖ
    - Key decisions: Singleton pattern, env-based config
  - Task 2: Core Models (2 iterations) ‚úÖ
    - Key decisions: Entity validation, repository pattern
  
  ## Phase 2: Core Implementation üöß IN PROGRESS
  ...
  
Step 6: Return summary to user
```

---

## Cross-File Search Pattern

**Used By**: 4 commands (backlog-add, backlog-pull, next-iteration, rollback)

### Pattern Steps

```
1. Read DASHBOARD.md (understand scope)
2. Determine search criteria:
   - Looking for next ‚è≥ iteration?
   - Finding task by number?
   - Searching for specific status?
3. Use Grep or Read to search across multiple task files
4. Collect matches
5. Perform operation (move to backlog, update status, etc.)
6. Update DASHBOARD.md if needed
7. Return result
```

### Example: `/flow-next-iteration`

```
Step 1: Read DASHBOARD.md
‚Üí Current: Phase 2, Task 3, Iteration 2 (in progress)

Step 2: Determine next iteration to work on
‚Üí Check current task file first (phase-2/task-3.md)
‚Üí Look for next ‚è≥ iteration after current one

Step 3: Read phase-2/task-3.md
‚Üí Find iterations:
  - Iteration 1: ‚úÖ COMPLETE
  - Iteration 2: üöß IN PROGRESS (current)
  - Iteration 3: ‚è≥ PENDING ‚Üê FOUND
  - Iteration 4: ‚è≥ PENDING

Step 4: If found in current task
‚Üí Return "Iteration 3: Retry Logic"
‚Üí Show goal and status

Step 5: If not found in current task
‚Üí Look at next task in current phase
‚Üí Then next phase if needed

Step 6: Return result
‚Üí "Next iteration: Iteration 3 - Retry Logic (phase-2/task-3.md)"
```

---

<!-- AI_SCAN:COMPLETE_WORKFLOW:2902-3200 -->
# Complete Workflow Examples

## Example 1: Payment Gateway Integration (Full Feature)

### Project Setup

```bash
# Create new project
/flow-blueprint

AI: Please provide project details:
- Feature name?
- Purpose?
- High-level phases?

User: Payment Gateway Integration
      Integrate Stripe for credit card payments
      Phases: Foundation, Core Implementation, Testing

AI: Created:
- DASHBOARD.md
- PLAN.md
- phase-1/ (Foundation)
- phase-1/task-1.md (Project Setup)
```

**Files Created**:
- `.flow/DASHBOARD.md` - Progress tracking
- `.flow/PLAN.md` - Overview, architecture, testing strategy
- `.flow/phase-1/` - First phase directory
- `.flow/phase-1/task-1.md` - Initial task

---

### Working Through Phase 1

```bash
# Start first phase
/flow-phase-start

# Add tasks to Phase 1
/flow-task-add "Project Setup"
/flow-task-add "Core Models"

# Start first task
/flow-task-start

# Add iteration to Task 1
/flow-iteration-add "Repository Structure"

# Start brainstorming
/flow-brainstorm-start

AI: What subjects should we discuss for Repository Structure?

User: Directory layout, Configuration setup, Dependency management

AI: Added 3 subjects to brainstorming. Use /flow-next-subject to begin.

# Resolve subjects
/flow-next-subject

AI: Let's discuss Subject 1: Directory Layout
    What structure should we use?

User: Standard src/ structure with feature-based organization

AI: Is this:
    A) Pre-implementation task
    B) Documentation update
    C) Auto-resolved
    D) Main iteration work

User: D

AI: Action items?

User: Create src/payment/ directory, Add index files, Setup barrel exports

AI: Subject 1 resolved. 2 subjects remaining.

/flow-next-subject
[... continue resolving subjects ...]

# After all subjects resolved
/flow-brainstorm-review

AI: Reviewing all 3 subjects...
    - Subject 1: Directory layout (Type D)
    - Subject 2: Config setup (Type D)
    - Subject 3: Dependencies (Type A - Pre-task)
    
    Pre-implementation task identified:
    - Update package.json with Stripe SDK
    
    Ready to proceed?

User: Yes

# Complete pre-task
[Install Stripe SDK]

# Complete brainstorming
/flow-brainstorm-complete

AI: Brainstorming complete. Iteration 1 is now üé® READY.
    Use /flow-implement-start to begin coding.

# Start implementation
/flow-implement-start

# Do the work
[Create directory structure, setup config, etc.]

# Complete implementation
/flow-implement-complete

AI: Iteration 1 complete! ‚úÖ
    Next: Use /flow-iteration-add for Iteration 2, or /flow-task-complete if task is done.
```

**Files Updated During This Workflow**:
1. **DASHBOARD.md**:
   - Phase 1 status: ‚è≥ ‚Üí üöß
   - Task 1 status: ‚è≥ ‚Üí üöß ‚Üí ‚úÖ
   - Current work pointer updated throughout
   - Progress percentages updated

2. **phase-1/task-1.md**:
   - Task status: ‚è≥ ‚Üí üöß
   - Iteration 1 added
   - Brainstorming section filled
   - Implementation notes added
   - Status: üöß ‚Üí ‚úÖ

---

### Moving to Phase 2

```bash
# Complete Phase 1
/flow-phase-complete

AI: Phase 1 complete! ‚úÖ
    Ready to start Phase 2?

# Add Phase 2
/flow-phase-add "Core Implementation"

# Start Phase 2
/flow-phase-start

# Add tasks
/flow-task-add "API Integration"
/flow-task-add "Webhook Handler"
/flow-task-add "Error Handling"

# Work through tasks
[... repeat similar workflow as Phase 1 ...]
```

---

## Example 2: Simple Task with Single Iteration

```bash
# Add simple task
/flow-task-add "Update Documentation"

AI: Created phase-2/task-4.md
    Task created with iterations structure.

    Since this is simple documentation work, you can:
    - Add one iteration with direct action items (skip brainstorming)
    - Start, implement, and complete quickly

# Add single iteration
/flow-iteration-add "Documentation Updates"

AI: Added Iteration 1 to Task 4.
    For simple work, you can skip brainstorming and add action items directly.

User: Add these action items:
      - Update README
      - Fix typos
      - Add examples

AI: Added 3 action items to Iteration 1.
    Use /flow-implement-start to begin.

# Start implementation
/flow-implement-start

# Do the work
[Update docs]

# Complete implementation
/flow-implement-complete

AI: Iteration 1 complete! ‚úÖ
    Task 4 has 1/1 iterations complete.
    Use /flow-task-complete to mark task done.

/flow-task-complete

AI: Task 4 complete! ‚úÖ
    Moving to next task...
```

**Note**: Simple tasks use one iteration with direct action items - no brainstorming required.

---

## Example 3: Deferring Work to Backlog

```bash
# During Phase 2, decide to defer a task
/flow-backlog-add 5 "Multi-currency support adds too much complexity for V1"

AI: Moved Task 5 to BACKLOG.md with reason.
    Updated DASHBOARD.md to reflect removal.

# Later, pull it back
/flow-backlog-pull 5

AI: Pulled Task 5 from backlog.
    Added to end of Phase 2.
    Updated DASHBOARD.md.
```

---

## Example 4: Archiving Completed Work

```bash
# After completing Phase 1 and Phase 2
/flow-plan-split

AI: Archiving completed work...
    - Phase 1: 3 tasks archived
    - Phase 2: Task 1-2 archived (completed only)
    
    Created ARCHIVE.md with all completed task details.
    
    Updated task files to reference archive:
    - phase-1/task-1.md ‚Üí "See ARCHIVE.md"
    - phase-1/task-2.md ‚Üí "See ARCHIVE.md"
    - phase-2/task-1.md ‚Üí "See ARCHIVE.md"
    - phase-2/task-2.md ‚Üí "See ARCHIVE.md"
    
    DASHBOARD.md now shows only active work.
```

---

<!-- AI_SCAN:BACKLOG_MANAGEMENT:3202-3500 -->
# Backlog Management

## BACKLOG.md Structure

```markdown
# Project Backlog

**Last Updated**: [Date]

---

## üìã Backlog Dashboard

**Total Items**: [N]

**By Version**:
- V2 Features: [N]
- V3 Features: [N]
- Technical Debt: [N]
- Deferred Tasks: [N]

**By Priority**:
- High: [N]
- Medium: [N]
- Low: [N]

---

## Backlog Items

### High Priority

#### ‚è≥ Task: Multi-Currency Support

**Originally Planned**: Phase 2, Task 6
**Deferred To**: V2
**Priority**: High

**Reasoning**:
V1 scope focuses on USD only. Multi-currency requires:
- Exchange rate API integration
- Currency conversion logic
- Multi-currency display in UI
- Testing across currencies

This adds 2-3 weeks and is not critical for V1 launch.

**Estimated Effort**: 2-3 weeks
**Dependencies**: Core payment processing complete (Phase 2, Task 1-3)

**When to Pull Back**:
- After V1 launch
- When international customers become priority
- When we have exchange rate API access

---

#### ‚è≥ Task: Advanced Retry Logic with Circuit Breaker

**Originally Planned**: Phase 2, Task 3, Iteration 3
**Deferred To**: V2
**Priority**: High

**Reasoning**:
Basic retry logic (3 attempts, exponential backoff) is sufficient for V1.
Circuit breaker pattern adds value but requires:
- State management for circuit status
- Monitoring and alerting integration
- Configuration management
- Additional testing

**Estimated Effort**: 1 week
**Dependencies**: Basic retry logic (Phase 2, Task 3, Iteration 2)

---

### Medium Priority

#### ‚è≥ Feature: Saved Payment Methods

**Deferred To**: V2
**Priority**: Medium

**Reasoning**:
V1 focuses on one-time payments. Saved payment methods require:
- Secure token storage
- Card management UI
- PCI compliance review
- Additional security testing

**Estimated Effort**: 2 weeks
**Dependencies**: Payment processing complete, Security audit done

---

### Low Priority

#### ‚è≥ Technical Debt: Refactor PaymentService

**Deferred To**: V3
**Priority**: Low

**Reasoning**:
Current PaymentService works but has some code duplication.
Not urgent, can refactor after V2 when we understand all use cases better.

**Estimated Effort**: 3-4 days
**Dependencies**: None

---

## Removed from Backlog

### Task: ACH Payment Support

**Originally**: V2 Feature
**Removed**: 2025-01-20
**Reason**: Business decision - focus on credit cards only for foreseeable future
```

---

## Backlog Commands

### `/flow-backlog-add [task-number] "[reason]"`

**Purpose**: Move task from active plan to backlog

**Usage**:
```bash
# Move single task
/flow-backlog-add 6 "Multi-currency adds too much complexity for V1, deferring to V2"

# Move range of tasks
/flow-backlog-add 6-8 "These features are V2 scope"
```

**Effect**:
1. Reads DASHBOARD.md, finds Phase/Task info
2. Reads task file (phase-N/task-M.md)
3. Copies task details to BACKLOG.md with reason
4. Marks task as üîÆ DEFERRED in DASHBOARD.md
5. Updates task file status to üîÆ DEFERRED with reference to BACKLOG.md

**Task File After**:
```markdown
# Task 6: Multi-Currency Support

**Status**: üîÆ DEFERRED
**Deferred To**: V2
**Reason**: Too complex for V1 scope

See [BACKLOG.md](../BACKLOG.md#task-multi-currency-support) for details and reasoning.
```

---

### `/flow-backlog-view`

**Purpose**: Show backlog contents

**Usage**:
```bash
/flow-backlog-view
```

**Output**:
```
Backlog Summary:
- Total items: 8
- V2 features: 5
- V3 features: 2
- Technical debt: 1

High Priority (3 items):
1. Multi-Currency Support (V2)
2. Advanced Retry Logic (V2)
3. Saved Payment Methods (V2)

Medium Priority (3 items):
...

See BACKLOG.md for full details.
```

---

### `/flow-backlog-pull [task-number] [position]"`

**Purpose**: Pull task from backlog back into active plan

**Usage**:
```bash
# Pull task, add to end of current phase
/flow-backlog-pull 6

# Pull task, insert after specific task
/flow-backlog-pull 6 "after task 3"

# Pull task, insert at beginning of phase
/flow-backlog-pull 6 "at start"
```

**Effect**:
1. Reads BACKLOG.md, finds task details
2. Determines current phase from DASHBOARD.md
3. Creates new task file in phase directory
4. Assigns next available task number
5. Updates DASHBOARD.md with new task
6. Removes from BACKLOG.md (or marks as pulled)

**Example**:
```bash
/flow-backlog-pull 6

AI: Pulled "Multi-Currency Support" from backlog.
    Created phase-2/task-6.md
    Updated DASHBOARD.md
    
    Task is now ‚è≥ PENDING in Phase 2.
    Use /flow-task-start when ready to begin.
```

---

## When to Use Backlog

### Use Backlog For:

**V2/V3 Features**:
- Features planned but not in current version scope
- Enhancements discovered during V1 development
- Nice-to-have features that aren't MVP

**Deferred Tasks**:
- Tasks started but decided against mid-development
- Tasks that turned out more complex than expected
- Tasks blocked by external dependencies (waiting for API access, etc.)

**Technical Debt**:
- Refactoring opportunities identified
- Code improvements that aren't urgent
- Performance optimizations that can wait

**Scope Creep Prevention**:
- Features requested during development that expand scope
- "Wouldn't it be cool if..." ideas
- Gold-plating attempts

### Don't Use Backlog For:

**Cancelled Work**:
- Use ‚ùå CANCELLED status in task file instead
- Document reason directly in task

**Bugs**:
- Bugs should be fixed, not backlogged
- Exception: Non-critical bugs in V2 features can be backlogged with V2

**Core MVP Features**:
- If it's truly needed for V1, keep it in active plan
- Descope properly rather than backlog everything

---

<!-- AI_SCAN:BEST_PRACTICES:3502-3800 -->
# Best Practices & Pitfalls

## Best Practices

### 1. Always Brainstorm for Complex Work

**‚úÖ DO**:
```markdown
### Iteration 2: Error Handling ‚è≥

[Brainstorming section]
[Pre-implementation tasks]
[Implementation section]
```

**‚ùå DON'T**:
```markdown
### Iteration 2: Error Handling ‚è≥

[Start implementing without design]
```

**Why**: Brainstorming surfaces decisions early, prevents refactoring later.

---

### 2. Keep DASHBOARD.md Up-to-Date

**‚úÖ DO**:
- Update DASHBOARD.md every time status changes
- Use commands that automatically update both files
- Run `/flow-status` regularly to verify state

**‚ùå DON'T**:
- Update task file but forget DASHBOARD.md
- Manually edit both files (error-prone)
- Let DASHBOARD.md get stale

**Why**: DASHBOARD.md is source of truth for current state. Stale dashboard confuses everyone.

---

### 3. Use Descriptive Commit Messages

**‚úÖ DO**:
```bash
git commit -m "Complete Iteration 2: Error Handling

- Implemented RetryPolicy with exponential backoff
- Added error taxonomy mapping
- Fixed legacy ErrorHandler async support
- All tests passing

Updated: phase-2/task-3.md, DASHBOARD.md"
```

**‚ùå DON'T**:
```bash
git commit -m "updates"
```

**Why**: Commit history tells story of feature development.

---

### 4. Document Discoveries Immediately

**‚úÖ DO**:
```markdown
**Implementation Notes**:
- Discovered Stripe SDK v12 deprecated charges API
- Switched to PaymentIntents API (newer, more flexible)
- Added StripeErrorMapper class (not in original plan)
- Performance: API calls 200-300ms, added caching
```

**‚ùå DON'T**:
```markdown
**Implementation Notes**:
(empty)
```

**Why**: Discoveries are valuable context for future work and team members.

---

### 5. Break Down Large Tasks

**‚úÖ DO**:
```
Phase 2: Core Implementation
- Task 1: Database Layer (3 iterations)
- Task 2: Business Logic (4 iterations)
- Task 3: API Integration (4 iterations)
```

**‚ùå DON'T**:
```
Phase 2: Core Implementation
- Task 1: Everything (25 iterations)
```

**Why**: Smaller tasks are easier to reason about, track progress, and complete.

---

### 6. Use Pre-Implementation Tasks

**‚úÖ DO**:
```markdown
#### Pre-Implementation Tasks

##### ‚è≥ Pre-Task 1: Fix Interface Signature

**Why Blocking**: Current interface doesn't support async
...

[Complete before /flow-brainstorm-complete]
```

**‚ùå DON'T**:
```markdown
[Start implementation]
[Hit blocker]
[Stop to fix blocker]
[Lose context]
```

**Why**: Unblock early while context is fresh.

---

### 7. Reference PLAN.md for Big Decisions

**‚úÖ DO**:
- Update PLAN.md Architecture section for Type B decisions
- Reference PLAN.md when explaining system design
- Keep PLAN.md as single source of truth for architecture

**‚ùå DON'T**:
- Scatter architecture decisions across task files
- Forget to document major design choices
- Let PLAN.md get out of sync with reality

---

### 8. Use /flow-verify-plan Regularly

**‚úÖ DO**:
```bash
/flow-verify-plan

# Run this:
- After bulk edits
- When feeling lost
- Before marking phase complete
- After pulling from git
```

**Why**: Catches inconsistencies early before they cause confusion.

---

## Common Pitfalls

### Pitfall 1: Skipping /flow-brainstorm-review

**Problem**:
```bash
/flow-next-subject  # Resolve all subjects
/flow-brainstorm-complete  # Skip review!
```

**Why Bad**: Miss identifying pre-implementation tasks, miss suggesting more iterations.

**Fix**: ALWAYS run `/flow-brainstorm-review` after resolving all subjects, BEFORE `/flow-brainstorm-complete`.

---

### Pitfall 2: Marking Complete Too Early

**Problem**:
```markdown
### Iteration 2: Error Handling ‚úÖ COMPLETE

**Implementation Notes**:
- TODO: Add tests
- TODO: Fix edge case
```

**Why Bad**: Work not actually done, TODOs present.

**Fix**: Only mark ‚úÖ COMPLETE when ALL work done, verified, and no TODOs remain.

---

### Pitfall 3: Not Reading DASHBOARD.md First

**Problem**:
```
[AI tries to edit task file without reading DASHBOARD.md]
[Edits wrong task/iteration]
[Causes confusion]
```

**Why Bad**: Don't know current context, edit wrong places.

**Fix**: ALWAYS read DASHBOARD.md first (dashboard-first pattern).

---

### Pitfall 4: Creating Too Many Small Tasks

**Problem**:
```
Phase 2: Core Implementation
- Task 1: Create class (1 action item)
- Task 2: Add method (1 action item)
- Task 3: Add another method (1 action item)
[... 20 tiny tasks ...]
```

**Why Bad**: Overhead of task management exceeds value.

**Fix**: Combine related small work into one task with multiple action items or iterations.

---

### Pitfall 5: Not Linking Files

**Problem**:
```markdown
# Task 3 in phase-2/task-3.md

**Phase**: Phase 2
```

**Why Bad**: No clickable link back to DASHBOARD.md, hard to navigate.

**Fix**: Always use markdown links:
```markdown
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
```

---

### Pitfall 6: Forgetting to Update Examples

**Problem**: Make changes to framework, forget to update example files.

**Why Bad**: Users learn from outdated examples.

**Fix**: After changing framework docs, update examples/ directory to match.

---

## Performance Tips

### For Large Projects

**Problem**: 100+ tasks across 10 phases = slow to navigate

**Solutions**:

1. **Use /flow-plan-split regularly**:
   - Archives completed work
   - Keeps active plan small
   - Old work still accessible in ARCHIVE.md

2. **Leverage DASHBOARD.md**:
   - Dashboard has jump links
   - Don't read all task files, just current one
   - Use Grep to search across files when needed

3. **Keep task files focused**:
   - One task per file
   - Don't let iterations grow too large
   - Split task if > 7-8 iterations

---

## Multi-Developer Workflows

### Git Merge Conflicts

**Problem**: Multiple developers editing same files

**With Multi-File Architecture**:
- Conflicts localized to specific task files
- DASHBOARD.md conflicts are small and obvious
- Much better than monolithic PLAN.md merge conflicts

**Best Practices**:
1. Each developer works on different tasks (different files)
2. Communicate before editing DASHBOARD.md
3. Pull frequently to stay in sync
4. Use `/flow-verify-plan` after merging

---

### Handoff Between Developers

**Scenario**: Developer A starts task, Developer B finishes it

**Process**:
1. Developer A updates DASHBOARD.md and task file with current state
2. Developer A commits and pushes
3. Developer B pulls, runs `/flow-status` to understand current state
4. Developer B reads current task file (DASHBOARD.md tells them which file)
5. Developer B continues work from current iteration

**Key**: DASHBOARD.md + task files preserve complete context for handoff.

---

## Summary of Key Rules

1. **Dashboard-First**: Always read DASHBOARD.md first
2. **Iterations-Only**: All tasks have iterations (simple tasks use single iteration)
3. **Brainstorm Complex Work**: Don't skip brainstorming for complex iterations
4. **Pre-Tasks Before Implementation**: Complete all pre-tasks before `/flow-brainstorm-complete`
5. **Review Before Complete**: Always `/flow-brainstorm-review` before `/flow-brainstorm-complete`
6. **Document Everything**: Implementation notes, discoveries, decisions
7. **Update Both Files**: Commands update both DASHBOARD.md and task files
8. **Verify Regularly**: Use `/flow-verify-plan` to catch inconsistencies
9. **Archive When Large**: Use `/flow-plan-split` to keep active plan manageable
10. **Use Backlog**: Defer scope creep to BACKLOG.md, don't delete work

---

**End of Complete Framework Documentation**

For quick reference, see lines 1-600 (Quick Reference section).
For specific sections, see Section Index (lines 543-614).

FRAMEWORK_DATA_EOF
}

get_example_dashboard() {
  cat <<'EXAMPLE_DASHBOARD_EOF'
# Payment Gateway Integration - Dashboard

**Last Updated**: 2025-01-15 16:45
**Project**: Stripe payment processing integration with webhook support
**Status**: Phase 2 in progress
**Version**: V1

---

## üìç Current Work

- **Phase**: [Phase 2 - Core Implementation](phase-2/)
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
- **Iteration**: [Iteration 2 - Error Handling](phase-2/task-3.md#iteration-2-error-handling) üöß IN PROGRESS
- **Focus**: Implementing comprehensive error handling with retry logic for Stripe API calls

---

## üìä Progress Overview

### Phase 1: Foundation ‚úÖ COMPLETE

**Goal**: Establish project structure and core data models
**Status**: 100% complete (5/5 iterations)

**Tasks**:
- ‚úÖ **Task 1**: Project Setup (3/3 iterations)
  - ‚úÖ Iteration 1: Repository Structure
  - ‚úÖ Iteration 2: Dependencies & Configuration
  - ‚úÖ Iteration 3: Development Environment
- ‚úÖ **Task 2**: Core Models (2/2 iterations)
  - ‚úÖ Iteration 1: Entity Design
  - ‚úÖ Iteration 2: Validation Logic

### Phase 2: Core Implementation üöß IN PROGRESS

**Goal**: Build payment processing and webhook handling functionality
**Status**: 40% complete (6/15 iterations)

**Tasks**:
- ‚úÖ **Task 1**: Database Layer (2/2 iterations)
  - ‚úÖ Iteration 1: Repository Pattern
  - ‚úÖ Iteration 2: Transaction Support
- ‚úÖ **Task 2**: Business Logic (3/3 iterations)
  - ‚úÖ Iteration 1: Payment Service Core
  - ‚úÖ Iteration 2: State Management
  - ‚úÖ Iteration 3: Validation Rules
- üöß **Task 3**: API Integration (1/4 iterations) ‚Üê **CURRENT**
  - ‚úÖ Iteration 1: REST Client Setup
  - üöß Iteration 2: Error Handling ‚Üê **ACTIVE**
  - ‚è≥ Iteration 3: Retry Logic
  - ‚è≥ Iteration 4: Integration Tests
- ‚è≥ **Task 4**: Webhook Handler (0/3 iterations)
  - ‚è≥ Iteration 1: Signature Verification
  - ‚è≥ Iteration 2: Event Processing
  - ‚è≥ Iteration 3: Idempotency
- ‚è≥ **Task 5**: Authentication (0/3 iterations)
  - ‚è≥ Iteration 1: Token Management
  - ‚è≥ Iteration 2: Security Middleware
  - ‚è≥ Iteration 3: Rate Limiting

### Phase 3: Testing & Hardening ‚è≥ PENDING

**Goal**: Comprehensive testing and production readiness
**Status**: Not started (0/8 iterations)

**Tasks**:
- ‚è≥ **Task 1**: Test Suite (0/3 iterations)
  - ‚è≥ Iteration 1: Unit Tests
  - ‚è≥ Iteration 2: Integration Tests
  - ‚è≥ Iteration 3: E2E Tests
- ‚è≥ **Task 2**: Error Scenarios (0/2 iterations)
  - ‚è≥ Iteration 1: Edge Cases
  - ‚è≥ Iteration 2: Failure Recovery
- ‚è≥ **Task 3**: Performance Testing (0/2 iterations)
  - ‚è≥ Iteration 1: Load Testing
  - ‚è≥ Iteration 2: Optimization
- ‚è≥ **Task 4**: Documentation (0/1 iteration)
  - ‚è≥ Iteration 1: API Docs & Guides

---

## üìö Framework Patterns Demonstrated

This example project demonstrates Flow's **Resolution Items Pattern**:

- **See**: [phase-2/task-3.md](phase-2/task-3.md) - Iteration 1 and 2
- **Pattern**: During brainstorming, each subject produces "Resolution Items"
- **Consolidation**: `/flow-brainstorming-review` consolidates all Resolution Items into single Action Items list
- **Benefit**: Prevents scattered action items, ensures brainstorming flows cleanly into implementation

---

## üí° Key Decisions

**Decision Needed**: Should we implement circuit breaker pattern for retry logic?
- Option A: Add circuit breaker now - More resilient, but adds complexity
- Option B: Defer to V2 - Ship V1 faster, add sophistication later
- **Recommendation**: Option B - Basic retry (exponential backoff, 3 attempts) is sufficient for V1. Circuit breaker can wait.

**Resolved**:
- **2025-01-13**: Retry Strategy - Using exponential backoff with 3 retries max. Balances reliability with user experience.
- **2025-01-14**: Error Taxonomy - Mapping Stripe errors to domain errors to decouple domain logic from Stripe SDK.
- **2025-01-13**: Circuit Breaker Deferred to V2 - Adds complexity, not critical for V1 launch.
EXAMPLE_DASHBOARD_EOF
}

get_example_plan() {
  cat <<'EXAMPLE_PLAN_EOF'
# Payment Gateway Integration - Development Plan

> **üìñ Framework Guide**: See [DEVELOPMENT_FRAMEWORK.md](DEVELOPMENT_FRAMEWORK.md) for complete Flow methodology
> **üìç Current Progress**: See [DASHBOARD.md](DASHBOARD.md) for real-time status tracking
> **üéØ Purpose**: Integrate Stripe payment processing with credit card support and webhook handling

**Created**: 2025-01-08
**Version**: V1
**Plan Location**: `.flow/` (managed by Flow framework)

---

## Overview

### Purpose

Build a production-ready payment gateway integration that allows our platform to accept credit card payments through Stripe. The system must handle synchronous payment processing, asynchronous webhook notifications for payment events, and provide robust error handling with retry logic for transient failures.

This integration is critical for monetization and must meet PCI compliance requirements while maintaining <2s response time for payment operations.

### Goals

**Primary Goals**:
- Process credit card payments via Stripe API with <2s response time
- Handle webhook events for async payment state notifications (payment succeeded, failed, refunded)
- Implement automatic retry logic for transient API failures (3 attempts, exponential backoff)
- Maintain 99.9% payment processing success rate (excluding card declines)
- Ensure PCI compliance through proper token handling (no raw card data stored)

**Success Criteria**:
- Payment processing works end-to-end in production
- All webhook events handled correctly with idempotency
- Error rate < 0.1% (excluding legitimate declines)
- Test coverage > 85% for payment critical paths
- Security audit passed for PCI compliance

### Scope

**V1 Scope** (Current Session):
- Credit card payment processing (charges API)
- Basic subscription support (create, cancel)
- Webhook handler for critical events: `payment_intent.succeeded`, `payment_intent.failed`, `charge.refunded`
- Retry logic: 3 attempts with exponential backoff (1s, 2s, 4s)
- Error handling: Map Stripe errors to domain errors
- Basic authentication with API keys
- USD currency only
- Payment history storage in PostgreSQL

---

## Architecture

### System Context

The payment gateway integration follows a layered architecture with clear separation of concerns: API Layer (request handling), Service Layer (business logic), Integration Layer (Stripe API wrapper), and Data Layer (persistence).

**Components**:
- **PaymentService**: Orchestrates payment processing flow (createPayment, processPayment, refundPayment)
- **StripeClient**: Stripe API wrapper with retry logic and error mapping (singleton pattern)
- **WebhookHandler**: Processes incoming Stripe webhook events with signature verification and idempotency
- **PaymentRepository**: Payment data persistence with ACID transaction support
- **ErrorMapper**: Translates Stripe errors to domain errors for decoupling

**Key Dependencies**:
- **Stripe Node SDK** (v12.18.0): Official API client with TypeScript support
- **Existing Auth Service**: User authentication for protected endpoints
- **PostgreSQL** (v14+): Database with transaction support for payment state

**Reference Implementations**:
- **Existing PayPal Integration** (`src/legacy/billing.ts`): Webhook signature validation pattern
- **Shipment Webhook Handler** (`src/webhooks/shipment.ts`): Idempotency pattern using event IDs

---

## DO / DON'T Guidelines

**‚úÖ DO**:
- Always validate webhook signatures before processing events (security critical)
- Use transactions for all payment state changes (data integrity)
- Map Stripe errors to domain errors immediately (decouple from provider)
- Implement idempotency for webhook event processing (handle duplicate events)
- Log all payment operations for audit trail (PCI compliance)
- Use exponential backoff for retries (avoid thundering herd)

**‚ùå DO NOT**:
- Store raw card numbers in database (PCI violation - use tokens only)
- Skip webhook signature verification (security risk)
- Hard-code Stripe error codes in business logic (tight coupling)
- Process duplicate webhook events (use event ID deduplication)
- Return detailed error messages to client for declined cards (security)
- Retry non-transient errors (e.g., card declined, invalid request)

---

## Notes & Learnings

**Design Decisions**:
- **2025-01-13**: Using exponential backoff with 3 retries max for API calls - balances reliability with user experience
- **2025-01-14**: Mapping Stripe errors to domain errors - decouples domain logic from Stripe SDK, enables future provider switching
- **2025-01-13**: Deferring circuit breaker pattern to V2 - basic retry is sufficient for V1, reduces complexity

**References**:
- [Stripe API Docs](https://stripe.com/docs/api): Official API reference
- [Webhook Best Practices](https://stripe.com/docs/webhooks/best-practices): Security and idempotency patterns
EXAMPLE_PLAN_EOF
}

get_example_task_standalone() {
  cat <<'EXAMPLE_TASK_STANDALONE_EOF'
# Task 1: Project Setup

**Status**: ‚úÖ COMPLETE
**Phase**: [Phase 1 - Foundation](../DASHBOARD.md#phase-1-foundation)
**Purpose**: Set up project structure, dependencies, and development environment

---

## Task Overview

Initialize the payment gateway project with proper directory structure, install required dependencies (Stripe SDK, testing frameworks), and configure the development environment for local development.

**Why This Task**: Foundation must be solid before building payment features. Proper setup prevents technical debt and configuration issues later.

**Dependencies**: None (first task in project)

---

## Iterations

### ‚úÖ Iteration 1: Repository Structure

**Goal**: Create src/ directory structure and initialize project configuration
**Status**: ‚úÖ COMPLETE

---

#### Action Items

- [x] Create directory structure (src/api, src/services, src/integrations, src/repositories)
- [x] Initialize package.json with required dependencies
- [x] Install Stripe SDK (stripe@12.18.0)
- [x] Install TypeScript and configure tsconfig.json (strict mode)
- [x] Create .env.example with required environment variables
- [x] Write README.md with setup instructions

---

#### Implementation - Iteration 1: Repository Structure

**Status**: ‚úÖ COMPLETE

**Implementation Notes**:
- Created feature-based directory structure (group by feature, not by type)
  - Pattern: src/{feature}/{api|service|repository}/
  - Rationale: Easier to navigate, better encapsulation
- Stripe SDK v12 uses ESM modules, required updating tsconfig.json moduleResolution
- Needed to add `@types/node` for TypeScript type definitions
- TypeScript strict mode enabled to catch type errors early

**Files Modified**:
- `package.json` - Dependencies and scripts
- `tsconfig.json` - TypeScript configuration with strict mode
- `.env.example` - Environment variable template
- `README.md` - Setup and development instructions
- Created `src/` directory structure

**Verification**:
- ‚úÖ All dependencies installed successfully (no vulnerabilities)
- ‚úÖ TypeScript compiles without errors
- ‚úÖ Test connection to Stripe API successful (test mode)

---

### ‚úÖ Iteration 2: Dependencies & Configuration

**Goal**: Install testing frameworks and configure database
**Status**: ‚úÖ COMPLETE

---

#### Action Items

- [x] Install Jest and testing utilities
- [x] Configure jest.config.js
- [x] Set up database connection and migration framework
- [x] Create initial schema migration for payments table
- [x] Verify setup by running database migrations

---

#### Implementation - Iteration 2: Dependencies & Configuration

**Status**: ‚úÖ COMPLETE

**Implementation Notes**:
- Jest for unit tests, custom simulation scripts for integration tests
  - Rationale: Jest for fast unit tests, simulation scripts for realistic E2E tests without hitting live API
- PostgreSQL connection pooling requires max 10 connections for local dev
- Database migrations run successfully on all environments (local, staging)

**Files Modified**:
- `jest.config.js` - Jest testing configuration
- `src/database/connection.ts` - PostgreSQL connection pooling
- `migrations/001_create_payments_table.sql` - Initial schema

**Verification**:
- ‚úÖ Database migrations run successfully
- ‚úÖ Jest test runner configured and working
- ‚úÖ All team members able to set up locally

---

### ‚úÖ Iteration 3: Development Environment

**Goal**: Finalize local development setup and validate end-to-end
**Status**: ‚úÖ COMPLETE

---

#### Action Items

- [x] Create npm scripts for development workflow (dev, build, test, migrate)
- [x] Set up hot-reload for local development
- [x] Add linting and formatting (ESLint, Prettier)
- [x] Validate entire setup with smoke test
- [x] Document common development tasks in README

---

#### Implementation - Iteration 3: Development Environment

**Status**: ‚úÖ COMPLETE

**Implementation Notes**:
- Added npm scripts: `npm run dev`, `npm run build`, `npm test`, `npm run migrate`
- Hot-reload working with nodemon for fast iteration
- ESLint + Prettier configured with team coding standards
- Smoke test validates Stripe connection, database connection, and TypeScript compilation

**Files Modified**:
- `package.json` - Added development scripts
- `.eslintrc.js` - ESLint configuration
- `.prettierrc` - Prettier configuration
- `scripts/smoke-test.ts` - Smoke test for local setup validation
- `README.md` - Updated with development workflow instructions

**Verification**:
- ‚úÖ `npm run dev` starts server with hot-reload
- ‚úÖ `npm test` runs all tests successfully
- ‚úÖ `npm run migrate` applies database migrations
- ‚úÖ Smoke test passes (Stripe + DB + TypeScript all working)
- ‚úÖ All team members successfully completed setup

---

## Task Notes

**Key Decisions**:
- Feature-based directory structure chosen over layer-based structure for better encapsulation
- TypeScript strict mode enabled despite slight learning curve - better type safety worth it
- Jest + simulation scripts hybrid approach for testing - fast unit tests + realistic integration tests

**References**:
- [Stripe Node SDK](https://github.com/stripe/stripe-node): Official SDK documentation
- [TypeScript Handbook](https://www.typescriptlang.org/docs/handbook/tsconfig-json.html): Configuration guide
EXAMPLE_TASK_STANDALONE_EOF
}

get_example_task_iterations() {
  cat <<'EXAMPLE_TASK_ITERATIONS_EOF'
# Task 3: API Integration

**Status**: üöß IN PROGRESS
**Phase**: [Phase 2 - Core Implementation](../DASHBOARD.md#phase-2-core-implementation)
**Purpose**: Integrate with Stripe REST API for payment processing

---

## Task Overview

Build a robust Stripe API client with error handling, retry logic for transient failures, and comprehensive integration tests. This is the core integration layer that all payment operations depend on.

**Why This Task**: Payment processing requires reliable communication with Stripe API. Without proper error handling and retry logic, transient network issues or API hiccups would cause payment failures and poor user experience.

**Dependencies**:
- **Requires**: Task 1 (Database Layer) - need PaymentRepository for state persistence
- **Requires**: Task 2 (Business Logic) - need PaymentService interface definitions
- **Blocks**: Task 4 (Webhook Handler) - webhook processing depends on API client
- **Blocks**: Task 5 (Authentication) - auth tokens stored via API calls

**Estimated Complexity**: High (4 iterations expected)

**Risk Level**: High - Core payment functionality depends on this

---

## Iterations

### ‚úÖ Iteration 1: REST Client Setup

**Goal**: Create Stripe API client wrapper with authentication and configuration

**Status**: ‚úÖ COMPLETE (2025-01-12)

---

#### Brainstorming Session - REST Client Architecture

**Focus**: Design API client abstraction layer and authentication flow

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: Client Architecture Pattern

**Decision**: Use singleton pattern with lazy initialization

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe SDK maintains connection pool internally
- Multiple client instances would create redundant connections and waste resources
- Lazy initialization delays credential validation until first use (fast app startup)
- Singleton ensures consistent configuration across the application

**Resolution Items**:
- Create `StripeClient` singleton class in src/integrations/stripe/
- Implement lazy initialization in constructor (init on first API call)
- Add credential validation on first API call (fail fast if misconfigured)
- Export singleton instance for import across codebase

---

##### ‚úÖ Subject 2: Authentication Flow

**Decision**: Use API key from environment variable with startup validation

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe best practices recommend environment-based configuration
- Supports different keys per environment (dev/staging/prod)
- Validation at startup prevents runtime errors from missing/invalid keys
- Fails fast with clear error message if key is missing or malformed

**Resolution Items**:
- Load `STRIPE_API_KEY` from environment variables
- Validate key format at startup (must start with `sk_test_` or `sk_live_`)
- Throw descriptive error if key is missing or invalid
- Log masked key on startup for debugging (sk_***...last4chars)

---

##### ‚úÖ Subject 3: API Timeout Configuration

**Decision**: Set 30-second timeout for API calls, configurable via environment

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Stripe recommends 30s timeout for payment operations
- Prevents indefinite hanging on network issues
- Configurable via environment for different deployment scenarios
- Balance between reliability (long enough for legit slow requests) and responsiveness (not too long)

**Resolution Items**:
- Configure default timeout of 30 seconds
- Make timeout configurable via `STRIPE_API_TIMEOUT_MS` env var
- Add timeout handling in API call wrapper
- Log timeout events for monitoring

---

#### Action Items

<!--
  FRAMEWORK PATTERN: Resolution Items ‚Üí Action Items Flow

  Notice how this Action Items list is a CONSOLIDATION of all Resolution Items from
  the 3 resolved subjects above. This is the core pattern:

  1. During brainstorming: Each subject produces "Resolution Items"
  2. When done brainstorming: Run /flow-brainstorming-review
  3. AI consolidates all Resolution Items into single Action Items list here
  4. During implementation: Work from this consolidated list (NOT from individual subjects)

  This prevents scattered action items and ensures all brainstorming decisions flow
  into implementation in a structured way.
-->

(Consolidated from Resolution Items above by `/flow-brainstorming-review`)

- [x] Create `StripeClient` singleton class in src/integrations/stripe/
- [x] Implement lazy initialization in constructor (init on first API call)
- [x] Add credential validation on first API call (fail fast if misconfigured)
- [x] Export singleton instance for import across codebase
- [x] Load `STRIPE_API_KEY` from environment variables
- [x] Validate key format at startup (must start with `sk_test_` or `sk_live_`)
- [x] Throw descriptive error if key is missing or invalid
- [x] Log masked key on startup for debugging (sk_***...last4chars)
- [x] Configure default timeout of 30 seconds
- [x] Make timeout configurable via `STRIPE_API_TIMEOUT_MS` env var
- [x] Add timeout handling in API call wrapper
- [x] Log timeout events for monitoring

---

#### Implementation - Iteration 1: REST Client Setup

**Status**: ‚úÖ COMPLETE (2025-01-12)

**Implementation Notes**:
- Created `src/integrations/stripe/StripeClient.ts` with singleton pattern
- Implemented lazy initialization - Stripe SDK initialized on first `getInstance()` call
- Added comprehensive key validation (format check + test API call)
- Discovered: Stripe SDK v12 changed API - using `paymentIntents` instead of deprecated `charges`
- Added utility method `maskApiKey()` for safe logging
- Performance: Singleton initialization takes ~50ms (acceptable for lazy init)

**Files Modified**:
- `src/integrations/stripe/StripeClient.ts` - Created new file (187 lines)
- `src/config/env.ts` - Added STRIPE_API_KEY and STRIPE_API_TIMEOUT_MS validation
- `src/integrations/stripe/index.ts` - Barrel export for clean imports
- `scripts/stripe-client.scripts.ts` - Created test file with connection verification

**Verification**:
- ‚úÖ All tests passing in stripe-client.scripts.ts
- ‚úÖ API key validation working correctly (rejects invalid keys)
- ‚úÖ Singleton pattern verified (same instance returned on multiple calls)
- ‚úÖ Timeout configuration working (tested with slow network simulation)
- ‚úÖ Connection to Stripe test API successful
- ‚úÖ Code review completed by team

**Bugs Discovered**:
None in current scope, but found issue in existing ErrorHandler (see Pre-Implementation Tasks in Iteration 2)

---

### üöß Iteration 2: Error Handling

**Goal**: Implement comprehensive error handling and error taxonomy mapping

**Status**: üöß IN PROGRESS (Implementing)

---

#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

---

##### ‚úÖ Pre-Task 1: Refactor Legacy ErrorHandler

**Completed**: 2025-01-14

**Why Blocking**: Current ErrorHandler class doesn't support async retry logic needed for Stripe API calls

**Scope** (< 30 min):
- Update ErrorHandler.ts to support async error handlers
- Add `retryAsync()` method
- Update 3 existing call sites to use new async pattern

**Files**:
- `src/utils/ErrorHandler.ts` - Add async support
- `src/services/BillingService.ts` - Update to use retryAsync()
- `src/services/PaymentService.ts` - Update to use retryAsync()
- `tests/utils/ErrorHandler.test.ts` - Add async tests

**Test**: Run existing test suite to ensure no regressions

**Changes Made**:
- Added `retryAsync<T>(fn: () => Promise<T>, options)` method to ErrorHandler
- Updated ErrorHandler to handle Promise-based operations
- Migrated BillingService and PaymentService to use retryAsync()
- All existing tests pass + 5 new async tests added
- No breaking changes to existing sync error handling

---

#### Brainstorming Session - Error Handling Strategy

**Focus**: Design error taxonomy, retry logic, and error recovery patterns

**Subjects to Discuss**:
(All subjects resolved)

**Resolved Subjects**:

---

##### ‚úÖ Subject 1: Error Taxonomy

**Decision**: Map Stripe errors to domain-specific error types using ErrorMapper class

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Decouples domain logic from Stripe SDK (enables future provider switching)
- Provides consistent error handling across application
- Enables easier testing with mocked errors
- Business logic doesn't need to know about Stripe-specific error codes

**Error Categories**:
- `PaymentDeclinedError` - Card declined (insufficient funds, incorrect details, etc.)
- `PaymentAuthenticationError` - 3D Secure or authentication required
- `PaymentProcessingError` - Stripe API or network error (retryable)
- `PaymentConfigurationError` - API key or configuration issue (not retryable)
- `PaymentValidationError` - Invalid request parameters (not retryable)

**Resolution Items**:
- Create `ErrorMapper` class in src/integrations/stripe/
- Define domain error types in src/errors/
- Map all Stripe error codes to domain errors
- Add tests for error mapping (all Stripe error codes covered)

---

##### ‚úÖ Subject 2: Retry Strategy

**Decision**: Implement exponential backoff with 3 retries for transient errors only

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Exponential backoff prevents overwhelming Stripe API during issues
- 3 retries balances reliability (handle transient failures) with user experience (don't wait too long)
- Retry delays: 1s, 2s, 4s (total 7s max additional wait)
- Only retry transient errors (network issues, 5xx responses), not permanent errors (4xx client errors)

**Retry Decision Logic**:
- Retry: Network timeout, Stripe 500/502/503/504, rate limit (429)
- Don't retry: Card declined (402), invalid request (400), authentication errors (401)

**Resolution Items**:
- Create `RetryPolicy` class with exponential backoff algorithm
- Implement retry logic in StripeClient wrapper
- Add configuration for max retries (default 3, configurable via env)
- Add configuration for base delay (default 1000ms, configurable via env)
- Log retry attempts with attempt number and delay
- Add tests for retry scenarios (success after N retries, exhausted retries)

---

##### ‚úÖ Subject 3: Error Logging

**Decision**: Log all errors with structured logging including request context and retry attempts

**Resolution Type**: D (Iteration Action Items)

**Rationale**:
- Structured logs enable better monitoring and debugging
- Request context (payment ID, user ID, amount) helps trace issues
- Retry attempt numbers help understand system behavior under failures
- Sensitive data (API keys, card numbers) must be redacted

**Log Format**:
```typescript
{
  level: 'error',
  message: 'Stripe API call failed',
  paymentId: 'pay_123',
  userId: 'user_456',
  stripeErrorCode: 'card_declined',
  retryAttempt: 2,
  timestamp: '2025-01-15T14:30:00Z'
}
```

**Resolution Items**:
- Add structured logging to StripeClient
- Log all API errors with full context
- Redact sensitive data before logging
- Add retry attempt number to logs
- Integrate with existing logging infrastructure

---

##### ‚úÖ Subject 4: Circuit Breaker Pattern

**Decision**: Skip circuit breaker for V1, defer to V2

**Resolution Type**: B (Documentation)

**Rationale**:
- Circuit breaker adds complexity (state management, monitoring, configuration)
- Stripe API has robust rate limiting and rarely has prolonged outages
- Our expected V1 volume (<100 requests/min) is low risk for cascade failures
- Retry logic with exponential backoff provides sufficient resilience for V1
- Can add circuit breaker in V2 when we have production metrics to tune thresholds

**Documentation Update**:
Added circuit breaker to PLAN.md V2 scope with reasoning and implementation notes

---

#### Action Items

<!-- See comment in Iteration 1 for explanation of Resolution Items ‚Üí Action Items flow -->

(Consolidated from Resolution Items above by `/flow-brainstorming-review`)

- [x] Create `ErrorMapper` class in src/integrations/stripe/
- [x] Define domain error types in src/errors/
- [x] Map all Stripe error codes to domain errors
- [x] Add tests for error mapping (all Stripe error codes covered)
- [x] Create `RetryPolicy` class with exponential backoff algorithm
- [x] Implement retry logic in StripeClient wrapper
- [x] Add configuration for max retries (default 3, configurable via env)
- [x] Add configuration for base delay (default 1000ms, configurable via env)
- [x] Log retry attempts with attempt number and delay
- [x] Add tests for retry scenarios (success after N retries, exhausted retries)
- [x] Add structured logging to StripeClient
- [x] Log all API errors with full context
- [x] Redact sensitive data before logging
- [x] Add retry attempt number to logs
- [x] Integrate with existing logging infrastructure

---

#### Implementation - Iteration 2: Error Handling

**Status**: üöß IN PROGRESS (2025-01-15)

**Implementation Notes**:
- Created `src/integrations/stripe/ErrorMapper.ts` (98 lines)
  - Comprehensive mapping of all Stripe error codes
  - Includes error code reference documentation
- Created `src/integrations/stripe/RetryPolicy.ts` (76 lines)
  - Exponential backoff algorithm implementation
  - Configurable via STRIPE_MAX_RETRIES and STRIPE_RETRY_BASE_DELAY_MS env vars
- Updated `src/integrations/stripe/StripeClient.ts` to use ErrorMapper and RetryPolicy
  - All API calls wrapped with retry logic
  - Errors mapped before thrown to service layer
- Created `src/errors/payment/` directory with domain error classes
  - PaymentDeclinedError
  - PaymentProcessingError
  - PaymentConfigurationError
  - PaymentValidationError
  - PaymentAuthenticationError
- Added structured logging to all error paths
  - Using existing logger with additional context fields
  - Sensitive data redaction working correctly
- Discovered: Stripe SDK throws different error types for network vs API errors, needed special handling

**Files Modified**:
- `src/integrations/stripe/StripeClient.ts` - Added error handling and retry (220 lines now, +33)
- `src/integrations/stripe/ErrorMapper.ts` - Created (98 lines)
- `src/integrations/stripe/RetryPolicy.ts` - Created (76 lines)
- `src/errors/payment/PaymentDeclinedError.ts` - Created (18 lines)
- `src/errors/payment/PaymentProcessingError.ts` - Created (18 lines)
- `src/errors/payment/PaymentConfigurationError.ts` - Created (18 lines)
- `src/errors/payment/PaymentValidationError.ts` - Created (18 lines)
- `src/errors/payment/PaymentAuthenticationError.ts` - Created (18 lines)
- `src/errors/payment/index.ts` - Barrel export (8 lines)
- `scripts/error-handling.scripts.ts` - Created test file (156 lines)
  - Tests all error mapping scenarios
  - Tests retry logic with simulated failures
  - Tests exhausted retry scenarios

**Verification** (In Progress):
- ‚úÖ Error mapping tests passing (all Stripe error codes covered)
- ‚úÖ Retry logic tests passing (success after retries, exhausted retries)
- ‚úÖ Exponential backoff working correctly (measured actual delays)
- ‚úÖ Structured logging working (verified log format)
- ‚úÖ Sensitive data redaction working
- [ ] Integration test with real Stripe test API (in progress)
- [ ] Team code review (scheduled for 2025-01-16)

**Next Steps**:
1. Complete integration test with Stripe test API
2. Get code review approval
3. Mark iteration complete
4. Move to Iteration 3

---

### ‚è≥ Iteration 3: Advanced Retry Logic

**Goal**: Add jitter to exponential backoff and implement retry budget pattern

**Status**: ‚è≥ PENDING

**Note**: This iteration will be planned after Iteration 2 is complete. Initial thoughts:
- Add jitter to prevent thundering herd problem
- Implement retry budget to prevent excessive retries across all requests
- May defer some advanced features to V2 based on Iteration 2 outcomes

---

### ‚è≥ Iteration 4: Integration Tests

**Goal**: Comprehensive test coverage with Stripe API simulation

**Status**: ‚è≥ PENDING

**Note**: This iteration focuses on end-to-end integration testing:
- Simulate all Stripe API responses (success, errors, timeouts)
- Test retry logic with controlled network conditions
- Verify error mapping for all error codes
- Performance testing (measure API call latency with retries)

---

## Task Notes

**Discoveries**:
- Stripe SDK already implements connection pooling internally (no need for custom pool)
- Stripe SDK v12 uses `paymentIntents` API instead of deprecated `charges` API
- Error codes changed in Stripe API v2023-10-16 (updated error taxonomy accordingly)
- Stripe webhooks can deliver out of order (must handle idempotently in Task 4)
- Network timeouts throw different error type than API errors (needed special handling)

**Decisions**:
- Using Stripe Node SDK v12.18.0 (latest stable)
- NOT implementing custom connection pool (Stripe SDK handles it better)
- NOT implementing circuit breaker for V1 (defer to V2)
- Using exponential backoff over fixed delay (more efficient)
- Retry 3 times max (balance between reliability and user experience)

**Performance**:
- Stripe API calls average 200-300ms response time
- With 3 retries and exponential backoff, worst case is ~7s additional wait
- Total max time for payment call: 30s timeout + 7s retry delay = 37s (acceptable)
- Singleton initialization overhead: ~50ms (one-time cost)

**References**:
- Stripe API Docs: https://stripe.com/docs/api
- Stripe Error Codes: https://stripe.com/docs/error-codes
- Stripe Best Practices: https://stripe.com/docs/api/errors/handling
- Existing PayPal integration: `src/legacy/billing.ts` (learned webhook validation pattern)
- Similar retry logic: `src/utils/HttpClient.ts` (reused exponential backoff algorithm)

**Team Feedback**:
- Code review from @alice (2025-01-12): Suggested adding timeout configuration - added ‚úÖ
- Code review from @bob (2025-01-14): Requested more comprehensive error tests - added ‚úÖ
- Architecture review (2025-01-13): Approved singleton pattern and retry strategy ‚úÖ
EXAMPLE_TASK_ITERATIONS_EOF
}

get_skills_guide() {
  cat <<'SKILLS_GUIDE_EOF'
# Flow Framework Skills Guide

Complete guide for creating effective Agent Skills for the Flow framework.

## Table of Contents

1. [Overview](#overview)
2. [Writing Effective Descriptions](#writing-effective-descriptions)
3. [When to Use allowed-tools](#when-to-use-allowed-tools)
4. [Single-File vs Multi-File Decision](#single-file-vs-multi-file-decision)
5. [Testing Skill Activation](#testing-skill-activation)
6. [Common Pitfalls](#common-pitfalls)
7. [Troubleshooting](#troubleshooting)

---

## Overview

Agent Skills are **model-invoked** capabilities - Claude autonomously decides when to use them based on your request and the Skill's description. This differs from slash commands which are **user-invoked** (you explicitly type `/command`).

**Key Principle**: Skills provide awareness and context, not authority. They help Claude understand Flow patterns while keeping the human as the driver.

---

## Writing Effective Descriptions

The `description` field (max 1024 characters) is **critical** for Skill discovery. It must include:

### Formula

1. **What the Skill does** (capability)
2. **When to use it** (specific trigger phrases users would say)
3. **What it provides** (outcome/guidance)

### Good Example

```yaml
description: Navigate Flow framework's multi-file architecture (DASHBOARD.md, PLAN.md, phase-N/task-M.md). Use when user asks "where am I", "what's next", "show status", "current work", or wants to understand project structure. Provides dashboard-first navigation guidance.
```

**Why it works**:
- ‚úÖ Describes capability: "Navigate multi-file architecture"
- ‚úÖ Lists specific triggers: "where am I", "what's next", "show status"
- ‚úÖ States outcome: "dashboard-first navigation guidance"
- ‚úÖ Within 1024 char limit

### Bad Example

```yaml
description: Helps with navigation
```

**Why it fails**:
- ‚ùå Vague: "Helps with" is too general
- ‚ùå No triggers: Claude won't know when to activate
- ‚ùå No outcome: What does it provide?

### Trigger Phrase Best Practices

**Include natural language users would actually say**:
- ‚úÖ "what should I work on next?"
- ‚úÖ "let's implement this"
- ‚úÖ "review the plan"
- ‚ùå "navigate_flow_structure" (too technical)
- ‚ùå "use skill" (too meta)

**Cover variations**:
- "What's next?" / "What should I do next?" / "Where am I?"
- "Let's code" / "Time to implement" / "Start building"
- "Check the plan" / "Review status" / "Verify completion"

---

## When to Use allowed-tools

The `allowed-tools` field restricts which tools Claude can use when a Skill is active.

### When to Restrict (Read-Only Skills)

**Use `allowed-tools: Read, Grep, Glob` for**:
- **Navigation Skills**: Only read files, don't modify
- **Review Skills**: Inspect code/plans without changes
- **Status Skills**: Check state without altering it

**Example**:
```yaml
---
name: flow-navigator
description: Navigate Flow framework's multi-file architecture...
allowed-tools: Read, Grep, Glob
---
```

**Benefits**:
- Prevents accidental modifications
- Faster (no permission prompts for read operations)
- Clear intent (inspection only)

### When NOT to Restrict (Implementation Skills)

**Omit `allowed-tools` for**:
- **Planning Skills**: Need to create/modify files
- **Implementation Skills**: Need full tool access
- **Documentation Skills**: Need write access

**Example**:
```yaml
---
name: flow-implementer
description: Guide implementation workflow...
# No allowed-tools - needs write access
---
```

---

## Single-File vs Multi-File Decision

Use this decision tree:

### Use Single-File Template (`_TEMPLATE/`)

**When**:
- ‚úÖ Skill fits in < 200 lines
- ‚úÖ No supporting documentation needed
- ‚úÖ Instructions are straightforward
- ‚úÖ Few examples needed

**Examples**: flow-navigator, flow-reviewer (read-only, simple workflows)

### Use Multi-File Template (`_TEMPLATE-MULTI/`)

**When**:
- ‚úÖ Skill requires > 200 lines
- ‚úÖ Detailed reference documentation needed
- ‚úÖ Multiple complex examples
- ‚úÖ Templates or scripts to include

**Examples**: flow-planner (many templates), flow-architect (extensive guidance)

### Progressive Disclosure Pattern

Multi-file Skills use **progressive disclosure** - Claude only loads supporting files when needed:

```markdown
# SKILL.md (always loaded)
Quick start instructions here.

For details, see [REFERENCE.md](REFERENCE.md).  # Loaded only if user needs details

## Examples
See [EXAMPLES.md](EXAMPLES.md) for scenarios.  # Loaded only for examples
```

**Benefits**:
- Keeps context manageable
- Fast initial activation
- Deep dive available when needed

---

## Testing Skill Activation

After creating a Skill, test that it activates correctly:

### Step 1: Deploy Skill

```bash
# Build and deploy
./build-standalone.sh
./flow.sh
```

### Step 2: Test Trigger Phrases

Use **exact trigger phrases from description**:

```
# For flow-navigator
User: "What should I work on next?"
Expected: Skill activates, reads DASHBOARD.md, provides navigation

# For flow-planner
User: "Let's add a new task"
Expected: Skill activates, suggests /flow-task-add, shows task structure

# For flow-implementer
User: "Time to implement"
Expected: Skill activates, checks brainstorming, uses /flow-implement-start
```

### Step 3: Verify Activation

**Signs Skill activated correctly**:
- Claude references Skill content in response
- Appropriate guidance provided
- Correct tools used (respecting allowed-tools if set)

**Signs Skill did NOT activate**:
- Generic response without Skill context
- Wrong workflow suggested
- No mention of Flow patterns

### Step 4: Refine Description

If Skill doesn't activate:
1. Add more trigger phrase variations to description
2. Make description more specific
3. Ensure trigger phrases match how users actually talk
4. Test again

---

## Common Pitfalls

### 1. Vague Descriptions

**Problem**: `description: "For working with Flow"`
**Solution**: Be specific about what, when, and how

### 2. Missing Trigger Phrases

**Problem**: Description doesn't include phrases users would say
**Solution**: Add natural language triggers: "Use when user asks '...'"

### 3. Description Too Long

**Problem**: 2000 character description (exceeds 1024 limit)
**Solution**: Be concise, move details to SKILL.md body

### 4. Wrong allowed-tools Setting

**Problem**: Read-only Skill without allowed-tools restriction
**Solution**: Add `allowed-tools: Read, Grep, Glob` for inspection-only Skills

### 5. Duplicate Functionality

**Problem**: Skill overlaps with existing slash command
**Solution**: Skills complement commands, don't replace them. Skill = awareness, command = execution

### 6. Too Broad Scope

**Problem**: One Skill trying to do everything
**Solution**: Keep Skills focused on one capability, compose multiple Skills

### 7. Testing with Wrong Phrases

**Problem**: Testing with phrases not in description
**Solution**: Test with exact trigger phrases from description field

---

## Troubleshooting

### Skill Doesn't Activate

**Check**:
1. Description includes specific trigger phrases
2. Description under 1024 characters
3. YAML syntax valid (opening/closing `---`)
4. Name format: lowercase, hyphens only, max 64 chars
5. Skill file deployed to `.claude/skills/flow-*/SKILL.md`

**Test**:
```bash
# Verify Skill exists
ls ~/.claude/skills/flow-navigator/SKILL.md
# or
ls .claude/skills/flow-navigator/SKILL.md

# Check description
cat .claude/skills/flow-navigator/SKILL.md | head -10
```

### Skill Activates at Wrong Time

**Problem**: Skill triggers when it shouldn't

**Solution**: Make description more specific:
- Add context about when NOT to use
- Narrow trigger phrases
- Add distinguishing terms

### Multiple Skills Conflict

**Problem**: Two Skills activate simultaneously or wrong one activates

**Solution**: Differentiate descriptions:
- Use distinct trigger terms
- Add specific context (e.g., "for navigation" vs "for implementation")
- Reference different user intents

### allowed-tools Not Working

**Problem**: Skill still asks for write permissions despite `allowed-tools: Read, Grep, Glob`

**Check**:
1. YAML syntax correct (comma-separated tools)
2. Tool names match exactly: Read, Grep, Glob (capitalized)
3. Skill redeployed after changes

---

## Validation Checklist

Before deploying a new Skill:

- [ ] **Name**: Lowercase, hyphens only, max 64 chars
- [ ] **Description**: Max 1024 chars, includes what/when/outcome
- [ ] **Trigger phrases**: Specific natural language phrases included
- [ ] **allowed-tools**: Set for read-only Skills
- [ ] **Instructions**: Clear step-by-step guidance
- [ ] **Examples**: At least one concrete example
- [ ] **Testing**: Skill activates with trigger phrases
- [ ] **No conflicts**: Doesn't overlap with other Skills
- [ ] **Focused scope**: One capability, not too broad

---

## Examples from Flow Skills

### flow-navigator (Read-Only)

```yaml
name: flow-navigator
description: Navigate Flow framework's multi-file architecture (DASHBOARD.md, PLAN.md, phase-N/task-M.md). Use when user asks "where am I", "what's next", "show status", "current work", or wants to understand project structure. Provides dashboard-first navigation guidance. Read-only access.
allowed-tools: Read, Grep, Glob
```

### flow-implementer (Full Access)

```yaml
name: flow-implementer
description: Guide implementation workflow in Flow framework. Use when user says "implement", "let's code", "start building", "time to write code", or is ready to execute action items. Enforces pre-implementation gate (brainstorming must be complete), guides use of /flow-implement-start and /flow-implement-complete commands, tracks action item completion.
# No allowed-tools - needs write access
```

### flow-reviewer (Read-Only)

```yaml
name: flow-reviewer
description: Review code and plan consistency in Flow framework. Use when user says "review", "verify", "check", "validate", or asks "is this complete". Validates status markers match actual state, checks for phantom tasks, ensures brainstorming complete before implementation. Read-only inspection using Read, Grep, Glob tools.
allowed-tools: Read, Grep, Glob
```

---

## References

- **Agent Skills Documentation**: https://docs.claude.com/en/docs/claude-code/skills
- **Agent Skills Best Practices**: https://docs.claude.com/en/docs/agents-and-tools/agent-skills/best-practices
- **Flow Framework**: framework/DEVELOPMENT_FRAMEWORK.md
- **Skills Templates**: framework/skills/_TEMPLATE/ and framework/skills/_TEMPLATE-MULTI/
SKILLS_GUIDE_EOF
}

# Skill extraction functions
get_skill_flow_navigator() {
  cat <<'SKILL_FLOW_NAVIGATOR_EOF'
---
name: flow-navigator
description: Navigate Flow framework's multi-file architecture (DASHBOARD.md, PLAN.md, phase-N/task-M.md). Use when user asks "where am I", "what's next", "what should I work on next", "what do I work on", "show status", "show me status", "current work", "what should I do", or wants to understand project structure and progress. Provides dashboard-first navigation guidance with status awareness.
allowed-tools: Read, Grep, Glob
---

# Flow Navigator

Navigate Flow framework projects using the dashboard-first pattern. This Skill helps you understand project structure, locate current work, and guide users through their Flow workflow.

## When to Use This Skill

Activate when the user asks questions like:
- "Where am I in the project?"
- "What should I work on next?"
- "Show me the current status"
- "What's left to do?"
- "Where are we in the plan?"
- "What's the progress?"

## Dashboard-First Navigation Pattern

**Golden Rule**: Always start with DASHBOARD.md before diving into details.

### Step 1: Read DASHBOARD.md

Start here for every navigation request:

```
Read .flow/DASHBOARD.md
```

The dashboard contains:
- **Current Work** section ‚Üí Shows active phase/task/iteration
- **Progress Overview** section ‚Üí Shows all phases with status markers
- **Key Decisions** section ‚Üí Important architectural choices
- **Success Criteria** section ‚Üí What "done" looks like

### Step 2: Parse Current Work

Extract the active work location:

```markdown
## üìç Current Work
- **Phase**: [Phase 2 - Implementation](phase-2/)
- **Task**: [Task 3 - API Integration](phase-2/task-3.md)
- **Iteration**: [Iteration 2 - Error Handling] üöß IMPLEMENTING
```

This tells you:
- Current phase number and name
- Current task number and file path
- Current iteration status

### Step 3: Read Task File (Only When Needed)

**When to read task files**:
- User asks for specific details about current task
- User wants to see action items or implementation notes
- User needs to understand iteration goals

**When to stay at dashboard level**:
- User only wants high-level status
- User asks "what's next" (dashboard shows this)
- Quick progress checks

**Pattern**:
```
Read .flow/phase-N/task-M.md
```

### Step 4: Use Status Markers

Understand progress through markers:
- ‚úÖ **COMPLETE** - Work finished and verified
- üöß **IN PROGRESS** - Currently being worked on
- ‚è≥ **PENDING** - Not started yet
- üé® **READY** - Brainstorming complete, ready to implement
- ‚ùå **CANCELLED** - Decided not to do this
- üîÆ **FUTURE** - Deferred to later version

## Common Navigation Patterns

### Pattern 1: "What should I do next?"

1. Read DASHBOARD.md
2. Check "Current Work" section
3. If iteration is üöß IMPLEMENTING: "Continue working on [iteration name]"
4. If no active work: Check next ‚è≥ PENDING task/iteration

### Pattern 2: "Where are we in the plan?"

1. Read DASHBOARD.md
2. Count completed vs total tasks/iterations
3. Report: "Phase X in progress, Y/Z tasks complete"
4. Highlight current focus from "Current Work"

### Pattern 3: "Show me the current status"

1. Read DASHBOARD.md
2. Report from "Current Work" section
3. Show active iteration with status marker
4. List immediate next steps

### Pattern 4: "What's left to do?"

1. Read DASHBOARD.md "Progress Overview"
2. Count ‚è≥ PENDING items across all phases
3. Provide breakdown: "X tasks, Y iterations remaining"
4. Optionally list high-level task names

## Multi-File Architecture

Flow projects use this structure:

```
.flow/
‚îú‚îÄ‚îÄ DASHBOARD.md          # Start here - high-level view
‚îú‚îÄ‚îÄ PLAN.md               # Architecture, scope, decisions
‚îú‚îÄ‚îÄ phase-1/
‚îÇ   ‚îú‚îÄ‚îÄ task-1.md         # Detailed task breakdown
‚îÇ   ‚îú‚îÄ‚îÄ task-2.md
‚îÇ   ‚îî‚îÄ‚îÄ task-3.md
‚îú‚îÄ‚îÄ phase-2/
‚îÇ   ‚îî‚îÄ‚îÄ task-1.md
‚îî‚îÄ‚îÄ phase-3/
    ‚îî‚îÄ‚îÄ task-1.md
```

**Navigation hierarchy**:
1. DASHBOARD.md ‚Üí Overview, current work, progress
2. PLAN.md ‚Üí Architecture decisions, scope boundaries
3. phase-N/task-M.md ‚Üí Detailed iterations, action items, implementation notes

## Read-Only Philosophy

**This Skill is for navigation, not modification.**

‚úÖ **DO**:
- Read files to understand structure
- Parse status markers
- Report progress to user
- Suggest next steps

‚ùå **DON'T**:
- Modify DASHBOARD.md or task files
- Update status markers
- Add/remove tasks
- Make architectural changes

**When user wants changes**: Guide them to appropriate slash commands:
- `/flow-task-start` - Start working on a task
- `/flow-implement-start` - Begin iteration implementation
- `/flow-implement-complete` - Mark iteration done
- `/flow-status` - Show current status (command version)

## Examples

### Example 1: Quick Status Check

```
User: "What's next?"

Response:
1. Read .flow/DASHBOARD.md
2. Parse "Current Work" section
3. Report: "You're on Phase 2, Task 3, Iteration 2 (Error Handling) üöß IN PROGRESS.

   Current focus: Implementing retry logic with exponential backoff.

   Next step: Complete this iteration, then move to Iteration 3 (Logging)."
```

### Example 2: Progress Overview

```
User: "Show me where we are in the plan"

Response:
1. Read .flow/DASHBOARD.md
2. Count completion:
   - Phase 1: ‚úÖ COMPLETE (3/3 tasks)
   - Phase 2: üöß IN PROGRESS (1/4 tasks complete)
   - Phase 3: ‚è≥ PENDING

3. Report: "Phase 2 in progress. Completed 4 of 10 total iterations.

   Currently implementing: Task 3, Iteration 2 (Error Handling)

   Remaining work: 2 iterations in current task, then 3 more tasks in Phase 2, plus Phase 3."
```

### Example 3: Lost User

```
User: "I'm confused, where am I?"

Response:
1. Read .flow/DASHBOARD.md
2. Show clear location:
   "You're in the **Flow Framework Agent Skills** project.

   üìç Current Location:
   - Phase: Phase 2 - Core Skills Implementation
   - Task: Task 1 - flow-navigator Skill
   - Iteration: Iteration 1 - SKILL.md creation üöß IMPLEMENTING

   What you're doing: Creating the navigation Skill file with dashboard-first instructions.

   Files you're working in: framework/skills/flow-navigator/SKILL.md"
```

## Best Practices

1. **Always read DASHBOARD.md first** - Never skip straight to task files
2. **Respect status markers** - They're the source of truth for progress
3. **Stay high-level by default** - Only dive into details when asked
4. **Use exact marker symbols** - Don't paraphrase (‚úÖ not "done", üöß not "working")
5. **Reference file paths** - Help user understand multi-file structure
6. **Suggest slash commands** - When user wants to make changes

## References

- **Dashboard-first approach**: See `/flow-status` slash command (reference model)
- **Status markers**: DEVELOPMENT_FRAMEWORK.md lines 1872-1968
- **Multi-file architecture**: DEVELOPMENT_FRAMEWORK.md lines 105-179
- **Quick Reference Guide**: DEVELOPMENT_FRAMEWORK.md lines 1-353
SKILL_FLOW_NAVIGATOR_EOF
}

get_skill_flow_planner() {
  cat <<'SKILL_FLOW_PLANNER_EOF'
---
name: flow-planner
description: Plan new features, tasks, and iterations in Flow framework. Use when user says "add task", "add a task", "create task", "plan feature", "plan this feature", "create iteration", "add iteration", "break this down", "how should we structure this", "how do I structure", or wants to add new work to the plan. Guides task structure decisions (standalone vs iterations), suggests brainstorming for complex features, references planning slash commands.
---

# Flow Planner

Help users plan and structure new work in Flow framework projects. This Skill guides AI in understanding Flow's planning patterns and using appropriate slash commands for adding phases, tasks, and iterations.

## When to Use This Skill

Activate when the user wants to add new work:
- "Add a new task"
- "Plan this feature"
- "Create iterations for..."
- "Break this down into steps"
- "How should we structure this?"
- "Add this to the plan"
- "What's the best way to organize this work?"

## Planning Philosophy

**Flow's Core Principle**: Plan before code. Structure work hierarchically (phases ‚Üí tasks ‚Üí iterations) with clear boundaries and iterative refinement.

**Key Decision**: Every task is EITHER:
- **Standalone** - Direct action items, no iterations
- **Task with Iterations** - No direct action items, ONLY iterations

**NEVER mix both** - This is the Golden Rule.

## Task Structure Decision Tree

```
User wants to add work
    ‚Üì
Is it complex/multi-step?
    ‚Üì
YES ‚Üí Task with Iterations
    ‚Üì
    Break into 3-5 iterations
    Each iteration = milestone
    ‚Üì
NO ‚Üí Standalone Task
    ‚Üì
    Direct action items
    Complete in one go
```

## Planning Slash Commands

### Core Commands

**`/flow-task-add [name]`**
- Creates new task file in current phase
- Use when: Adding new task to phase
- Prompts for: Standalone vs Iterations decision

**`/flow-iteration-add [name]`**
- Adds iteration to current task
- Use when: Breaking down complex task
- Creates: New iteration with goal, action items

**`/flow-phase-add [name]`**
- Creates new phase directory
- Use when: Major milestone or category of work
- Updates: DASHBOARD.md with new phase

**`/flow-brainstorm-start [topics]`**
- Begins design discussion
- Use when: Complex features need planning
- Helps: Make decisions before implementing

### When to Suggest Brainstorming

Use this decision tree to determine if brainstorming is needed:

```
User wants to add work
    ‚Üì
Does it involve design decisions?
    ‚Üì
YES ‚Üí Brainstorm first
    ‚Üì
    Multiple valid approaches?
    Trade-offs to discuss?
    Architectural impact?
    Integration complexity?
    ‚Üì
    Use /flow-brainstorm-start
    ‚Üì
NO ‚Üí Direct implementation
    ‚Üì
    Clear requirements?
    Single obvious approach?
    Isolated change?
    ‚Üì
    Skip brainstorming
```

**Always suggest brainstorming for**:
- Complex features with multiple approaches
- Architectural decisions needed
- Integration with external systems
- Performance-critical features
- Features affecting multiple areas
- Database schema changes
- API contract design
- Error handling strategies
- Security-sensitive features

**Skip brainstorming for**:
- Simple additions (new file, basic function)
- Well-defined tasks (clear requirements)
- Repetitive work (similar to previous tasks)
- Bug fixes with obvious solutions
- Trivial refactoring

## Brainstorming Subject Resolution Types

When users DO need brainstorming, help them understand how subjects get resolved. There are 4 types:

### Type A: Pre-Implementation Task

**When**: Small blocking code change needed BEFORE iteration starts

**Criteria**:
- Required for iteration (blocking)
- Small scope (< 30 min)
- Can be done independently
- Examples: Fix interface, rename file, update enum, fix bug

**Example Subject**:
```markdown
Subject: Type Definition Updates

Decision: Need to update PaymentStatus enum to include new states

Resolution Type: A (Pre-Implementation Task)

Action Items:
- [ ] Update PaymentStatus enum in types.ts
- [ ] Update 4 switch statements to handle new states
- [ ] Add tests for new states
```

**What happens**: These action items go into "Pre-Implementation Tasks" section and must be completed BEFORE main implementation starts.

### Type B: Immediate Documentation

**When**: Architectural decision that affects system design

**Criteria**:
- No code changes yet
- Updates PLAN.md Architecture section NOW
- Examples: Design pattern choice, API contract, data model

**Example Subject**:
```markdown
Subject: Error Recovery Strategy

Decision: Implement retry with exponential backoff, no circuit breaker for V1

Resolution Type: B (Documentation)

Documentation Update:
Updated PLAN.md Architecture section with retry strategy diagram and V2 scope for circuit breaker
```

**What happens**: AI updates PLAN.md immediately during brainstorming, before implementation.

### Type C: Auto-Resolved

**When**: Subject answered by another subject's decision

**Criteria**:
- No independent decision needed
- Cascade from another subject
- Examples: Implementation detail determined by architecture choice

**Example Subject**:
```markdown
Subject: Retry Delay Calculation

Decision: Use exponential backoff as decided in Subject 1

Resolution Type: C (Auto-Resolved by Subject 1)
```

**What happens**: No action items, just note which subject resolved this.

### Type D: Iteration Action Items

**When**: Substantial feature work that IS the iteration

**Criteria**:
- Main implementation work
- Takes significant time (> 30 min)
- Examples: Build API endpoint, implement validator, create service

**Example Subject**:
```markdown
Subject: Retry Implementation

Decision: Implement RetryPolicy class with configurable backoff strategy

Resolution Type: D (Iteration Action Items)

Action Items:
- [ ] Create RetryPolicy class
- [ ] Implement exponential backoff algorithm
- [ ] Add configuration for max retries, base delay
- [ ] Integrate with StripeClient
- [ ] Add tests for retry scenarios
```

**What happens**: These action items become the iteration's implementation action items.

## Complexity Indicators

Help users recognize task complexity:

### Simple Task (No Brainstorming)

**Indicators**:
- Single file change
- Clear requirements from user
- No integration points
- < 1 hour to complete
- Similar to previous work

**Examples**:
- "Add a validation function"
- "Fix typo in error message"
- "Export existing function"
- "Add logging statement"

**Guidance**: "This looks straightforward - I suggest a standalone task with direct action items. No brainstorming needed."

### Complex Task (Needs Brainstorming)

**Indicators**:
- Multiple approaches possible
- Affects system architecture
- Integration with external services
- > 4 hours to complete
- User says "I'm not sure how to..."

**Examples**:
- "Add authentication system"
- "Integrate Stripe payments"
- "Implement caching layer"
- "Design database schema"

**Guidance**: "This is complex - I recommend brainstorming first. Let's use `/flow-brainstorm-start` to discuss: [list 3-5 subjects]."

### Borderline Task (Ask User)

**Indicators**:
- Moderate complexity (2-4 hours)
- Some design decisions needed
- User hasn't expressed preference

**Examples**:
- "Add error handling to API"
- "Refactor data layer"
- "Implement search feature"

**Guidance**: "This could go either way. We could brainstorm the approach first, or jump into iterations if you already have a clear vision. Which would you prefer?"

## Task Structure Patterns

### Pattern 1: Standalone Task

**Use when**: Simple, focused work

```markdown
# Task 3: Add Logging

**Status**: ‚è≥ PENDING

## Action Items
- [ ] Create logger utility
- [ ] Add log statements to main functions
- [ ] Test logging output
- [ ] Update documentation
```

**Characteristics**:
- Single focus area
- Clear action items
- Can complete in one session
- No need to break down further

### Pattern 2: Task with Iterations (Skeleton ‚Üí Veins ‚Üí Flesh)

**Use when**: Complex, multi-phase work

```markdown
# Task 3: API Integration

**Status**: ‚è≥ PENDING

## Iterations

### ‚è≥ Iteration 1: Skeleton - Basic API client
**Goal**: Minimal working connection

### ‚è≥ Iteration 2: Veins - Core endpoints
**Goal**: Essential CRUD operations

### ‚è≥ Iteration 3: Flesh - Error handling & retry
**Goal**: Production-ready reliability
```

**Characteristics**:
- Multiple milestones
- Each iteration is testable
- Progressive complexity
- Incremental value delivery

**NO direct action items in task** - Only in iterations

### Pattern 3: Task with Brainstorming

**Use when**: Design decisions needed

```markdown
# Task 2: Database Schema

**Status**: üöß IN PROGRESS

## Iterations

### üöß Iteration 1: Design schema structure
**Status**: üöß BRAINSTORMING

#### Brainstorming Session
**Subjects to Discuss**:
1. ‚è≥ Table relationships - One-to-many or many-to-many?
2. ‚è≥ Indexing strategy - Which fields to index?
3. ‚è≥ Migration approach - How to handle schema changes?
```

**When to use**:
- Multiple valid approaches exist
- Trade-offs need discussion
- User needs to make decisions

## Step-by-Step Planning Workflow

### Step 1: Understand the Request

Ask clarifying questions:
- "What's the goal of this feature?"
- "Are there any constraints or requirements?"
- "Does this build on existing work?"

### Step 2: Determine Complexity

**Simple** ‚Üí Standalone task
**Complex** ‚Üí Task with iterations
**Uncertain** ‚Üí Suggest brainstorming first

### Step 3: Propose Structure

Present options to user:
```
I suggest structuring this as:

**Option A: Standalone Task** - "Add Feature X"
- Direct action items
- Single completion
- Estimated: 1-2 hours

**Option B: Task with 3 Iterations**
- Iteration 1: Basic implementation
- Iteration 2: Add advanced features
- Iteration 3: Polish and optimize
- Estimated: 4-6 hours

Which approach fits better?
```

### Step 4: Create the Structure

Use appropriate slash command:
- `/flow-task-add "Task Name"` - Create task
- Follow prompts for standalone vs iterations
- If iterations: `/flow-iteration-add "Iteration Name"` for each

### Step 5: Add Context

Help user fill in:
- **Purpose**: Why this task exists
- **Dependencies**: What it requires/blocks
- **Design Notes**: Key considerations
- **Action Items**: Concrete steps (standalone) or iteration goals (with iterations)

## Common Patterns

### Pattern: Feature Addition

```
User: "Add user authentication"

Response:
This is a complex feature - I suggest a task with 3 iterations:

1. Iteration 1: Basic login/logout (Skeleton)
2. Iteration 2: JWT tokens & session management (Veins)
3. Iteration 3: Password reset & email verification (Flesh)

Should we also brainstorm the auth approach first?
(OAuth, JWT, session-based, etc.)
```

### Pattern: Bug Fix

```
User: "Fix the pagination bug"

Response:
This sounds like a standalone task:

Task: Fix Pagination Bug
- [ ] Reproduce the issue
- [ ] Identify root cause
- [ ] Implement fix
- [ ] Add regression test
- [ ] Verify fix works

Does this structure work?
```

### Pattern: Refactoring

```
User: "Refactor the data layer"

Response:
This is complex - let's break it down:

Task: Refactor Data Layer (4 iterations)
1. Iteration 1: Extract interfaces
2. Iteration 2: Migrate to new pattern
3. Iteration 3: Update tests
4. Iteration 4: Remove old code

We should brainstorm:
- New architecture pattern
- Migration strategy
- Backwards compatibility

Should I start `/flow-brainstorm-start` for this?
```

## Best Practices

1. **Always clarify complexity** - Don't assume, ask user
2. **Suggest iterations for complex work** - Better to break down than have massive tasks
3. **Propose brainstorming when uncertain** - Design first, implement second
4. **Use Flow's metaphor** - Skeleton ‚Üí Veins ‚Üí Flesh
5. **Reference slash commands** - Guide user to use Flow's tools
6. **Keep iterations focused** - Each should have clear goal and completion criteria

## Task Structure Golden Rules

**DO**:
- ‚úÖ Standalone task with action items
- ‚úÖ Task with iterations (no direct action items)
- ‚úÖ Each iteration has specific goal
- ‚úÖ Iterations build on each other

**DON'T**:
- ‚ùå Mix action items and iterations in same task
- ‚ùå Create task with only 1 iteration (make it standalone)
- ‚ùå Make iterations too large (break down further)
- ‚ùå Skip brainstorming for complex features

## Iteration Sizing Guidelines

**Good Iteration Size**:
- Completable in 1-2 hours
- Clear completion criteria
- Testable milestone
- Adds incremental value

**Too Large** (split into multiple iterations):
- "Implement entire feature"
- "Build and test everything"
- No clear milestone

**Too Small** (combine or make standalone):
- "Add one line of code"
- "Rename a variable"
- Trivial changes

## Examples

### Example 1: User Asks to Add Feature

```
User: "I want to add real-time notifications"

AI Response:
Let me help you plan this feature. Real-time notifications is complex - I suggest:

**Task: Real-Time Notifications** (3 iterations)

**Iteration 1: Skeleton - WebSocket Connection**
- Goal: Establish basic WebSocket connection
- Action items:
  - Set up WebSocket server
  - Implement client connection
  - Basic ping/pong keepalive

**Iteration 2: Veins - Notification System**
- Goal: Core notification sending/receiving
- Action items:
  - Design notification message format
  - Implement server-side broadcast
  - Add client-side handlers

**Iteration 3: Flesh - UI & Polish**
- Goal: User-facing notification display
- Action items:
  - Create notification UI component
  - Add notification history
  - Implement dismiss/mark-read

Before we start, should we brainstorm:
- WebSocket library choice (ws, socket.io, native)?
- Notification types and priority system?
- Persistence strategy?

Use `/flow-task-add "Real-Time Notifications"` to create this structure.
```

### Example 2: User Asks to Fix Bug

```
User: "The search filter isn't working correctly"

AI Response:
This looks like a standalone task - focused bug fix:

**Task: Fix Search Filter Bug**

**Action Items**:
- [ ] Reproduce the bug with test case
- [ ] Debug the filter logic
- [ ] Identify root cause (likely query building)
- [ ] Implement fix
- [ ] Add unit test for this scenario
- [ ] Verify fix resolves issue

Estimated: 1-2 hours

Use `/flow-task-add "Fix Search Filter Bug"` to create this task.
```

### Example 3: User Unsure How to Structure

```
User: "I need to integrate with Stripe for payments"

AI Response:
Stripe integration is substantial - let's think through the structure:

**Two approaches**:

**Option A: Task with 4 Iterations** (Recommended)
- Iteration 1: Setup Stripe client & test connection
- Iteration 2: Implement payment processing
- Iteration 3: Add webhook handling
- Iteration 4: Error handling & edge cases

**Option B: Brainstorm First** (For complex decisions)
Run `/flow-brainstorm-start` to discuss:
- Payment flow (one-time vs subscription)
- Error handling strategy
- Webhook security
- Testing approach (Stripe test mode)

Which approach do you prefer? Or should we brainstorm first?
```

### Example 4: Guiding Brainstorming Subject Resolution

```
User: "Let's brainstorm the retry logic for API calls"

AI Response:
Great! Let's start brainstorming. I'll suggest some subjects:

Subjects to Discuss:
1. Retry Strategy - Exponential backoff vs fixed delay vs linear?
2. Error Classification - Which errors should trigger retry vs immediate fail?
3. Max Retry Attempts - How many retries before giving up?
4. Existing Error Handler - Need to update ErrorHandler.ts to support async?
5. Timeout Configuration - Per-request timeout vs total operation timeout?

Use `/flow-brainstorm-start` to begin. I'll help you categorize each decision:
- Type A: Pre-implementation tasks (must do before main work)
- Type B: Architecture docs (update PLAN.md now)
- Type C: Auto-resolved (answered by other decisions)
- Type D: Main implementation work (the actual iteration)

---

[After discussing Subject 4...]

User: "We need to update ErrorHandler.ts to support async operations"

AI Response:
This sounds like Type A (Pre-Implementation Task). Let me confirm:

‚úÖ Is it blocking? YES - Can't implement retry logic without async support
‚úÖ Is it small? YES - Estimated 20-30 minutes
‚úÖ Can it be done independently? YES - Self-contained change

Resolution Type: A (Pre-Implementation Task)

Action Items:
- [ ] Update ErrorHandler.ts to support async operations
- [ ] Add retryAsync() method
- [ ] Update 3 existing call sites to use async version
- [ ] Add tests for async error handling

This will go into "Pre-Implementation Tasks" section and must be completed
BEFORE we run `/flow-implement-start`.

---

[After discussing Subject 1...]

User: "Let's use exponential backoff with base delay of 1 second"

AI Response:
This sounds like Type D (Iteration Action Items). Let me confirm:

‚úÖ Is it substantial work? YES - Core feature implementation
‚úÖ Does it take > 30 min? YES - Estimated 2-3 hours
‚úÖ Is it the main iteration work? YES - This IS what we're building

Resolution Type: D (Iteration Action Items)

Action Items:
- [ ] Create RetryPolicy class
- [ ] Implement exponential backoff algorithm (base: 1s, max: 32s)
- [ ] Add configuration for max retries (default: 3)
- [ ] Integrate with API client
- [ ] Add tests for retry scenarios

These become the iteration's implementation action items.
```

## Interaction with Other Flow Commands

**Planning Stage** (This Skill):
- `/flow-task-add` - Create task
- `/flow-iteration-add` - Add iterations
- `/flow-brainstorm-start` - Design decisions

**Implementation Stage** (flow-implementer Skill):
- `/flow-implement-start` - Begin work
- `/flow-implement-complete` - Finish iteration

**Navigation Stage** (flow-navigator Skill):
- `/flow-status` - Check progress
- `/flow-next` - What to do next

## References

- **Task Structure Rules**: DEVELOPMENT_FRAMEWORK.md lines 238-566
- **Brainstorming Pattern**: DEVELOPMENT_FRAMEWORK.md lines 1167-1797
- **Complete Workflow**: DEVELOPMENT_FRAMEWORK.md lines 614-940
- **Quick Reference**: DEVELOPMENT_FRAMEWORK.md lines 1-353
SKILL_FLOW_PLANNER_EOF
}

get_skill_flow_planner_templates() {
  cat <<'SKILL_FLOW_PLANNER_TEMPLATES_EOF'
# Flow Planning Templates

Ready-to-use templates for creating phases, tasks, and iterations in Flow framework. Copy and customize these structures for your planning needs.

## Template 1: Standalone Task

Use when: Simple, focused work that doesn't need breaking down

```markdown
# Task [N]: [Task Name]

**Status**: ‚è≥ PENDING
**Phase**: [Phase [N] - [Phase Name]](../DASHBOARD.md#phase-[n]-[phase-name])
**Purpose**: [Brief description of what this task accomplishes]

## Overview

[1-2 paragraphs explaining the task's context, why it's needed, and how it fits into the larger project]

## Action Items

- [ ] [Concrete action step 1]
- [ ] [Concrete action step 2]
- [ ] [Concrete action step 3]
- [ ] [Concrete action step 4]
- [ ] [Concrete action step 5]

## Notes

**Key Considerations**:
- [Important point to remember]
- [Trade-off or constraint]
- [Dependency or prerequisite]

**References**:
- [Link to related documentation]
- [Link to relevant framework section]
```

### Example: Standalone Task

```markdown
# Task 3: Add Request Logging

**Status**: ‚è≥ PENDING
**Phase**: [Phase 2 - Core Features](../DASHBOARD.md#phase-2-core-features)
**Purpose**: Add structured logging for all HTTP requests to aid debugging

## Overview

Currently, the application doesn't log HTTP requests, making it difficult to debug issues in production. This task adds middleware to log all incoming requests with relevant metadata (method, path, duration, status code).

## Action Items

- [ ] Create logging middleware function
- [ ] Add request ID generation
- [ ] Log request start (method, path, headers)
- [ ] Log request completion (status, duration)
- [ ] Add middleware to express app
- [ ] Test logging output format
- [ ] Update documentation

## Notes

**Key Considerations**:
- Use structured logging (JSON format)
- Don't log sensitive data (passwords, tokens)
- Include correlation IDs for request tracing

**References**:
- Express middleware docs
- Winston logging library
```

---

## Template 2: Task with Iterations

Use when: Complex, multi-step work that needs progressive refinement

```markdown
# Task [N]: [Task Name]

**Status**: ‚è≥ PENDING
**Phase**: [Phase [N] - [Phase Name]](../DASHBOARD.md#phase-[n]-[phase-name])
**Purpose**: [Brief description of what this task accomplishes]

## Overview

[1-2 paragraphs explaining the task's context, complexity, and why it's broken into iterations]

## Iterations

### ‚è≥ Iteration 1: [Skeleton] - [Minimal version]
**Goal**: [What minimal functionality this iteration delivers]
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] [Core action 1]
- [ ] [Core action 2]
- [ ] [Core action 3]

### ‚è≥ Iteration 2: [Veins] - [Core functionality]
**Goal**: [What essential features this iteration adds]
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] [Essential feature 1]
- [ ] [Essential feature 2]
- [ ] [Essential feature 3]

### ‚è≥ Iteration 3: [Flesh] - [Polish and edge cases]
**Goal**: [What production-ready features this iteration completes]
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] [Polish item 1]
- [ ] [Edge case handling 1]
- [ ] [Final touches 1]

## Notes

**Task Structure**:
- This task follows Flow's iterative pattern: Skeleton ‚Üí Veins ‚Üí Flesh
- Each iteration is independently testable and adds value
- No direct action items in task - only in iterations

**Dependencies**:
- [Prerequisite work that must be complete]
- [Related tasks that affect this one]

**References**:
- [Link to related documentation]
- [Link to framework patterns]
```

### Example: Task with Iterations

```markdown
# Task 2: User Authentication System

**Status**: ‚è≥ PENDING
**Phase**: [Phase 1 - Foundation](../DASHBOARD.md#phase-1-foundation)
**Purpose**: Implement secure user authentication with JWT tokens

## Overview

The application needs a complete authentication system supporting user registration, login, logout, and token-based session management. This is complex enough to warrant iterative development, building from basic login to full production-ready auth.

## Iterations

### ‚è≥ Iteration 1: Skeleton - Basic Login/Logout
**Goal**: Minimal working login/logout with password hashing
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Create User model with password field
- [ ] Implement password hashing (bcrypt)
- [ ] Create POST /login endpoint
- [ ] Create POST /logout endpoint
- [ ] Add basic session storage
- [ ] Test login/logout flow

### ‚è≥ Iteration 2: Veins - JWT Tokens & Auth Middleware
**Goal**: Secure token-based authentication for protected routes
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Generate JWT tokens on login
- [ ] Create auth middleware to verify tokens
- [ ] Add token to response headers
- [ ] Implement token refresh logic
- [ ] Add protected route examples
- [ ] Test token validation

### ‚è≥ Iteration 3: Flesh - Registration & Password Reset
**Goal**: Complete auth system with all user flows
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Create POST /register endpoint
- [ ] Add email verification flow
- [ ] Implement forgot-password endpoint
- [ ] Create password reset token system
- [ ] Add rate limiting to auth endpoints
- [ ] Test complete user lifecycle

## Notes

**Task Structure**:
- Skeleton: Get basic auth working
- Veins: Add security and token management
- Flesh: Polish with registration and recovery flows

**Dependencies**:
- Database schema must be set up
- Email service configured (for Iteration 3)

**References**:
- JWT library: jsonwebtoken
- DEVELOPMENT_FRAMEWORK.md lines 567-613
```

---

## Template 3: Individual Iteration

Use when: Adding a new iteration to an existing task

```markdown
### ‚è≥ Iteration [N]: [Iteration Name]
**Goal**: [Clear, specific goal this iteration achieves]
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] [Action step 1]
- [ ] [Action step 2]
- [ ] [Action step 3]
- [ ] [Action step 4]
- [ ] [Action step 5]

#### Design Notes
**Approach**: [Brief explanation of the implementation approach]

**Key Decisions**:
- [Important decision 1 and rationale]
- [Important decision 2 and rationale]

**Testing**: [How to verify this iteration works]
```

### Example: Individual Iteration

```markdown
### ‚è≥ Iteration 4: Add Redis Caching
**Goal**: Reduce database load by caching frequently accessed data
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Set up Redis client connection
- [ ] Identify cacheable queries (user profiles, product listings)
- [ ] Implement cache-aside pattern
- [ ] Add cache invalidation on updates
- [ ] Set appropriate TTLs for different data types
- [ ] Add cache hit/miss metrics
- [ ] Test cache behavior under load

#### Design Notes
**Approach**: Use cache-aside pattern where application checks cache first, then falls back to database. Invalidate cache entries on write operations.

**Key Decisions**:
- TTL: 5 minutes for user profiles, 1 hour for product listings
- Cache key format: `{resource}:{id}` (e.g., `user:123`)
- Invalidation: Delete on update, let expire on delete

**Testing**:
- Verify cache hits reduce DB queries
- Confirm stale data doesn't persist after updates
- Load test with Redis enabled vs disabled
```

---

## Template 4: Task with Brainstorming

Use when: Complex decisions need discussion before implementation

```markdown
# Task [N]: [Task Name]

**Status**: ‚è≥ PENDING
**Phase**: [Phase [N] - [Phase Name]](../DASHBOARD.md#phase-[n]-[phase-name])
**Purpose**: [Brief description]

## Overview

[Explanation of task and why it needs design discussion]

## Iterations

### ‚è≥ Iteration 1: Design [Core System]
**Goal**: Make key architectural decisions
**Status**: ‚è≥ PENDING

#### Brainstorming Session

**Subjects to Discuss**:
1. ‚è≥ **[Subject 1]** - [Key question to decide]
2. ‚è≥ **[Subject 2]** - [Trade-off to evaluate]
3. ‚è≥ **[Subject 3]** - [Approach to determine]

**Resolved Subjects**:
[Will be filled during `/flow-brainstorm-start`]

### ‚è≥ Iteration 2: Implement [Core]
**Goal**: Build based on design decisions
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] [Implementation step 1]
- [ ] [Implementation step 2]
- [ ] [Implementation step 3]

### ‚è≥ Iteration 3: [Additional Features]
**Goal**: [Next increment]
**Status**: ‚è≥ PENDING

## Notes

**Why Brainstorming First**:
- [Reason brainstorming is valuable]
- [What decisions need discussion]
```

### Example: Task with Brainstorming

```markdown
# Task 1: Database Schema Design

**Status**: ‚è≥ PENDING
**Phase**: [Phase 1 - Foundation](../DASHBOARD.md#phase-1-foundation)
**Purpose**: Design normalized database schema supporting all product requirements

## Overview

The database schema is foundational - poor choices here create technical debt. We need to discuss relationships, indexing strategy, and migration approach before implementation.

## Iterations

### ‚è≥ Iteration 1: Design Schema Structure
**Goal**: Finalize table structure, relationships, and indexing
**Status**: ‚è≥ PENDING

#### Brainstorming Session

**Subjects to Discuss**:
1. ‚è≥ **User-Product Relationship** - One-to-many or many-to-many with junction table?
2. ‚è≥ **Indexing Strategy** - Which columns to index? Composite indexes needed?
3. ‚è≥ **Soft Deletes** - Use soft deletes (deleted_at) or hard deletes?
4. ‚è≥ **Timestamps** - What audit fields (created_at, updated_at, created_by)?
5. ‚è≥ **Migration Approach** - How to handle schema changes in production?

**Resolved Subjects**:
[Will be filled during brainstorming]

### ‚è≥ Iteration 2: Create Initial Migration
**Goal**: Implement decided schema in SQL migration
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Write SQL migration file
- [ ] Create database models (ORM)
- [ ] Add indexes per brainstorming decisions
- [ ] Test migration up/down
- [ ] Seed test data

### ‚è≥ Iteration 3: Add Constraints and Triggers
**Goal**: Production-ready schema with validation
**Status**: ‚è≥ PENDING

#### Action Items
- [ ] Add foreign key constraints
- [ ] Create database triggers for audit fields
- [ ] Add check constraints for data validation
- [ ] Test constraint enforcement
- [ ] Document schema design

## Notes

**Why Brainstorming First**:
- Schema changes are expensive once production data exists
- Trade-offs between normalization and performance need discussion
- Team alignment on conventions (soft deletes, audit fields) needed upfront
```

---

## Template 5: Phase Structure

Use when: Adding a new phase to the project

```markdown
# Phase [N]: [Phase Name]

**Goal**: [High-level goal this phase accomplishes]
**Status**: ‚è≥ PENDING
**Complexity**: [Simple / Medium / Complex]

## Overview

[2-3 paragraphs explaining:
- What this phase delivers
- Why it's a distinct phase
- How it relates to previous/next phases]

## Tasks

1. **Task 1**: [Task Name] - [Brief description]
2. **Task 2**: [Task Name] - [Brief description]
3. **Task 3**: [Task Name] - [Brief description]

## Success Criteria

This phase is complete when:
- [ ] [Measurable outcome 1]
- [ ] [Measurable outcome 2]
- [ ] [Measurable outcome 3]

## Dependencies

**Requires** (must be done first):
- [Prerequisite phase or work]

**Blocks** (waiting on this):
- [Dependent phases or work]

## Notes

**Estimated Duration**: [Time estimate]
**Risk Level**: [Low / Medium / High]
**Key Challenges**: [Anticipated difficulties]
```

---

## Usage Guidelines

### When to Use Each Template

**Standalone Task**:
- Bug fixes
- Simple feature additions
- Documentation updates
- Configuration changes
- Estimated < 2 hours

**Task with Iterations**:
- Complex features
- System integrations
- Architecture changes
- New modules/services
- Estimated > 2 hours

**Task with Brainstorming**:
- Architectural decisions
- Multiple valid approaches
- Performance-critical features
- External integrations
- Trade-offs need discussion

### Customization Tips

1. **Adjust iteration count** - Use 2-5 iterations based on complexity
2. **Add sections as needed** - Testing Strategy, Performance Notes, Security Considerations
3. **Reference framework docs** - Link to relevant DEVELOPMENT_FRAMEWORK.md sections
4. **Include examples** - Add code snippets or diagrams when helpful
5. **Keep action items atomic** - Each checkbox is a clear, completable step

### Common Mistakes to Avoid

‚ùå **DON'T**: Mix standalone and iteration patterns in same task
‚úÖ **DO**: Choose one structure and stick with it

‚ùå **DON'T**: Create task with only 1 iteration
‚úÖ **DO**: Make it standalone if there's only one phase

‚ùå **DON'T**: Have action items both in task AND in iterations
‚úÖ **DO**: Action items only in iterations (for task-with-iterations pattern)

‚ùå **DON'T**: Make iterations too small (< 30 min) or too large (> 1 day)
‚úÖ **DO**: Size iterations to 1-3 hours of focused work

## References

- **Task Structure Rules**: DEVELOPMENT_FRAMEWORK.md lines 238-566
- **Brainstorming Patterns**: DEVELOPMENT_FRAMEWORK.md lines 1167-1797
- **Complete Workflow**: DEVELOPMENT_FRAMEWORK.md lines 614-940
- **Status Markers Guide**: DEVELOPMENT_FRAMEWORK.md lines 1872-1968
SKILL_FLOW_PLANNER_TEMPLATES_EOF
}

get_skill_flow_implementer() {
  cat <<'SKILL_FLOW_IMPLEMENTER_EOF'
---
name: flow-implementer
description: Guide implementation workflow in Flow framework. Use when user says "implement", "implement this", "let's code", "let's implement", "start building", "time to write code", "time to code", "execute action items", "ready to implement", or is ready to implement. Enforces pre-implementation gate (brainstorming must be complete), guides use of /flow-implement-start and /flow-implement-complete commands, tracks action item completion, ensures verification before marking work complete.
---

# Flow Implementer

Help users execute implementation work in Flow framework projects. This Skill ensures AI follows Flow's implementation pattern: verify readiness ‚Üí start implementation ‚Üí execute action items ‚Üí verify completion ‚Üí mark complete.

## When to Use This Skill

Activate when the user wants to start coding:
- "Let's implement this"
- "Start coding"
- "Build the feature"
- "Time to write code"
- "Ready to implement"
- "Execute the action items"
- "Begin implementation"

## Implementation Philosophy

**Flow's Core Principle**: Design before code. Implementation happens AFTER brainstorming is complete (if needed) and pre-implementation tasks are done.

**Key Gates**:
- **Pre-Implementation Gate**: Brainstorming must be ‚úÖ COMPLETE (if iteration had brainstorming)
- **Pre-Tasks Gate**: All pre-implementation tasks must be ‚úÖ COMPLETE
- **Verification Gate**: All action items done, tests passing, ready for next work

**Implementation Pattern**: Start ‚Üí Execute ‚Üí Verify ‚Üí Complete

## Pre-Implementation Gate Check

Before starting ANY implementation, verify readiness:

### Check 1: Brainstorming Status (if applicable)

```
IF iteration has brainstorming section:
    IF brainstorming status ‚â† ‚úÖ COMPLETE:
        ‚ùå BLOCK implementation
        SUGGEST: "Brainstorming must be completed first. Use `/flow-next-subject` to continue brainstorming."
    ELSE:
        ‚úÖ PASS gate
ELSE:
    ‚úÖ PASS gate (no brainstorming needed)
```

### Check 2: Pre-Implementation Tasks (if applicable)

```
IF iteration has "Pre-Implementation Tasks" section:
    IF any pre-task status ‚â† ‚úÖ COMPLETE:
        ‚ùå BLOCK implementation
        LIST incomplete pre-tasks
        SUGGEST: "Complete pre-tasks first, then use `/flow-implement-start`"
    ELSE:
        ‚úÖ PASS gate
ELSE:
    ‚úÖ PASS gate (no pre-tasks)
```

### Check 3: Iteration Status

```
IF iteration status = üöß IN PROGRESS:
    ‚úÖ PASS (already implementing)
IF iteration status = üé® READY or ‚è≥ PENDING:
    SUGGEST: "Use `/flow-implement-start` to begin implementation"
```

## Implementation Workflow

### Step 1: Start Implementation

**Command**: `/flow-implement-start`

**What it does**:
- Marks iteration üöß IN PROGRESS
- Creates "Implementation" section in task file
- Updates DASHBOARD.md current work

**When to suggest**: User is ready to code and gates passed

### Step 2: Execute Action Items

**Sequential Execution**:
1. Read action items from iteration (or brainstorming Type D subjects)
2. Execute each action item in order
3. Check off items as completed: `- [x] Action item`
4. Document progress in "Implementation Notes"

**Parallel Execution** (when safe):
- If action items are independent (no dependencies)
- Example: Creating multiple unrelated files
- Still check off sequentially for tracking

**Handling Blockers**:
```
IF encounter blocker during implementation:
    DOCUMENT blocker in Implementation Notes
    ASSESS severity:
        - Minor (< 15 min fix): Handle and continue
        - Major (> 15 min, out of scope): STOP and notify user
        - Blocking (cannot proceed): Mark iteration ‚ùå BLOCKED, notify user
```

### Step 3: Verify Completion

Before marking iteration complete, verify:

**Verification Checklist**:
- [ ] All action items checked off (‚úÖ)
- [ ] Code compiles/runs without errors
- [ ] Tests passing (if applicable)
- [ ] Files modified documented
- [ ] Implementation notes updated
- [ ] No unresolved blockers

**Testing Strategy** (from PLAN.md):
- Follow Testing Strategy section in PLAN.md
- Run tests according to project conventions
- Document test results in Implementation Notes

### Step 4: Complete Implementation

**Command**: `/flow-implement-complete`

**What it does**:
- Marks iteration ‚úÖ COMPLETE
- Updates completion date
- Updates DASHBOARD.md progress
- Advances to next iteration

**When to suggest**: All verification criteria met

## Implementation Slash Commands

### `/flow-implement-start`

**Use when**: Starting implementation for current iteration

**Prerequisites**:
- Brainstorming ‚úÖ COMPLETE (if applicable)
- Pre-tasks ‚úÖ COMPLETE (if applicable)
- Iteration status = üé® READY or ‚è≥ PENDING

**Effect**:
- Changes iteration status to üöß IN PROGRESS
- Creates implementation section in task file
- Updates DASHBOARD.md

### `/flow-implement-complete`

**Use when**: All action items done and verified

**Prerequisites**:
- All action items checked off
- Verification criteria met
- No unresolved blockers

**Effect**:
- Marks iteration ‚úÖ COMPLETE
- Updates completion date
- Advances to next iteration or task

## Action Item Execution Patterns

### Pattern 1: Sequential Implementation

**Use when**: Action items depend on each other

```markdown
Action Items:
- [x] Create database schema
- [x] Implement data access layer (depends on schema)
- [x] Add service layer (depends on DAL)
- [x] Create API endpoints (depends on service)
```

**Approach**:
1. Complete item 1
2. Verify item 1 works
3. Move to item 2
4. Repeat until all done

### Pattern 2: Parallel Implementation

**Use when**: Action items are independent

```markdown
Action Items:
- [ ] Create logger utility
- [ ] Create validator utility
- [ ] Create formatter utility
```

**Approach**:
1. Create all three files
2. Verify each works independently
3. Check off all items

### Pattern 3: Incremental Verification

**Use when**: Complex implementation with multiple steps

```markdown
Action Items:
- [x] Implement basic authentication (VERIFY: can login)
- [x] Add JWT token generation (VERIFY: tokens valid)
- [x] Add token refresh (VERIFY: refresh works)
- [x] Add logout (VERIFY: tokens invalidated)
```

**Approach**:
1. Complete one action item
2. Test/verify immediately
3. Document verification in notes
4. Move to next item

## Pre-Implementation Tasks Pattern

### What Are Pre-Implementation Tasks?

Small blocking tasks (< 30 min) that must be completed BEFORE main iteration work starts.

**Examples**:
- Refactor interface to support new pattern
- Update enum with missing values
- Fix bug in legacy code
- Rename file to match convention

### When to Complete Pre-Tasks

```
IF iteration has "Pre-Implementation Tasks" section:
    FOR EACH pre-task:
        Complete pre-task
        Mark ‚úÖ COMPLETE with date
        Document changes in pre-task section
    ONLY AFTER ALL PRE-TASKS DONE:
        Run /flow-implement-start for main iteration
```

### Pre-Task Structure

```markdown
#### Pre-Implementation Tasks

##### ‚è≥ Pre-Task 1: Update ErrorHandler to support async

**Why Blocking**: Retry logic requires async error handling

**Scope** (< 30 min):
- Update ErrorHandler.ts with async support
- Add retryAsync() method
- Update 3 call sites

**Files**:
- src/utils/ErrorHandler.ts

---

##### ‚úÖ Pre-Task 1: Update ErrorHandler to support async

**Completed**: 2025-10-30

**Changes Made**:
- Added async support to ErrorHandler class
- Implemented retryAsync() method with exponential backoff
- Updated call sites in BillingService, PaymentService, OrderService
- Added unit tests for async error handling

**Files Modified**:
- src/utils/ErrorHandler.ts (+42 lines)
- tests/utils/ErrorHandler.test.ts (+28 lines)
```

## Verification Best Practices

### What to Verify

**Code Quality**:
- [ ] No syntax errors
- [ ] No linting errors
- [ ] Follows project conventions
- [ ] Code is readable and well-structured

**Functionality**:
- [ ] Feature works as intended
- [ ] Edge cases handled
- [ ] Error handling implemented
- [ ] No regressions introduced

**Testing**:
- [ ] Unit tests pass
- [ ] Integration tests pass (if applicable)
- [ ] Manual testing done (if no automated tests)

**Documentation**:
- [ ] Implementation notes updated
- [ ] Files modified list complete
- [ ] Verification results documented

### When to Mark ‚ùå BLOCKED

Mark iteration ‚ùå BLOCKED when:
- External dependency not available
- Blocker requires > 1 hour to resolve
- Need user decision before proceeding
- Technical limitation discovered

**Blocked Pattern**:
```markdown
### ‚ùå Iteration 2: Error Handling

**Status**: ‚ùå BLOCKED

**Blocker**: Stripe SDK doesn't support custom retry logic in v12

**Options**:
A) Downgrade to Stripe SDK v11 (supports custom retry)
B) Wait for v13 release (eta 2 weeks)
C) Implement wrapper around SDK calls

**Waiting for**: User decision on approach
```

## Detailed Verification Guidance

For comprehensive guidance on verification, testing patterns, completion criteria, bug documentation, and decision-making, see **[VERIFICATION.md](VERIFICATION.md)**.

That resource includes:
- **Testing Patterns**: Unit testing, integration testing, manual testing checklists, and TDD patterns with complete code examples
- **What "Done" Looks Like**: 6 detailed completion criteria with examples
- **When to Document Bugs and Issues**: Bug documentation templates, severity levels, and fix-immediately vs defer guidance
- **Deciding: ‚ùå BLOCKED vs Continue**: Decision flowchart, 8 scenarios with examples, and real-world case studies

## Scope Boundary Rules

### When You Discover New Work

During implementation, if you discover issues NOT in current action items:

1. **STOP** - Don't make assumptions
2. **ASSESS** - Categorize the issue:
   - Syntax error in file you're editing? Fix and document
   - Missing functionality? Discuss with user
   - New feature idea? Defer to future iteration
   - Blocking bug? Propose pre-implementation task

3. **NOTIFY** user with structured options:
   - **Option A**: Create pre-implementation task (< 30 min, blocking)
   - **Option B**: Add as new brainstorming subject (design needed)
   - **Option C**: Handle immediately (if user approves)
   - **Option D**: Defer to separate iteration (after current work)

4. **AWAIT** user decision before proceeding

### Example: Scope Boundary Alert

```
‚ö†Ô∏è SCOPE BOUNDARY ALERT

During implementation of Iteration 2 (Error Handling), discovered:

**Issue**: PaymentService.ts uses deprecated error format that conflicts with new retry logic

**Impact**: Cannot complete current action item without addressing this

**Options**:
A) Create pre-implementation task (estimated 20 min):
   - Update PaymentService error format
   - Update 2 call sites
   - Add to Pre-Implementation Tasks section

B) Add as brainstorming subject:
   - Need to design error format standard across all services
   - Affects more than just PaymentService

C) Handle immediately:
   - Fix PaymentService.ts now as part of current work
   - Document change in Implementation Notes

D) Defer to separate iteration:
   - Work around issue for now
   - Create new iteration for error format standardization

Which approach would you prefer?
```

## Common Implementation Patterns

### Pattern: Feature Implementation

```
User: "Let's implement the authentication system"

AI Response:
I'll help you implement the authentication system. Let me check readiness:

‚úÖ Brainstorming Session - COMPLETE (4 subjects resolved)
‚úÖ Pre-Implementation Tasks - COMPLETE (updated User model)
‚úÖ Iteration Status - üé® READY

Ready to implement! Use `/flow-implement-start` to begin.

Action items from brainstorming:
1. Create AuthService class
2. Implement login/logout methods
3. Add JWT token generation
4. Integrate with API endpoints
5. Add authentication middleware

Estimated time: 3-4 hours

Should I start implementation?
```

### Pattern: Handling Blockers

```
User: "Start implementing the payment integration"

AI Response:
I'll help you implement payment integration. Let me check readiness:

‚ùå Pre-Implementation Tasks - INCOMPLETE

Found 2 incomplete pre-tasks:
1. ‚è≥ Pre-Task 1: Refactor PaymentConfig interface
2. ‚è≥ Pre-Task 2: Update environment variables

These tasks must be completed before main implementation. Should I help you complete them now?
```

### Pattern: Verification Before Completion

```
User: "Are we done with this iteration?"

AI Response:
Let me verify completion criteria:

‚úÖ All action items checked off (5/5)
‚úÖ Code compiles without errors
‚úÖ Tests passing (unit: 12/12, integration: 3/3)
‚úÖ Files modified documented (4 files)
‚úÖ Implementation notes updated
‚úÖ No unresolved blockers

Verification complete! All criteria met.

Use `/flow-implement-complete` to mark this iteration done and move to the next one.
```

### Pattern: Incremental Progress

```
User: "How's the implementation going?"

AI Response:
Implementation progress for Iteration 2: Error Handling

Completed (3/5):
- [x] Create RetryPolicy class
- [x] Implement exponential backoff algorithm
- [x] Add configuration for max retries

In Progress (1/5):
- [ ] Integrate with StripeClient ‚Üê CURRENT (60% done)

Pending (1/5):
- [ ] Add tests for retry scenarios

Estimated completion: 1 hour

Working on integrating RetryPolicy with StripeClient.ts. Will move to tests next.
```

## Interaction with Other Flow Skills

**Planning Stage** (flow-planner Skill):
- `/flow-task-add` - Create task
- `/flow-iteration-add` - Add iterations
- `/flow-brainstorm-start` - Design decisions

**Implementation Stage** (This Skill):
- `/flow-implement-start` - Begin work ‚Üê YOU ARE HERE
- `/flow-implement-complete` - Finish iteration ‚Üê YOU ARE HERE

**Navigation Stage** (flow-navigator Skill):
- `/flow-status` - Check progress
- `/flow-next` - What to do next

## References

- **Implementation Pattern**: DEVELOPMENT_FRAMEWORK.md lines 1798-1836
- **Status Markers**: DEVELOPMENT_FRAMEWORK.md lines 1872-1968
- **Brainstorming Pattern**: DEVELOPMENT_FRAMEWORK.md lines 1167-1797
- **Pre-Implementation Tasks**: DEVELOPMENT_FRAMEWORK.md lines 1683-1723
- **Scope Boundary Rules**: DEVELOPMENT_FRAMEWORK.md lines 339-540

## Implementation Gate Checklist

Before implementing, verify ALL gates passed:

```
[ ] Brainstorming complete (if applicable)
[ ] Pre-implementation tasks complete (if applicable)
[ ] Current iteration status = üé® READY or ‚è≥ PENDING
[ ] User confirmed ready to implement
```

If ALL checked ‚Üí Use `/flow-implement-start`

If ANY unchecked ‚Üí Address blockers first

## Completion Checklist

Before marking complete, verify ALL criteria met:

```
[ ] All action items checked off
[ ] Code compiles/runs
[ ] Tests passing
[ ] Files modified documented
[ ] Implementation notes updated
[ ] No unresolved blockers
[ ] Verification completed
```

If ALL checked ‚Üí Use `/flow-implement-complete`

If ANY unchecked ‚Üí Continue implementation
SKILL_FLOW_IMPLEMENTER_EOF
}

get_skill_flow_implementer_patterns() {
  cat <<'SKILL_FLOW_IMPLEMENTER_PATTERNS_EOF'
# Implementation Patterns

This document provides detailed patterns for handling pre-implementation tasks and executing action items in Flow framework.

## Table of Contents

1. [Pre-Implementation Tasks Pattern](#pre-implementation-tasks-pattern)
2. [Action Item Execution Best Practices](#action-item-execution-best-practices)
3. [Sequential vs Parallel Execution](#sequential-vs-parallel-execution)
4. [Breaking Down Large Action Items](#breaking-down-large-action-items)
5. [Common Implementation Scenarios](#common-implementation-scenarios)

---

## Pre-Implementation Tasks Pattern

### What Are Pre-Implementation Tasks?

**Pre-implementation tasks** are small, blocking pieces of work (< 30 min) that must be completed BEFORE starting the main iteration implementation.

**Key Characteristics**:
- **Small scope**: Can be completed in < 30 minutes
- **Blocking**: Main iteration cannot start without them
- **Independent**: Can be done separately from main work
- **Discovered during brainstorming**: Identified when resolving Type A subjects

### When to Create Pre-Implementation Tasks

Create pre-implementation tasks when you discover during brainstorming:

**Code Structure Issues**:
- Interface signature doesn't support new pattern
- Enum missing required values
- Type definitions need updates
- File naming doesn't match conventions

**Legacy Code Issues**:
- Old code doesn't support async operations
- Error handling pattern incompatible
- Deprecated API being used
- Missing error states

**Refactoring Needs**:
- Duplicate code needs extraction
- Hard-coded values need configuration
- Tight coupling needs decoupling
- Missing abstraction layer

**Bug Fixes**:
- Race condition in existing code
- Memory leak in utility function
- Off-by-one error in loop
- Missing null checks

### Pre-Implementation Task Structure

#### Template

```markdown
#### Pre-Implementation Tasks

These tasks MUST be completed BEFORE starting main implementation of this iteration.

##### ‚è≥ Pre-Task 1: [Name]

**Why Blocking**: [Explanation of why this blocks implementation]

**Scope** (< 30 min):
- [Specific change 1]
- [Specific change 2]
- [Specific change 3]

**Files**:
- [File path 1]
- [File path 2]

**Test**: [How to verify it's done]

---

##### ‚úÖ Pre-Task 1: [Name]

**Completed**: [Date]

**Changes Made**:
- [What was actually done]
- [Any deviations from plan]

**Files Modified**:
- [File path 1] ([+/-] X lines)
- [File path 2] ([+/-] Y lines)

**Verification**:
- [How it was tested]
```

### Example 1: Interface Update

**Before (Planning)**:

```markdown
##### ‚è≥ Pre-Task 1: Update PaymentProcessor interface

**Why Blocking**: Current interface doesn't support async retry logic needed for main implementation

**Scope** (< 30 min):
- Add `retryPolicy?: RetryPolicy` parameter to ProcessPaymentOptions
- Update 3 implementations (StripeProcessor, PayPalProcessor, MockProcessor)
- Update type definitions file

**Files**:
- src/types/payment.ts
- src/processors/StripeProcessor.ts
- src/processors/PayPalProcessor.ts
- src/processors/MockProcessor.ts

**Test**: TypeScript compiles without errors, all processors accept new parameter
```

**After (Completed)**:

```markdown
##### ‚úÖ Pre-Task 1: Update PaymentProcessor interface

**Completed**: 2025-10-30

**Changes Made**:
- Added `retryPolicy?: RetryPolicy` to ProcessPaymentOptions interface
- Updated all 3 processor implementations with optional parameter
- Added JSDoc comments explaining retry policy usage
- Discovered MockProcessor was missing error handling - fixed that too

**Files Modified**:
- src/types/payment.ts (+8 lines)
- src/processors/StripeProcessor.ts (+12 lines)
- src/processors/PayPalProcessor.ts (+10 lines)
- src/processors/MockProcessor.ts (+15 lines, +8 for error handling fix)

**Verification**:
- TypeScript compiles cleanly
- All unit tests passing
- Mock tests verify optional parameter behavior
```

### Example 2: Enum Update

**Before (Planning)**:

```markdown
##### ‚è≥ Pre-Task 2: Add missing payment states to enum

**Why Blocking**: Retry logic needs "pending_retry" and "failed_permanent" states

**Scope** (< 15 min):
- Add two new states to PaymentStatus enum
- Update 4 switch statements to handle new states
- Update state transition documentation

**Files**:
- src/types/payment.ts
- src/services/PaymentService.ts
- src/services/RetryService.ts
- docs/payment-states.md

**Test**: No switch statement exhaustiveness errors, docs updated
```

**After (Completed)**:

```markdown
##### ‚úÖ Pre-Task 2: Add missing payment states to enum

**Completed**: 2025-10-30

**Changes Made**:
- Added `PENDING_RETRY` and `FAILED_PERMANENT` to PaymentStatus enum
- Updated 4 switch statements with proper handling
- Added state transition diagram to docs
- Also added `CANCELLED_BY_USER` state (discovered during implementation)

**Files Modified**:
- src/types/payment.ts (+3 states)
- src/services/PaymentService.ts (+8 lines)
- src/services/RetryService.ts (+6 lines)
- docs/payment-states.md (+state diagram)

**Verification**:
- TypeScript exhaustiveness checks pass
- All switch statements handle new states
- State diagram reviewed and accurate
```

### Example 3: Legacy Code Refactor

**Before (Planning)**:

```markdown
##### ‚è≥ Pre-Task 3: Update ErrorHandler to support async operations

**Why Blocking**: Current ErrorHandler is synchronous, retry logic requires async

**Scope** (< 30 min):
- Add `handleAsync()` method to ErrorHandler class
- Implement async error recovery pattern
- Update 3 existing call sites to use async version
- Keep sync version for backwards compatibility

**Files**:
- src/utils/ErrorHandler.ts
- src/services/BillingService.ts
- src/services/PaymentService.ts
- src/services/OrderService.ts

**Test**: All services use async handler, no regressions in error handling
```

**After (Completed)**:

```markdown
##### ‚úÖ Pre-Task 3: Update ErrorHandler to support async operations

**Completed**: 2025-10-30

**Changes Made**:
- Added `handleAsync()` method with Promise-based error recovery
- Implemented exponential backoff helper function
- Updated all 3 call sites to async pattern
- Kept sync `handle()` method for backwards compatibility
- Added comprehensive unit tests for async error handling

**Files Modified**:
- src/utils/ErrorHandler.ts (+65 lines)
- tests/utils/ErrorHandler.test.ts (+42 lines)
- src/services/BillingService.ts (+8 lines)
- src/services/PaymentService.ts (+12 lines)
- src/services/OrderService.ts (+6 lines)

**Verification**:
- All unit tests passing (12 new tests)
- Integration tests with services passing
- No regressions in existing error handling
- Async pattern verified with multiple retry scenarios
```

### Pre-Implementation Task Workflow

```
1. During brainstorming, identify Type A subjects
   ‚Üì
2. /flow-brainstorm-review creates Pre-Implementation Tasks section
   ‚Üì
3. Complete each pre-task sequentially
   ‚Üì
4. Mark each ‚úÖ COMPLETE with date and details
   ‚Üì
5. Verify all pre-tasks done
   ‚Üì
6. ONLY THEN run /flow-implement-start for main iteration
```

---

## Action Item Execution Best Practices

### General Principles

**1. Read Before Execute**
- Read ALL action items before starting
- Understand dependencies between items
- Identify which can be parallel vs sequential

**2. Check Off Immediately**
- Mark item `[x]` as soon as completed
- Don't batch multiple completions
- Provides clear progress tracking

**3. Document as You Go**
- Update Implementation Notes with discoveries
- Note any deviations from plan
- Document workarounds or alternative approaches

**4. Verify Incrementally**
- Test after each action item (if possible)
- Don't wait until end to verify everything
- Catch issues early while context is fresh

### Action Item Checklist Format

**Good Action Items** (specific, measurable):
```markdown
- [ ] Create `src/payment/RetryPolicy.ts` class
- [ ] Implement exponential backoff algorithm (base: 1s, max: 32s)
- [ ] Add configuration for max retries (default: 3)
- [ ] Integrate RetryPolicy with StripeClient.processPayment()
- [ ] Add unit tests for retry scenarios (success, failure, timeout)
```

**Poor Action Items** (vague, unmeasurable):
```markdown
- [ ] Handle retries
- [ ] Make it work
- [ ] Add tests
- [ ] Fix issues
```

### Execution Order Strategies

#### Strategy 1: Dependency Order

Execute items based on what depends on what.

**Example**:
```markdown
1. [x] Create RetryPolicy class (nothing depends on this yet)
2. [x] Implement backoff algorithm (depends on class existing)
3. [x] Add configuration (depends on algorithm structure)
4. [x] Integrate with client (depends on all above)
5. [x] Add tests (depends on everything working)
```

#### Strategy 2: Risk Order

Do risky/uncertain items first to catch blockers early.

**Example**:
```markdown
1. [x] Research Stripe API rate limits (uncertain, might change approach)
2. [x] Implement retry logic (core feature, most risk)
3. [x] Add configuration (low risk, straightforward)
4. [x] Add logging (low risk, enhancement)
5. [x] Add tests (low risk, verification)
```

#### Strategy 3: Value Order

Deliver most valuable functionality first.

**Example**:
```markdown
1. [x] Implement basic payment processing (core value)
2. [x] Add error handling (high value, prevents crashes)
3. [x] Integrate with database (high value, persistence)
4. [x] Add logging (medium value, debugging)
5. [x] Add rate limiting (low value, optimization)
```

### Handling Blockers

**When you encounter a blocker**:

1. **Document the blocker immediately**:
   ```markdown
   **Implementation Notes**:
   - Created RetryPolicy class
   - Implemented backoff algorithm
   - **BLOCKER**: Stripe SDK v12 doesn't support custom retry hooks
     - Cannot complete action item 4 (integrate with client)
     - Options: downgrade to v11, wait for v13, implement wrapper
     - Needs user decision
   ```

2. **Notify user with options**:
   ```
   ‚ö†Ô∏è BLOCKER ENCOUNTERED

   Action Item: "Integrate RetryPolicy with StripeClient"

   Issue: Stripe SDK v12 doesn't expose retry hooks for custom logic

   Options:
   A) Downgrade to Stripe SDK v11 (supports custom retry, but older)
   B) Wait for SDK v13 release (has retry hooks, ETA 2 weeks)
   C) Implement wrapper around SDK calls (adds complexity)
   D) Mark iteration ‚ùå BLOCKED and move to different work

   Which approach should we take?
   ```

3. **Wait for user decision** before proceeding

### Parallel Action Items

**Safe for parallel execution**:
- Independent files
- Different modules
- No shared state
- Can verify independently

**Example**:
```markdown
Action Items (can do in parallel):
- [ ] Create `logger.ts` utility
- [ ] Create `validator.ts` utility
- [ ] Create `formatter.ts` utility
- [ ] Create `parser.ts` utility

All four can be created simultaneously.
```

**NOT safe for parallel**:
- One depends on another
- Shared file/state
- Must be tested together

**Example**:
```markdown
Action Items (MUST be sequential):
- [ ] Create database schema
- [ ] Create data access layer (needs schema)
- [ ] Create service layer (needs DAL)
- [ ] Create API endpoints (needs service)

These have dependencies - do in order.
```

---

## Sequential vs Parallel Execution

### Sequential Execution Pattern

**When to use**: Action items have dependencies

**Pattern**:
```
Item 1 ‚Üí Item 2 ‚Üí Item 3 ‚Üí Item 4
```

**Example: Building API Endpoint**

```markdown
#### Action Items (Sequential)

- [x] Define API request/response types
  ‚Üì (next item needs types)
- [x] Implement validation logic
  ‚Üì (next item needs validation)
- [x] Create service method
  ‚Üì (next item needs service)
- [x] Create API endpoint handler
  ‚Üì (next item needs endpoint)
- [x] Add integration tests

**Why Sequential**: Each item builds on the previous one.
```

**Execution Strategy**:
1. Complete item 1 fully
2. Verify item 1 works
3. Move to item 2
4. Repeat until all done

### Parallel Execution Pattern

**When to use**: Action items are independent

**Pattern**:
```
    ‚îå‚îÄ Item 1
    ‚îú‚îÄ Item 2
    ‚îú‚îÄ Item 3
    ‚îî‚îÄ Item 4
```

**Example: Creating Utility Functions**

```markdown
#### Action Items (Parallel)

- [x] Create logger utility
- [x] Create validator utility
- [x] Create formatter utility
- [x] Create error handler utility

**Why Parallel**: None depend on each other, all are standalone utilities.
```

**Execution Strategy**:
1. Create all files at once
2. Implement all functions
3. Verify each independently
4. Check off all items

### Hybrid Execution Pattern

**When to use**: Mix of dependent and independent items

**Pattern**:
```
Item 1 ‚Üí  ‚îå‚îÄ Item 2a
          ‚îú‚îÄ Item 2b  ‚Üí Item 3
          ‚îî‚îÄ Item 2c
```

**Example: Feature with Multiple Components**

```markdown
#### Action Items (Hybrid)

- [x] Create base authentication interface
  ‚Üì
  ‚îå‚îÄ [x] Implement JWT auth provider (uses interface)
  ‚îú‚îÄ [x] Implement OAuth provider (uses interface)
  ‚îî‚îÄ [x] Implement API key provider (uses interface)
  ‚Üì
- [x] Create auth middleware (uses all providers)
- [x] Add tests for all auth methods

**Why Hybrid**: Interface must exist first, then providers can be built in parallel, then middleware needs all providers.
```

**Execution Strategy**:
1. Complete item 1 (interface)
2. Complete items 2a, 2b, 2c in parallel
3. Complete item 3 (middleware)
4. Complete item 4 (tests)

### Decision Tree: Sequential or Parallel?

```
Does Item B need Item A's output?
    ‚Üì
YES ‚Üí Sequential (A ‚Üí B)
    ‚Üì
NO ‚Üí Check for shared resources
    ‚Üì
    Same file/state?
        ‚Üì
    YES ‚Üí Sequential (safer)
        ‚Üì
    NO ‚Üí Parallel (A + B)
```

---

## Breaking Down Large Action Items

### When to Break Down

**Signs an action item is too large**:
- Estimated > 2 hours
- Involves multiple files
- Multiple sub-steps needed
- Unclear how to complete
- High risk of failure

**Example of Too-Large Item**:
```markdown
- [ ] Implement payment system
```

This is too vague and large. Break it down!

### Breakdown Strategies

#### Strategy 1: By Component

Break into logical components/modules.

**Before**:
```markdown
- [ ] Implement payment system
```

**After**:
```markdown
- [ ] Create PaymentProcessor interface
- [ ] Implement StripeProcessor class
- [ ] Implement PayPalProcessor class
- [ ] Create PaymentService to coordinate processors
- [ ] Add payment validation logic
- [ ] Add error handling and retry
- [ ] Add tests for all processors
```

#### Strategy 2: By Layer

Break into architectural layers.

**Before**:
```markdown
- [ ] Add user authentication
```

**After**:
```markdown
- [ ] Database: Create users table with auth fields
- [ ] Data Layer: Create UserRepository with auth methods
- [ ] Service Layer: Create AuthService with login/logout
- [ ] API Layer: Create /login and /logout endpoints
- [ ] Middleware: Add authentication middleware
- [ ] Tests: Add auth integration tests
```

#### Strategy 3: By Phase

Break into implementation phases (skeleton ‚Üí veins ‚Üí flesh).

**Before**:
```markdown
- [ ] Build search feature
```

**After**:
```markdown
Skeleton (basic functionality):
- [ ] Create search API endpoint that returns hardcoded results
- [ ] Add search input in UI
- [ ] Wire UI to API

Veins (core functionality):
- [ ] Implement database search query
- [ ] Add pagination to results
- [ ] Add sorting options

Flesh (polish):
- [ ] Add search filters (date, type, status)
- [ ] Add search highlighting
- [ ] Add search suggestions
- [ ] Optimize query performance
```

#### Strategy 4: By File

Break into file-level changes.

**Before**:
```markdown
- [ ] Refactor error handling
```

**After**:
```markdown
- [ ] Update ErrorHandler.ts with new error types
- [ ] Update PaymentService.ts error handling
- [ ] Update OrderService.ts error handling
- [ ] Update BillingService.ts error handling
- [ ] Update error handling tests
- [ ] Update error documentation
```

### Breakdown Examples

#### Example 1: API Integration

**Too Large**:
```markdown
- [ ] Integrate with Stripe API
```

**Properly Broken Down**:
```markdown
- [ ] Create StripeClient class with API key configuration
- [ ] Implement createPayment() method
- [ ] Implement getPayment() method
- [ ] Implement refundPayment() method
- [ ] Add error mapping (Stripe errors ‚Üí our errors)
- [ ] Add retry logic for transient failures
- [ ] Add webhook signature validation
- [ ] Add unit tests with mocked Stripe API
- [ ] Add integration tests with Stripe test mode
```

#### Example 2: Database Schema

**Too Large**:
```markdown
- [ ] Design and implement database schema
```

**Properly Broken Down**:
```markdown
- [ ] Create users table with fields and constraints
- [ ] Create payments table with foreign keys
- [ ] Create orders table with relationships
- [ ] Add indexes on frequently queried fields
- [ ] Create migration script for schema
- [ ] Add seed data for development
- [ ] Test schema with sample queries
- [ ] Document schema in ER diagram
```

#### Example 3: Refactoring

**Too Large**:
```markdown
- [ ] Refactor legacy payment code
```

**Properly Broken Down**:
```markdown
- [ ] Extract payment processing into separate class
- [ ] Replace hard-coded values with configuration
- [ ] Convert callbacks to async/await
- [ ] Add proper error handling
- [ ] Replace any types with proper interfaces
- [ ] Update tests to match new structure
- [ ] Verify no regressions with integration tests
- [ ] Update documentation
```

---

## Common Implementation Scenarios

### Scenario 1: Creating New Feature

**Context**: Building a new feature from scratch

**Recommended Pattern**: Sequential with verification

```markdown
#### Action Items

- [x] Design and document API contract
  ‚Üí Verification: API spec reviewed and approved

- [x] Create database schema and migration
  ‚Üí Verification: Migration runs cleanly, schema correct

- [x] Implement data access layer
  ‚Üí Verification: Unit tests for DAL passing

- [x] Implement service layer
  ‚Üí Verification: Service tests passing

- [x] Create API endpoints
  ‚Üí Verification: Integration tests passing

- [x] Add error handling
  ‚Üí Verification: Error cases tested and working

- [x] Add logging and monitoring
  ‚Üí Verification: Logs visible, metrics tracked

- [x] Write documentation
  ‚Üí Verification: Docs accurate and complete
```

### Scenario 2: Bug Fix

**Context**: Fixing a specific bug

**Recommended Pattern**: Diagnose ‚Üí Fix ‚Üí Verify

```markdown
#### Action Items

- [x] Reproduce bug with test case
  ‚Üí Verification: Test fails, reproducing bug

- [x] Debug and identify root cause
  ‚Üí Verification: Root cause documented

- [x] Implement fix
  ‚Üí Verification: Test now passes

- [x] Add regression test
  ‚Üí Verification: New test prevents bug from returning

- [x] Verify fix doesn't break anything else
  ‚Üí Verification: All tests still passing
```

### Scenario 3: Refactoring

**Context**: Improving existing code structure

**Recommended Pattern**: Incremental with safety checks

```markdown
#### Action Items

- [x] Add comprehensive tests for current behavior
  ‚Üí Verification: Tests passing, covering all cases

- [x] Extract method/class/module
  ‚Üí Verification: Tests still passing

- [x] Update call sites to use new code
  ‚Üí Verification: Tests still passing

- [x] Remove old code
  ‚Üí Verification: Tests still passing

- [x] Clean up and optimize
  ‚Üí Verification: Tests still passing, code cleaner
```

### Scenario 4: Integration

**Context**: Integrating with external system

**Recommended Pattern**: Mock ‚Üí Real ‚Üí Error handling

```markdown
#### Action Items

- [x] Create client interface and types
  ‚Üí Verification: Interface matches external API

- [x] Implement client with mock responses
  ‚Üí Verification: Mock client works, tests passing

- [x] Replace mock with real API calls
  ‚Üí Verification: Integration test with real API succeeds

- [x] Add error handling and retry logic
  ‚Üí Verification: Error cases handled gracefully

- [x] Add rate limiting and timeouts
  ‚Üí Verification: Rate limits respected, timeouts working
```

### Scenario 5: Performance Optimization

**Context**: Improving performance of existing feature

**Recommended Pattern**: Measure ‚Üí Optimize ‚Üí Verify

```markdown
#### Action Items

- [x] Add performance benchmarks
  ‚Üí Verification: Baseline performance measured

- [x] Profile and identify bottlenecks
  ‚Üí Verification: Bottlenecks documented

- [x] Implement optimization (e.g., caching)
  ‚Üí Verification: Benchmarks show improvement

- [x] Verify functionality unchanged
  ‚Üí Verification: All tests still passing

- [x] Document performance characteristics
  ‚Üí Verification: Docs updated with new benchmarks
```

---

## Best Practices Summary

**Pre-Implementation Tasks**:
- ‚úÖ Keep scope < 30 minutes
- ‚úÖ Complete ALL before starting main work
- ‚úÖ Document why each is blocking
- ‚úÖ Mark completed with date and details

**Action Items**:
- ‚úÖ Make items specific and measurable
- ‚úÖ Check off immediately after completion
- ‚úÖ Execute in logical order (dependencies first)
- ‚úÖ Verify incrementally, not just at end
- ‚úÖ Document blockers and deviations

**Breaking Down Large Items**:
- ‚úÖ If > 2 hours, break it down
- ‚úÖ Use component, layer, phase, or file breakdown
- ‚úÖ Ensure sub-items are still specific
- ‚úÖ Maintain logical grouping

**Sequential vs Parallel**:
- ‚úÖ Sequential when items depend on each other
- ‚úÖ Parallel when items are independent
- ‚úÖ Hybrid when mix of both
- ‚úÖ When in doubt, go sequential (safer)

**Common Scenarios**:
- ‚úÖ New feature: Sequential with verification
- ‚úÖ Bug fix: Diagnose ‚Üí Fix ‚Üí Verify
- ‚úÖ Refactoring: Incremental with safety checks
- ‚úÖ Integration: Mock ‚Üí Real ‚Üí Error handling
- ‚úÖ Optimization: Measure ‚Üí Optimize ‚Üí Verify
SKILL_FLOW_IMPLEMENTER_PATTERNS_EOF
}

get_skill_flow_implementer_verification() {
  cat <<'SKILL_FLOW_IMPLEMENTER_VERIFICATION_EOF'
# Implementation Verification Guide

This document provides detailed verification patterns, completion criteria, and decision-making guidance for implementation work in Flow framework. Reference this guide when you need detailed examples and templates for verifying your work.

> **Note**: This is a Level 3 resource for the flow-implementer Skill. See [SKILL.md](SKILL.md) for core implementation workflow.

## Table of Contents

1. [Testing Patterns](#testing-patterns)
2. [What "Done" Looks Like](#what-done-looks-like)
3. [When to Document Bugs and Issues](#when-to-document-bugs-and-issues)
4. [Deciding: ‚ùå BLOCKED vs Continue](#deciding--blocked-vs-continue)

---

## Testing Patterns

### Unit Testing Pattern

**When**: Testing individual functions/methods in isolation

**Example Structure**:
```typescript
describe('RetryPolicy', () => {
  describe('calculateDelay', () => {
    it('should return base delay for first retry', () => {
      const policy = new RetryPolicy({ baseDelay: 1000, maxRetries: 3 });
      expect(policy.calculateDelay(1)).toBe(1000);
    });

    it('should apply exponential backoff', () => {
      const policy = new RetryPolicy({ baseDelay: 1000, maxRetries: 3 });
      expect(policy.calculateDelay(2)).toBe(2000);
      expect(policy.calculateDelay(3)).toBe(4000);
    });

    it('should cap at max delay', () => {
      const policy = new RetryPolicy({ baseDelay: 1000, maxDelay: 5000 });
      expect(policy.calculateDelay(10)).toBe(5000);
    });
  });
});
```

**What to Test**:
- Happy path (expected inputs ‚Üí expected outputs)
- Edge cases (empty, null, undefined, boundary values)
- Error cases (invalid inputs ‚Üí proper errors)
- State changes (method calls affect object state correctly)

### Integration Testing Pattern

**When**: Testing multiple components working together

**Example Structure**:
```typescript
describe('Payment Integration', () => {
  it('should process payment with retry on transient failure', async () => {
    // Setup: Create real instances (or test doubles)
    const stripe = new StripeClient(testApiKey);
    const processor = new PaymentProcessor(stripe);

    // Mock Stripe to fail once, then succeed
    jest.spyOn(stripe, 'createCharge')
      .mockRejectedValueOnce(new TransientError('rate_limit'))
      .mockResolvedValueOnce({ id: 'ch_123', status: 'succeeded' });

    // Execute: Run the full flow
    const result = await processor.process({
      amount: 1000,
      currency: 'usd',
      retryPolicy: { maxRetries: 3 }
    });

    // Verify: Check end-to-end behavior
    expect(result.status).toBe('succeeded');
    expect(stripe.createCharge).toHaveBeenCalledTimes(2); // Failed once, succeeded second time
  });
});
```

**What to Test**:
- Component interactions (A calls B correctly)
- Data flow (data transforms correctly through layers)
- Error propagation (errors bubble up properly)
- Side effects (database writes, API calls, file I/O)

### Manual Testing Checklist

**When**: No automated tests exist or testing UI/UX

**Checklist Template**:
```markdown
**Manual Testing - [Feature Name]**

**Setup**:
- [ ] Environment: [development/staging]
- [ ] Test data: [describe test data used]
- [ ] Prerequisites: [any setup needed]

**Test Cases**:
1. Happy Path:
   - [ ] Action: [what you did]
   - [ ] Expected: [what should happen]
   - [ ] Actual: [what actually happened]
   - [ ] Result: ‚úÖ PASS / ‚ùå FAIL

2. Edge Case:
   - [ ] Action: [what you did]
   - [ ] Expected: [what should happen]
   - [ ] Actual: [what actually happened]
   - [ ] Result: ‚úÖ PASS / ‚ùå FAIL

**Issues Found**:
- [Bug 1 description + severity]
- [Bug 2 description + severity]

**Verified**: [Date] by [Name]
```

### Test-Driven Development (TDD) Pattern

**When**: Complex logic where tests help design

**Flow**:
```
1. RED: Write failing test
   ‚Üì
2. GREEN: Write minimal code to pass
   ‚Üì
3. REFACTOR: Improve code while keeping tests green
   ‚Üì
Repeat
```

**Example Iteration**:
```typescript
// Step 1: RED - Write failing test
test('should calculate exponential backoff', () => {
  const delay = calculateBackoff(2, 1000);
  expect(delay).toBe(2000);
});
// Run test ‚Üí FAILS (function doesn't exist)

// Step 2: GREEN - Minimal implementation
function calculateBackoff(attempt: number, baseDelay: number): number {
  return attempt * baseDelay;
}
// Run test ‚Üí PASSES

// Step 3: REFACTOR - Improve implementation
function calculateBackoff(attempt: number, baseDelay: number): number {
  return Math.pow(2, attempt - 1) * baseDelay;
}
// Run test ‚Üí STILL PASSES (for attempt=2: 2^1 * 1000 = 2000)

// Step 4: Add more tests to drive better design
test('should handle attempt=1', () => {
  expect(calculateBackoff(1, 1000)).toBe(1000); // 2^0 * 1000
});
```

---

## What "Done" Looks Like

### Iteration Completion Criteria

An iteration is **truly done** when ALL of the following are true:

#### 1. All Action Items Completed

```markdown
‚úÖ Correct:
- [x] Create RetryPolicy class
- [x] Implement backoff algorithm
- [x] Add configuration
- [x] Integrate with client
- [x] Add tests

‚ùå Incorrect:
- [x] Create RetryPolicy class
- [x] Implement backoff algorithm
- [ ] Add configuration          ‚Üê NOT DONE
- [x] Integrate with client
- [x] Add tests
```

#### 2. Code Works Correctly

**Verification Methods** (choose based on project):
- Unit tests passing (all green)
- Integration tests passing
- Manual testing completed with checklist
- Code review approved
- No compiler/linter errors

**Example**:
```bash
‚úÖ All tests passing:
  PASS  src/payment/RetryPolicy.test.ts
  PASS  src/payment/StripeClient.test.ts
  PASS  integration/payment.integration.test.ts

  Test Suites: 3 passed, 3 total
  Tests:       24 passed, 24 total
```

#### 3. No Unresolved Blockers

**Resolved Blocker Example**:
```markdown
**Implementation Notes**:
- Created RetryPolicy class
- **Blocker Encountered**: Stripe SDK v12 doesn't support custom retry
  - **Resolution**: Implemented wrapper pattern around SDK calls
  - **Impact**: Added StripeClientWrapper.ts (86 lines)
- Integrated wrapper with payment processor
```

**Unresolved Blocker Example** (iteration NOT done):
```markdown
**Implementation Notes**:
- Created RetryPolicy class
- **Blocker Encountered**: Stripe SDK v12 doesn't support custom retry
  - **Status**: ‚ùå WAITING FOR USER DECISION
  - **Options Presented**: Downgrade to v11, wait for v13, or implement wrapper
  - **Action**: Cannot proceed until user chooses approach
```

#### 4. Implementation Notes Updated

**Complete Notes Example**:
```markdown
**Implementation Notes**:

Created comprehensive retry logic for payment processing:

**What Was Built**:
- RetryPolicy class with configurable backoff (src/payment/RetryPolicy.ts, 124 lines)
- Exponential backoff algorithm (base: 1s, max: 32s, jitter: 20%)
- Error classification (transient vs permanent errors)
- Integration with StripeClient via wrapper pattern

**Design Decisions**:
- Chose exponential backoff over linear (better for API rate limiting)
- Added jitter to prevent thundering herd problem
- Made policy injectable for easy testing

**Challenges & Solutions**:
- Challenge: Stripe SDK v12 doesn't support custom retry
  - Solution: Implemented StripeClientWrapper to intercept API calls
- Challenge: Difficult to test retry timing
  - Solution: Made clock injectable via dependency injection

**Deviations from Plan**:
- Originally planned to use Stripe's built-in retry, but discovered it's not customizable
- Added StripeClientWrapper.ts (not in original action items, but necessary)

**Bugs Fixed**:
- Fixed off-by-one error in backoff calculation (was 2^attempt, now 2^(attempt-1))
```

#### 5. Files Modified Documented

**Complete Documentation Example**:
```markdown
**Files Modified**:
- src/payment/RetryPolicy.ts (created, 124 lines)
- src/payment/StripeClientWrapper.ts (created, 86 lines)
- src/payment/StripeClient.ts (modified, +24 lines, -8 lines)
- src/types/payment.ts (modified, +12 lines for retry types)
- tests/payment/RetryPolicy.test.ts (created, 98 lines)
- tests/payment/StripeClientWrapper.test.ts (created, 64 lines)
- integration/payment.integration.test.ts (modified, +42 lines)
```

#### 6. Ready for Next Work

**Verification Questions**:
- Can the next iteration start immediately? YES / NO
- Are there any dependencies that need resolving? YES / NO
- Does anything need user decision before continuing? YES / NO

**Example - Ready**:
```markdown
‚úÖ READY FOR NEXT ITERATION

Current Status:
- Iteration 2 (Retry Logic) complete and verified
- All tests passing
- No blockers for Iteration 3 (Error Logging)
- Can proceed immediately with /flow-implement-complete
```

**Example - NOT Ready**:
```markdown
‚ùå NOT READY - NEEDS USER DECISION

Current Status:
- Iteration 2 (Retry Logic) functionally complete
- All tests passing
- **Blocker for Iteration 3**: User needs to decide on logging library
  - Options: Winston, Pino, or custom logger
  - Cannot start Iteration 3 until decision made
- Mark Iteration 2 complete, but address blocker before starting Iteration 3
```

---

## When to Document Bugs and Issues

### Bug Discovery During Implementation

**When you discover bugs in EXISTING code** (not your changes):

#### Document in Implementation Notes

```markdown
**Implementation Notes**:

Created payment retry logic.

**Bugs Discovered in Existing Code**:

##### Bug 1: Race Condition in PaymentService

**Location**: `src/services/PaymentService.ts:145-152`

**Problem**:
```typescript
// Current buggy code
async processPayment(amount: number) {
  const status = await this.checkStatus();
  // Race condition: status can change between check and update
  await this.updatePayment(status);
}
```

**Impact**: Could cause duplicate charges in concurrent requests

**Action Taken**: Documented here, created separate task for fix (not in scope of current iteration)

**Recommendation**: High priority fix for next sprint
```

#### When to Fix Immediately vs Defer

**Fix Immediately** (document in Implementation Notes):
- Blocking bug in file you're currently modifying
- Syntax error preventing compilation
- Trivial fix (< 5 minutes)
- Part of your current action items

**Defer** (document and create task):
- Bug in unrelated code
- Requires significant refactoring
- Needs design discussion
- Out of scope for current iteration

### Issue Severity Levels

**Critical** (Fix immediately or BLOCK iteration):
- Causes data loss
- Security vulnerability
- System crash/unavailability
- Blocking current work

**High** (Document and create follow-up task):
- Incorrect functionality
- Performance degradation
- Race condition/concurrency issue
- Affects multiple users

**Medium** (Document for backlog):
- Edge case handling missing
- Poor error messages
- Minor performance issue
- Affects few users

**Low** (Document for future):
- Code quality issue
- Missing tests
- Documentation gap
- Nice-to-have improvement

---

## Deciding: ‚ùå BLOCKED vs Continue

### When to Mark ‚ùå BLOCKED

Mark iteration **‚ùå BLOCKED** when you **CANNOT PROCEED** without external help:

**Valid Blocking Scenarios**:

1. **External Dependency Unavailable**:
   ```markdown
   ‚ùå BLOCKED: Stripe API test environment down
   - Cannot run integration tests
   - Need API to be back up before proceeding
   - Estimated wait: 2-4 hours (according to status page)
   ```

2. **Need User Decision**:
   ```markdown
   ‚ùå BLOCKED: Need architecture decision
   - Two viable approaches for retry logic:
     A) Client-side retry (simpler, less reliable)
     B) Server-side retry queue (complex, more reliable)
   - Cannot proceed without user choosing approach
   - Next action: Present options to user, await decision
   ```

3. **Technical Limitation Discovered**:
   ```markdown
   ‚ùå BLOCKED: Library doesn't support required feature
   - Stripe SDK v12 doesn't expose retry hooks
   - Options: downgrade to v11, wait for v13, or implement wrapper
   - Estimated resolution time: > 2 hours (needs investigation)
   ```

4. **Missing Information**:
   ```markdown
   ‚ùå BLOCKED: Missing API credentials
   - Need production Stripe API key to test
   - Cannot verify integration without real credentials
   - User must provide credentials
   ```

### When to CONTINUE (Not Block)

**DO NOT mark blocked** if you can work around or continue:

**Continue Scenarios**:

1. **Minor Issue with Workaround**:
   ```markdown
   ‚úÖ CONTINUING: Test flakiness found
   - Integration test occasionally fails (timing issue)
   - **Workaround**: Added retry logic to test itself
   - Can proceed with implementation
   - **Note**: Will fix flakiness in separate cleanup task
   ```

2. **Discover Out-of-Scope Work**:
   ```markdown
   ‚úÖ CONTINUING: Found refactoring opportunity
   - Noticed ErrorHandler could be refactored for better reuse
   - **Decision**: Out of scope for this iteration
   - **Action**: Documented for future refactoring task
   - Proceeding with current implementation using existing ErrorHandler
   ```

3. **Can Complete Action Items Without Resolution**:
   ```markdown
   ‚úÖ CONTINUING: Documentation incomplete
   - Found outdated API documentation
   - **Action**: Using source code as reference instead
   - Can complete implementation despite docs being stale
   - **Note**: Will update docs in separate task
   ```

4. **Temporary Solution Acceptable**:
   ```markdown
   ‚úÖ CONTINUING: Performance not optimal
   - Current retry logic takes 30s worst case (goal was 20s)
   - **Decision**: Acceptable for V1, will optimize in V2
   - Can mark iteration complete with known limitation
   - **Note**: Documented in Implementation Notes for V2 improvement
   ```

### Decision Flowchart

```
Encounter Issue
    ‚Üì
Can I complete action items without resolving this?
    ‚Üì
YES ‚Üí CONTINUE
  ‚Üì
  Document issue in Implementation Notes
  Create follow-up task if needed
  Proceed with implementation
    ‚Üì
NO ‚Üí Assess Impact
  ‚Üì
  Is this a minor issue (< 30 min to resolve)?
    ‚Üì
    YES ‚Üí FIX NOW
      ‚Üì
      Resolve issue
      Document in Implementation Notes
      Continue implementation
    ‚Üì
    NO ‚Üí BLOCKED
      ‚Üì
      Mark iteration ‚ùå BLOCKED
      Document blocker clearly
      Present options to user
      Wait for decision/resolution
```

### Example: Blocked vs Continue

**Scenario**: Discovered Stripe API rate limiting during testing

**Option 1: Mark BLOCKED** (if cannot proceed):
```markdown
‚ùå BLOCKED: Hit Stripe API rate limit

**Issue**: Integration tests hitting Stripe API rate limit (100 requests/hour in test mode)

**Impact**: Cannot run integration tests to verify implementation

**Cannot Proceed Because**:
- Tests are mandatory for completion
- No way to verify retry logic works without testing against real API
- Mock tests insufficient (need real API behavior)

**Options**:
A) Request higher rate limit from Stripe support (ETA: 1-2 days)
B) Space out test runs (run tests every hour, very slow)
C) Use more sophisticated mocking to reduce API calls

**Waiting for**: User decision on approach
```

**Option 2: CONTINUE** (if can work around):
```markdown
‚úÖ CONTINUING: Stripe API rate limit hit

**Issue**: Integration tests hitting Stripe API rate limit (100 requests/hour in test mode)

**Workaround**: Implemented smart test mocking
- Created realistic mock responses based on Stripe API documentation
- Validated mock responses against real API (used 10 of 100 requests)
- Remaining integration tests use mocks
- Will run full integration test suite during deployment (production has higher limits)

**Impact**: Can proceed with confidence
- Core logic tested with mocks
- Sample verification with real API successful
- Documented limitation for deployment testing

**Next Steps**: Continue with implementation
```
SKILL_FLOW_IMPLEMENTER_VERIFICATION_EOF
}

get_skill_flow_architect() {
  cat <<'SKILL_FLOW_ARCHITECT_EOF'
---
name: flow-architect
description: Guide architectural decisions and PLAN.md updates in Flow framework. Use when user discusses "architecture", "how should we architect", "design patterns", "how should we structure", "how do we structure", "technology choice", "should we use", "DO/DON'T rules", "update architecture", or wants to update Architecture section in PLAN.md. Helps document architectural decisions, update DO/DON'T guidelines, define scope boundaries, and record technology choices during brainstorming.
---

# Flow Architect

Help users make and document architectural decisions in Flow framework projects. This Skill activates during brainstorming when design patterns, technology choices, or system structure need to be captured in PLAN.md.

## When to Use This Skill

Activate when the user discusses architecture:
- "How should we architect this?"
- "What's the best structure for..."
- "Should we use [pattern/library/approach]?"
- "Update the architecture section"
- "Add a DO/DON'T rule"
- "What technology should we choose?"
- "Document this design decision"
- "Define the scope boundaries"

## Architecture Philosophy

**Flow's Core Principle**: Document architectural decisions during brainstorming, not during implementation. PLAN.md preserves design rationale for future reference.

**Key Sections in PLAN.md**:
- **Architecture**: High-level system structure, component boundaries, data flow
- **DO/DON'T Guidelines**: Discovered patterns and anti-patterns with rationale
- **Scope**: What's in V1 vs future versions, boundaries and constraints

**When to Update**:
- Major architectural decision made
- Pattern discovered that should be followed consistently
- Technology choice finalized
- Scope boundary clarified
- Anti-pattern identified

## PLAN.md Architecture Section

### What Goes in Architecture

**High-level Structure**:
- System components and their relationships
- Module boundaries and responsibilities
- Data flow between components
- Integration points (external APIs, services, databases)
- Key design patterns being used

**Example Architecture Section**:
```markdown
## Architecture

### System Structure

**Core Components**:
- **PaymentProcessor**: Orchestrates payment flow, handles retries
- **StripeClient**: Wrapper around Stripe SDK, manages API calls
- **ErrorMapper**: Translates Stripe errors to domain errors
- **RetryPolicy**: Configurable backoff and retry logic

**Data Flow**:
```
User ‚Üí PaymentProcessor ‚Üí StripeClient ‚Üí Stripe API
         ‚Üì (on error)
    ErrorMapper ‚Üí RetryPolicy ‚Üí StripeClient (retry)
```

**Integration Points**:
- Stripe API v2024-10 (payment processing)
- Webhook endpoint (payment status updates)
- Database (transaction log)
```

### What Doesn't Go in Architecture

**Avoid These**:
- ‚ùå Implementation details (specific line numbers, code snippets)
- ‚ùå Completed work (belongs in task notes)
- ‚ùå Bugs and fixes (belongs in iteration notes)
- ‚ùå Speculation about future features (keep focused on V1)

## DO/DON'T Guidelines

### When to Add Guidelines

**Add a guideline when you discover**:
- A pattern that should be followed consistently
- An anti-pattern that should be avoided
- A constraint from the technology/platform
- A design decision with specific rationale

**DO NOT add guidelines for**:
- Obvious best practices (don't state "write tests")
- One-off decisions (not patterns)
- Implementation details (belongs in code comments)
- Preferences without rationale

### Guideline Structure

**Format**:
```markdown
### DO: [Action]

**Rationale**: [Why this pattern works]

**Example**:
```[language]
// Good approach
```

**Anti-pattern**:
```[language]
// What to avoid
```
```

**Real Example**:
```markdown
### DO: Use RetryPolicy for all Stripe API calls

**Rationale**: Stripe API has transient failures (rate limits, network issues). Retry logic with exponential backoff prevents user-facing errors.

**Example**:
```typescript
const result = await retryPolicy.execute(() =>
  stripe.createCharge({ amount, currency })
);
```

**Anti-pattern**:
```typescript
// Don't call Stripe directly without retry
const result = await stripe.createCharge({ amount, currency });
```
```

### DON'T: [Anti-pattern]

**Rationale**: [Why this causes problems]

**Impact**: [Consequences of ignoring this]

**Example**:
```markdown
### DON'T: Retry permanently failed payments

**Rationale**: Permanent failures (invalid card, insufficient funds) will never succeed. Retrying wastes resources and delays error feedback to user.

**Impact**:
- User waits longer for error message
- Unnecessary load on Stripe API
- Potential rate limit violations

**How to Identify Permanent Failures**:
- Stripe error codes: `card_declined`, `insufficient_funds`, `invalid_card`
- Use ErrorMapper to classify errors
```

## Technology Choices

### When to Document Technology Decisions

**Document when you choose**:
- External library or framework
- Design pattern (e.g., Repository pattern, Strategy pattern)
- Architecture style (e.g., layered, hexagonal, microservices)
- Third-party service (e.g., Stripe, Twilio, SendGrid)

### Technology Choice Format

```markdown
## Technology Choices

### [Component/Area]: [Technology]

**Decision**: Using [technology/pattern] for [purpose]

**Rationale**:
- [Reason 1: why this choice]
- [Reason 2: advantage over alternatives]
- [Reason 3: fits project constraints]

**Alternatives Considered**:
- [Alternative 1]: [Why not chosen]
- [Alternative 2]: [Why not chosen]

**Trade-offs**:
- ‚úÖ Pros: [advantages]
- ‚ùå Cons: [disadvantages]
- ‚öñÔ∏è Acceptable for V1: [why trade-offs are OK]
```

**Example**:
```markdown
### Retry Logic: Custom Implementation

**Decision**: Building custom retry policy instead of using Stripe SDK built-in retry

**Rationale**:
- Stripe SDK v12 doesn't expose retry configuration
- Need fine-grained control over backoff timing
- Want to distinguish transient vs permanent errors

**Alternatives Considered**:
- Stripe SDK built-in retry: Not customizable enough
- Generic retry library (async-retry): Doesn't understand Stripe error semantics

**Trade-offs**:
- ‚úÖ Pros: Full control, testable, Stripe-aware
- ‚ùå Cons: More code to maintain
- ‚öñÔ∏è Acceptable for V1: Retry logic is isolated in RetryPolicy class
```

## Scope Boundaries

### Defining Scope

**V1 Scope** (what's included):
- Core functionality needed for first release
- Must-have features
- Blocking dependencies

**V2/V3 Scope** (what's deferred):
- Nice-to-have features
- Optimizations
- Edge cases
- Advanced features

### Scope Section Format

```markdown
## Scope

### V1 - MVP (Current)

**In Scope**:
- [Core feature 1]
- [Core feature 2]
- [Core feature 3]

**Out of Scope** (defer to V2):
- [Enhancement 1]: [Why deferred]
- [Enhancement 2]: [Why deferred]

**Constraints**:
- [Constraint 1]: [Impact on design]
- [Constraint 2]: [Impact on design]
```

**Example**:
```markdown
## Scope

### V1 - MVP (Current)

**In Scope**:
- Payment processing (charge credit cards)
- Basic retry logic (transient failures only)
- Error mapping (Stripe errors ‚Üí domain errors)
- Transaction logging

**Out of Scope** (defer to V2):
- Refunds: Not needed for initial launch
- Subscription billing: Future business model
- Multi-currency: US only for V1
- Webhook verification: Will add when scaling

**Constraints**:
- Stripe API v2024-10 (latest stable)
- TypeScript 5.x (project standard)
- Must handle 100 req/sec (growth expectation)
```

## Updating PLAN.md During Brainstorming

### Workflow

1. **Read current PLAN.md**:
   - Check existing Architecture section
   - Review current DO/DON'T guidelines
   - Understand scope boundaries

2. **Discuss with user**:
   - Present architectural options clearly
   - Explain trade-offs for each approach
   - Reference existing patterns in codebase

3. **Update PLAN.md** (after user decides):
   - Add/update Architecture section
   - Add new DO/DON'T guidelines
   - Document technology choices
   - Clarify scope boundaries

4. **Reference in task file**:
   - Link to PLAN.md sections in task notes
   - Don't duplicate content in task files

### Subject Resolution Type B

Architectural decisions are often **Type B subjects** in brainstorming:
- **Type B**: Documentation-only updates (no code)
- Resolved by updating PLAN.md
- No action items needed
- Marked resolved when PLAN.md updated

**Example Type B Subject**:
```markdown
### Subject 2: Define Retry Strategy

**Status**: ‚úÖ RESOLVED (Type B - Documentation)

**Question**: What retry strategy should we use for Stripe API calls?

**Decision**: Exponential backoff with jitter (1s, 2s, 4s, 8s, 16s max)

**Rationale**:
- Prevents thundering herd problem (jitter)
- Standard for API rate limiting
- Stripe recommends exponential backoff

**PLAN.md Updated**:
- Added "Retry Logic" to Architecture section
- Added "DO: Use RetryPolicy for all Stripe calls" guideline
- Documented RetryPolicy configuration in Technology Choices
```

## Common Architecture Patterns

### Pattern: Layered Architecture

```
Presentation Layer (API endpoints, controllers)
    ‚Üì
Business Layer (services, domain logic)
    ‚Üì
Data Layer (repositories, database access)
    ‚Üì
External Layer (third-party APIs)
```

**When to use**: Clear separation of concerns, traditional web apps

### Pattern: Wrapper/Adapter

**When to use**: Integrating with external service, need to control interface

**Example**:
```markdown
### StripeClient Wrapper

**Purpose**: Wrap Stripe SDK to add retry logic and error mapping

**Benefits**:
- Isolates Stripe-specific code
- Single place for retry configuration
- Easier to test (can mock wrapper)
- Can swap Stripe for different provider

**Structure**:
```typescript
class StripeClient {
  constructor(
    private stripe: Stripe,
    private retryPolicy: RetryPolicy,
    private errorMapper: ErrorMapper
  ) {}

  async createCharge(params: ChargeParams): Promise<Charge> {
    return this.retryPolicy.execute(async () => {
      try {
        return await this.stripe.charges.create(params);
      } catch (error) {
        throw this.errorMapper.map(error);
      }
    });
  }
}
```
```

### Pattern: Strategy Pattern

**When to use**: Multiple algorithms for same operation, chosen at runtime

**Example**: RetryPolicy with different backoff strategies (linear, exponential, custom)

## Interaction with Other Flow Skills

**Planning Stage** (flow-planner Skill):
- `/flow-brainstorm-start` - Begin architectural discussion
- `/flow-brainstorm-subject` - Add design decision to discuss

**Architecture Stage** (This Skill):
- Discuss architectural options ‚Üê YOU ARE HERE
- Update PLAN.md with decisions ‚Üê YOU ARE HERE
- Resolve Type B subjects (documentation)

**Implementation Stage** (flow-implementer Skill):
- `/flow-implement-start` - Build based on architecture
- Reference PLAN.md architecture during coding

## Detailed Guidance

For comprehensive patterns, examples, and templates, see **[PLAN_UPDATES.md](PLAN_UPDATES.md)**:

- **When to Update PLAN.md**: Type B subjects, workflows, timing guidance
- **Architecture vs Scope**: Detailed distinction with decision tree and examples
- **DO/DON'T Examples**: 4 comprehensive patterns with full code (API integration, error handling, configuration, testing)
- **Technology Choice Templates**: Complete documentation format with 2 real examples
- **Keeping PLAN.md Focused**: What to include/avoid, red flags, how to slim down

## References

- **PLAN.md Structure**: DEVELOPMENT_FRAMEWORK.md lines 2363-2560
- **Brainstorming Pattern**: DEVELOPMENT_FRAMEWORK.md lines 1167-1797
- **Subject Resolution Type B**: DEVELOPMENT_FRAMEWORK.md lines 1247-1268
- **DO/DON'T Guidelines**: Include rationale and examples, avoid speculation

## Key Reminders

**Before suggesting architecture changes**:
- [ ] Read current PLAN.md Architecture section
- [ ] Understand existing patterns in codebase
- [ ] Present multiple options with trade-offs
- [ ] Let user make final decision

**After user decides**:
- [ ] Update PLAN.md with decision
- [ ] Add DO/DON'T if pattern emerges
- [ ] Document technology choice with rationale
- [ ] Resolve brainstorming subject (Type B)

**Keep PLAN.md focused**:
- High-level decisions, not implementation details
- Rationale, not speculation
- Patterns, not one-off choices
- V1 scope, defer V2/V3 discussions
SKILL_FLOW_ARCHITECT_EOF
}

get_skill_flow_architect_plan_updates() {
  cat <<'SKILL_FLOW_ARCHITECT_PLAN_UPDATES_EOF'
# PLAN.md Update Patterns

This document provides best practices and patterns for updating PLAN.md during brainstorming sessions in Flow framework projects. Use this as a reference when documenting architectural decisions, DO/DON'T guidelines, technology choices, and scope boundaries.

> **Note**: This is a Level 3 resource for the flow-architect Skill. See [SKILL.md](SKILL.md) for core architectural guidance.

## Table of Contents

1. [When to Update PLAN.md](#when-to-update-planmd)
2. [Architecture vs Scope](#architecture-vs-scope)
3. [DO/DON'T Guideline Examples](#dodont-guideline-examples)
4. [Technology Choice Documentation](#technology-choice-documentation)
5. [Keeping PLAN.md Focused](#keeping-planmd-focused)

## When to Update PLAN.md

### During Brainstorming (Type B Subjects)

**Type B subjects** are resolved by updating PLAN.md documentation:
- Architectural decisions finalized
- Design patterns chosen
- Technology/library selection complete
- Scope boundaries clarified
- DO/DON'T pattern discovered

**Workflow**:
1. Discuss options during brainstorming
2. User makes final decision
3. Update PLAN.md with decision + rationale
4. Mark brainstorming subject as ‚úÖ RESOLVED (Type B)

**Example Subject**:
```markdown
### Subject 3: Choose Error Mapping Strategy

**Status**: ‚úÖ RESOLVED (Type B - Documentation)

**Question**: How should we map Stripe errors to domain errors?

**Decision**: Use dedicated ErrorMapper class with error code lookup table

**Rationale**:
- Centralizes error mapping logic
- Easy to extend with new error codes
- Testable in isolation
- Keeps StripeClient focused

**PLAN.md Updated**:
- Added ErrorMapper to Architecture section (Component list)
- Added "DO: Use ErrorMapper for all Stripe errors" guideline
```

### Not During Implementation

**DON'T update PLAN.md during implementation** for:
- Bug fixes (document in iteration notes)
- Implementation details (document in code comments)
- Completed work (document in task files)
- Discovered issues (document in implementation notes)

**Exception**: If implementation reveals a pattern that should be followed consistently, note it for future brainstorming session to add to DO/DON'T guidelines.

## Architecture vs Scope

### Architecture Section: HOW the system works

**Use Architecture section for**:
- System structure (components, modules, layers)
- Component responsibilities and boundaries
- Data flow between components
- Integration points (external services, APIs)
- Design patterns being used
- Key technical constraints

**Example - Architecture Section**:
```markdown
## Architecture

### Component Structure

**Core Modules**:
- **PaymentProcessor** (Orchestrator)
  - Coordinates payment workflow
  - Handles transaction lifecycle
  - Delegates to specialized components

- **StripeClient** (Integration Adapter)
  - Wraps Stripe SDK
  - Applies retry policy to all API calls
  - Maps Stripe responses to domain models

- **ErrorMapper** (Error Translation)
  - Classifies errors (transient vs permanent)
  - Maps Stripe error codes to domain errors
  - Provides user-friendly error messages

- **RetryPolicy** (Resilience)
  - Configurable exponential backoff
  - Jitter to prevent thundering herd
  - Different policies for different error types

### Data Flow

```
User Request
  ‚Üì
PaymentProcessor.process()
  ‚Üì
StripeClient.createCharge() ‚Üí [RetryPolicy wraps call]
  ‚Üì
Stripe API
  ‚Üì (success)
Return Charge ID
  ‚Üì (failure - transient)
RetryPolicy ‚Üí exponential backoff ‚Üí retry
  ‚Üì (failure - permanent)
ErrorMapper ‚Üí domain error ‚Üí return to user
```

### Integration Points

**External Services**:
- Stripe API v2024-10 (payment processing)
  - Rate limit: 100 req/sec
  - Retry-after header respected
  - Webhook for async updates

**Database**:
- Transaction log (PostgreSQL)
  - Payment attempts (for audit)
  - Retry history (for analytics)
```

### Scope Section: WHAT is included

**Use Scope section for**:
- Features included in V1
- Features deferred to V2/V3
- Explicit exclusions
- Business constraints
- Performance requirements
- Platform limitations

**Example - Scope Section**:
```markdown
## Scope

### V1 - MVP (Current Release)

**In Scope**:
- Credit card payments (Visa, Mastercard, Amex)
- Basic retry for transient failures
- Error classification (permanent vs transient)
- Transaction logging for audit
- Synchronous payment flow

**Out of Scope** (defer to V2):
- Refund processing: Not needed for launch
- Subscription billing: Future business model
- Multi-currency support: US market only for V1
- Webhook processing: Will add with async flow
- Saved payment methods: V2 feature

**Constraints**:
- Stripe API v2024-10 required
- TypeScript 5.x (project standard)
- Response time < 3 seconds (includes retries)
- Must handle 100 payments/sec

**Platform Limitations**:
- Stripe test mode: 100 req/hour (not a production issue)
- No 3D Secure in V1 (adds complexity, defer to V2)
```

### Quick Decision Tree

```
Need to document decision
    ‚Üì
Does it explain HOW the system is structured?
    ‚Üì
YES ‚Üí Architecture section
  - Components
  - Data flow
  - Patterns
  - Integration points
    ‚Üì
NO ‚Üí Does it define WHAT is included/excluded?
    ‚Üì
YES ‚Üí Scope section
  - V1 features
  - V2 deferred
  - Constraints
  - Limitations
```

## DO/DON'T Guideline Examples

### Example 1: API Integration Pattern

```markdown
### DO: Use RetryPolicy for all external API calls

**Rationale**: External APIs have transient failures (network issues, rate limits, temporary unavailability). Retry logic with exponential backoff provides resilience without user-facing errors.

**Pattern**:
```typescript
// Good: Wrapped with retry policy
const result = await retryPolicy.execute(async () => {
  return await externalApi.call(params);
});
```

**Anti-pattern**:
```typescript
// Bad: Direct call without retry
const result = await externalApi.call(params); // Fails on transient errors
```

**When to Apply**:
- All calls to Stripe API
- All calls to third-party services
- Any network request that can fail transiently

**Exceptions**:
- Internal service calls (use different error handling)
- Database queries (use transaction retry instead)
```

### Example 2: Error Handling Constraint

```markdown
### DON'T: Retry permanent failures

**Rationale**: Permanent failures (invalid input, insufficient funds, authorization denied) will never succeed no matter how many times you retry. Retrying wastes resources and delays error feedback to users.

**Impact**:
- User waits longer for error message
- Unnecessary load on payment provider
- Risk of hitting rate limits
- Wasted compute resources

**How to Identify Permanent Failures**:
```typescript
// Use ErrorMapper to classify
const error = errorMapper.map(stripeError);

if (error.type === 'permanent') {
  // Don't retry - return error immediately
  throw error;
}

if (error.type === 'transient') {
  // Safe to retry
  await retryPolicy.execute(() => operation());
}
```

**Permanent Error Codes** (Stripe):
- `card_declined` - Card issuer rejected
- `insufficient_funds` - Not enough money
- `invalid_card` - Card details invalid
- `expired_card` - Card past expiration
```

### Example 3: Configuration Management

```markdown
### DO: Make retry policies configurable per environment

**Rationale**: Different environments have different performance characteristics and requirements. Test environments need faster retries for quick feedback. Production needs conservative retries to handle real failures.

**Configuration**:
```typescript
// config/retry.ts
export const retryConfig = {
  development: {
    maxRetries: 2,
    baseDelay: 100, // 100ms
    maxDelay: 1000, // 1 second
  },
  test: {
    maxRetries: 1,
    baseDelay: 10, // 10ms (fast tests)
    maxDelay: 100,
  },
  production: {
    maxRetries: 5,
    baseDelay: 1000, // 1 second
    maxDelay: 32000, // 32 seconds
  },
};
```

**Usage**:
```typescript
const policy = new RetryPolicy(retryConfig[process.env.NODE_ENV]);
```
```

### Example 4: Testing Pattern

```markdown
### DO: Test error scenarios with mocks

**Rationale**: External API failures are hard to reproduce in tests. Use mocks to simulate transient failures, permanent failures, and edge cases consistently.

**Pattern**:
```typescript
describe('PaymentProcessor with retries', () => {
  it('should retry on transient failure', async () => {
    // Mock: fail twice, then succeed
    const mockStripe = jest.fn()
      .mockRejectedValueOnce(new TransientError('rate_limit'))
      .mockRejectedValueOnce(new TransientError('network_error'))
      .mockResolvedValueOnce({ id: 'ch_123', status: 'succeeded' });

    const result = await processor.process(payment);

    expect(mockStripe).toHaveBeenCalledTimes(3); // 2 retries + success
    expect(result.status).toBe('succeeded');
  });

  it('should not retry on permanent failure', async () => {
    const mockStripe = jest.fn()
      .mockRejectedValueOnce(new PermanentError('card_declined'));

    await expect(processor.process(payment)).rejects.toThrow('card_declined');

    expect(mockStripe).toHaveBeenCalledTimes(1); // No retries
  });
});
```
```

## Technology Choice Documentation

### Template

```markdown
### [Component/Feature]: [Technology/Pattern]

**Decision**: Using [specific technology] for [purpose]

**Rationale**:
- [Reason 1: primary benefit]
- [Reason 2: fits project needs]
- [Reason 3: team familiarity / community support]

**Alternatives Considered**:
- [Alternative 1]: [Why not chosen - specific reason]
- [Alternative 2]: [Why not chosen - specific reason]

**Trade-offs**:
- ‚úÖ Pros:
  - [Advantage 1]
  - [Advantage 2]
- ‚ùå Cons:
  - [Disadvantage 1]
  - [Disadvantage 2]
- ‚öñÔ∏è Acceptable for V1: [Why trade-offs are acceptable]

**Migration Path** (if relevant):
- V1: [Current approach]
- V2: [Future improvement if needed]
```

### Example 1: Library Selection

```markdown
### Retry Logic: Custom Implementation

**Decision**: Building custom RetryPolicy class instead of using generic retry library

**Rationale**:
- Need Stripe-specific error classification (transient vs permanent)
- Stripe SDK v12 doesn't expose retry configuration
- Want exponential backoff with jitter (not all libraries support this)
- Need different policies for different error types

**Alternatives Considered**:
- **async-retry**: Generic library, but doesn't understand Stripe errors
  - Would need wrapper anyway for error classification
  - Adds dependency for limited benefit
- **Stripe SDK built-in**: Not customizable in v12
  - No access to retry timing
  - Can't distinguish transient from permanent
  - Would need to wait for v13 (6+ months)

**Trade-offs**:
- ‚úÖ Pros:
  - Full control over retry behavior
  - Stripe-aware error handling
  - Testable in isolation
  - Zero external dependencies
- ‚ùå Cons:
  - More code to maintain (~75 lines)
  - Need to implement backoff algorithm ourselves
  - Testing async timing can be tricky
- ‚öñÔ∏è Acceptable for V1:
  - Retry logic is isolated in single class
  - Well-tested with mocks (time-injection pattern)
  - Can swap for library later if needed (interface stays same)

**Migration Path**:
- V1: Custom RetryPolicy class
- V2: Monitor if Stripe SDK v13+ adds customizable retry
- V3: Consider migrating to SDK if it meets needs
```

### Example 2: Design Pattern

```markdown
### Error Handling: Strategy Pattern

**Decision**: Using Strategy pattern for error classification

**Rationale**:
- Different error types need different handling strategies
- Easy to add new error types without modifying existing code
- Testable strategies in isolation
- Clear separation of concerns

**Implementation**:
```typescript
interface ErrorStrategy {
  canHandle(error: StripeError): boolean;
  handle(error: StripeError): DomainError;
}

class TransientErrorStrategy implements ErrorStrategy {
  canHandle(error: StripeError): boolean {
    return ['rate_limit', 'network_error'].includes(error.code);
  }
  handle(error: StripeError): DomainError {
    return new TransientError(error.message, { retryable: true });
  }
}

class PermanentErrorStrategy implements ErrorStrategy {
  canHandle(error: StripeError): boolean {
    return ['card_declined', 'insufficient_funds'].includes(error.code);
  }
  handle(error: StripeError): DomainError {
    return new PermanentError(error.message, { retryable: false });
  }
}
```

**Alternatives Considered**:
- **Simple if/else chain**: Harder to test, grows complex with more error types
- **Error code mapping table**: Less flexible, can't handle complex logic

**Trade-offs**:
- ‚úÖ Pros: Extensible, testable, clean
- ‚ùå Cons: More classes (4 strategies + manager)
- ‚öñÔ∏è Acceptable: Error handling is core feature, worth the structure
```

## Keeping PLAN.md Focused

### What TO Include

**Architecture Section**:
- ‚úÖ High-level component structure
- ‚úÖ Data flow diagrams (text-based)
- ‚úÖ Integration points with external systems
- ‚úÖ Key design patterns being used
- ‚úÖ Technical constraints affecting design

**DO/DON'T Guidelines**:
- ‚úÖ Patterns discovered from real experience
- ‚úÖ Anti-patterns that caused problems
- ‚úÖ Platform-specific constraints
- ‚úÖ Examples with code snippets

**Technology Choices**:
- ‚úÖ Major library/framework selections
- ‚úÖ Design pattern choices
- ‚úÖ Rationale and trade-offs

**Scope**:
- ‚úÖ V1 feature list
- ‚úÖ Explicitly deferred features (V2/V3)
- ‚úÖ Performance requirements
- ‚úÖ Platform constraints

### What NOT to Include

**Avoid in Architecture**:
- ‚ùå Implementation details (specific line numbers)
- ‚ùå Completed work (belongs in task files)
- ‚ùå Bug fixes (belongs in iteration notes)
- ‚ùå Todos and action items (belongs in task files)
- ‚ùå Speculation about V2 features (keep focused on V1)

**Avoid in DO/DON'T**:
- ‚ùå Obvious best practices ("write tests", "use version control")
- ‚ùå One-off decisions that aren't patterns
- ‚ùå Personal preferences without rationale
- ‚ùå Guidelines without examples

**Avoid in Scope**:
- ‚ùå Detailed implementation plans (belongs in tasks)
- ‚ùå Tentative "maybe" features (defer or commit)
- ‚ùå Features without user value justification

### Red Flags (PLAN.md Getting Too Large)

**Warning signs**:
- PLAN.md over 300 lines (probably too detailed)
- Architecture section listing every file
- DO/DON'T with 20+ guidelines (too many patterns)
- Scope including V2/V3/V4 features

**How to slim down**:
1. Move implementation details to code comments
2. Move completed work to task files or ARCHIVE.md
3. Consolidate similar guidelines
4. Focus scope on V1 only, defer V2/V3 discussion

### Example: Too Detailed vs Just Right

**‚ùå Too Detailed** (avoid):
```markdown
## Architecture

### File Structure
- src/
  - payment/
    - PaymentProcessor.ts (145 lines)
      - process() method (lines 23-67)
      - validate() method (lines 69-89)
      - log() method (lines 91-103)
    - StripeClient.ts (213 lines)
      - createCharge() (lines 45-98)
      ...
```

**‚úÖ Just Right**:
```markdown
## Architecture

### Component Structure

**PaymentProcessor** (Orchestrator):
- Validates payment requests
- Coordinates Stripe API calls
- Logs transactions

**StripeClient** (Integration):
- Wraps Stripe SDK
- Applies retry policy
- Maps errors to domain model
```

## Summary

**Key Principles**:
1. Update PLAN.md during brainstorming (Type B subjects)
2. Distinguish Architecture (HOW) from Scope (WHAT)
3. DO/DON'T guidelines need rationale + examples
4. Document technology choices with trade-offs
5. Keep PLAN.md focused on V1, high-level decisions

**When in doubt**:
- Ask: "Is this a pattern others should follow?" ‚Üí DO/DON'T
- Ask: "Does this explain system structure?" ‚Üí Architecture
- Ask: "Does this define what's included?" ‚Üí Scope
- Ask: "Is this implementation detail?" ‚Üí Code comments / task file
SKILL_FLOW_ARCHITECT_PLAN_UPDATES_EOF
}

get_skill_flow_reviewer() {
  cat <<'SKILL_FLOW_REVIEWER_EOF'
---
name: flow-reviewer
description: Review and verify Flow framework plan consistency. Use when user says "review", "review the plan", "review this", "verify", "verify this", "check", "check the plan", "validate", "is this complete", "are we done", or wants to inspect plan status. Validates status markers match reality, checks for phantom tasks, ensures brainstorming complete before implementation, verifies task structure follows rules. Read-only inspection using Grep, Read, Glob tools only - never modifies files.
---

# Flow Reviewer

Help users verify plan consistency, validate status markers, and review implementation completeness in Flow framework projects. This Skill performs read-only inspections to ensure the plan matches reality.

## When to Use This Skill

Activate when the user wants verification:
- "Review the plan"
- "Verify the status"
- "Check if we're done"
- "Is the implementation complete?"
- "Validate the structure"
- "Are there any issues?"
- "Check for inconsistencies"
- "Verify all tasks are tracked"

## Review Philosophy

**Read-Only Inspection**: This Skill observes and reports, never modifies.

**What We Check**:
- Status markers match actual state
- No phantom tasks (DASHBOARD promises what doesn't exist)
- Brainstorming complete before implementation starts
- Task structure follows Flow rules
- Action items are all checked off when complete
- File references are valid

**Tools Available**: `Read`, `Grep`, `Glob` (read-only tools only)

## Review Checklist

### 1. Status Marker Consistency

**Check**: Do status markers reflect actual state?

**How to verify**:
```bash
# Find all IN PROGRESS items
grep -r "üöß IN PROGRESS" .flow/

# Find all COMPLETE items
grep -r "‚úÖ COMPLETE" .flow/

# Find all PENDING items
grep -r "‚è≥ PENDING" .flow/
```

**Common issues**:
- Task marked üöß IN PROGRESS but all iterations are ‚úÖ COMPLETE
- Iteration marked ‚è≥ PENDING but has implementation section
- Multiple items marked üöß IN PROGRESS (should only be one active)

**Example problem**:
```markdown
### üöß Iteration 2: Error Handling

**Status**: ‚úÖ COMPLETE (2025-10-30)  ‚Üê MISMATCH!
```

**Report**:
```
‚ùå Status Marker Mismatch
- Iteration 2 header shows üöß IN PROGRESS
- Implementation section shows ‚úÖ COMPLETE
- Action: Update header to match implementation status
```

### 2. Phantom Task Detection

**Check**: Does every task listed in DASHBOARD.md have a corresponding file?

**How to verify**:
```bash
# List all tasks mentioned in DASHBOARD
grep "Task [0-9]" .flow/DASHBOARD.md

# Check if task files exist
ls .flow/phase-*/task-*.md
```

**Common issues**:
- DASHBOARD lists "Task 5" but `.flow/phase-2/task-5.md` doesn't exist
- Task file references non-existent iterations

**Example problem**:
```markdown
DASHBOARD.md:
- üöß **Task 3**: API Integration (2/4 iterations)

But: .flow/phase-2/task-3.md doesn't exist
```

**Report**:
```
‚ùå Phantom Task Detected
- DASHBOARD.md references Task 3: API Integration
- File .flow/phase-2/task-3.md does not exist
- Action: Create task file or remove from DASHBOARD
```

### 3. Implementation Gate Verification

**Check**: Is implementation starting before brainstorming is complete?

**How to verify**:
```bash
# Check if iteration has brainstorming
grep -A 20 "## Brainstorming" task-file.md

# Check brainstorming status
grep "Brainstorming.*Status.*COMPLETE" task-file.md

# Check if implementation started
grep "## Implementation" task-file.md
```

**Gate Rule**: If iteration has brainstorming, it must be ‚úÖ COMPLETE before implementation starts.

**Example problem**:
```markdown
## Brainstorming
**Status**: üöß IN PROGRESS

## Implementation
**Status**: üöß IN PROGRESS  ‚Üê GATE VIOLATION!
```

**Report**:
```
‚ùå Implementation Gate Violation
- Iteration 2 has brainstorming IN PROGRESS
- Implementation section already started
- Action: Complete brainstorming before implementing
```

### 4. Task Structure Validation

**Check**: Does task follow the Golden Rule (Standalone XOR Iterations)?

**Golden Rule**: Tasks have EITHER:
- Direct action items (standalone task)
- OR iterations with action items in each iteration
- NEVER both

**How to verify**:
```bash
# Check if task has direct action items
grep -A 5 "## Action Items" task-file.md

# Check if task has iterations
grep "### " task-file.md | grep "Iteration"
```

**Example problem**:
```markdown
# Task 3: API Integration

## Action Items
- [ ] Create StripeClient
- [ ] Add error handling

## Iterations

### Iteration 1: Setup
...
```

**Report**:
```
‚ùå Task Structure Violation (Golden Rule)
- Task 3 has both direct action items AND iterations
- Golden Rule: Tasks must be EITHER standalone OR have iterations, never both
- Action: Move action items into iterations or remove iterations
```

### 5. Action Item Completion Check

**Check**: Are all action items checked off when iteration is marked complete?

**How to verify**:
```bash
# Find iteration marked COMPLETE
grep -B 2 "Status.*COMPLETE" task-file.md

# Check for unchecked action items in that iteration
grep -A 30 "### ‚úÖ Iteration" task-file.md | grep "\[ \]"
```

**Example problem**:
```markdown
### ‚úÖ Iteration 2: Error Handling
**Status**: ‚úÖ COMPLETE

#### Action Items
- [x] Create ErrorMapper
- [ ] Add tests  ‚Üê UNCHECKED!
- [x] Integrate with client
```

**Report**:
```
‚ùå Incomplete Action Items
- Iteration 2 marked ‚úÖ COMPLETE
- But action item "Add tests" is unchecked
- Action: Either complete the item or mark iteration as IN PROGRESS
```

### 6. File Reference Validation

**Check**: Do all file references point to existing files?

**How to verify**:
```bash
# Find file references in task files
grep -r "\`.*\.ts\`" .flow/ | grep -v "example"

# Check if referenced files exist
ls path/to/file.ts
```

**Example problem**:
```markdown
**Files Modified**:
- src/payment/StripeClient.ts
- src/payment/DoesNotExist.ts  ‚Üê FILE DOESN'T EXIST!
```

**Report**:
```
‚ö†Ô∏è Invalid File Reference
- Iteration 2 references src/payment/DoesNotExist.ts
- File does not exist in repository
- Action: Verify file path or remove invalid reference
```

## Status Markers Reference

### Valid Status Markers

**Task/Iteration Status**:
- ‚úÖ `COMPLETE` - Work finished and verified
- üöß `IN PROGRESS` - Currently working on this
- ‚è≥ `PENDING` - Not started yet
- üé® `READY` - Ready to implement (brainstorming complete)
- ‚ùå `CANCELLED` - Work abandoned
- üîÆ `DEFERRED` - Moved to future version

**Phase Status**:
- ‚úÖ `COMPLETE` - All tasks in phase done
- üöß `IN PROGRESS` - Currently working in this phase
- ‚è≥ `PENDING` - Phase not started

### Status Marker Lifecycle

**Iteration Lifecycle**:
```
‚è≥ PENDING
  ‚Üì (brainstorming started)
üöß IN PROGRESS (brainstorming)
  ‚Üì (brainstorming complete, ready to implement)
üé® READY
  ‚Üì (/flow-implement-start)
üöß IN PROGRESS (implementing)
  ‚Üì (/flow-implement-complete)
‚úÖ COMPLETE
```

**Common Mistakes**:
- ‚ùå Skipping üé® READY (going from brainstorming to implementation without marking ready)
- ‚ùå Multiple items marked üöß IN PROGRESS (should only be one active)
- ‚ùå Marking ‚úÖ COMPLETE with unchecked action items
- ‚ùå Using ‚è≥ PENDING after implementation started

## Common Review Patterns

### Pattern 1: Full Plan Review

**When**: User asks "review the entire plan"

**Steps**:
1. Read DASHBOARD.md to understand structure
2. For each phase:
   - Verify phase status matches task statuses
   - Check all tasks listed have files
3. For each task:
   - Verify task status matches iteration statuses
   - Check structure (standalone XOR iterations)
4. For each iteration:
   - Verify status marker consistency
   - Check action items if marked complete
5. Report all findings

**Output format**:
```markdown
## Plan Review Results

**Summary**: 15 items checked, 2 issues found

### ‚úÖ Passing Checks (13)
- All phase statuses consistent
- No phantom tasks detected
- Task structure valid
- ...

### ‚ùå Issues Found (2)

#### Issue 1: Status Marker Mismatch
- **Location**: Phase 2, Task 3, Iteration 2
- **Problem**: Header shows üöß but implementation shows ‚úÖ
- **Action**: Update header to ‚úÖ COMPLETE

#### Issue 2: Unchecked Action Items
- **Location**: Phase 2, Task 4, Iteration 1
- **Problem**: Iteration marked complete but 1 action item unchecked
- **Action**: Complete action item or mark iteration IN PROGRESS
```

### Pattern 2: Task-Specific Review

**When**: User asks "review Task 3"

**Steps**:
1. Read task file
2. Check task status consistency
3. Verify structure (standalone XOR iterations)
4. For each iteration:
   - Status marker consistency
   - Action item completion
   - Implementation gate (brainstorming before implementation)
5. Report findings

### Pattern 3: Status Audit

**When**: User asks "check all status markers"

**Steps**:
1. Grep for all status markers
2. For each marker:
   - Verify it's in valid lifecycle position
   - Check consistency with surrounding content
3. Check for multiple IN PROGRESS items (should be max 1)
4. Report findings

## Review Commands

### Check for Phantom Tasks

```bash
# List tasks from DASHBOARD
grep -E "Task [0-9]" .flow/DASHBOARD.md

# List actual task files
ls .flow/phase-*/task-*.md

# Compare (manual check)
```

### Find Incomplete Work

```bash
# Find all IN PROGRESS items
grep -r "üöß IN PROGRESS" .flow/

# Find unchecked action items
grep -r "\[ \]" .flow/phase-*/*.md
```

### Verify Implementation Gates

```bash
# Find iterations with brainstorming
grep -r "## Brainstorming" .flow/phase-*/

# Check if brainstorming is complete
grep -A 2 "## Brainstorming" .flow/phase-*/*.md | grep "Status"
```

### Validate Task Structure

```bash
# Check for direct action items in tasks
grep -A 5 "## Action Items" .flow/phase-*/task-*.md

# Check for iterations
grep "### " .flow/phase-*/task-*.md | grep -i iteration
```

## Interaction with Other Flow Skills

**Planning Stage** (flow-planner Skill):
- Planner creates structure
- Reviewer validates structure

**Implementation Stage** (flow-implementer Skill):
- Implementer executes work
- Reviewer verifies completion

**Architecture Stage** (flow-architect Skill):
- Architect documents decisions
- Reviewer checks references are valid

**Review Stage** (This Skill):
- Inspect plan consistency ‚Üê YOU ARE HERE
- Report findings, don't fix ‚Üê YOU ARE HERE

## Reporting Guidelines

### Report Format

**Use this structure for review findings**:

```markdown
## Review Results

**Scope**: [What was reviewed]
**Date**: [Review date]
**Status**: [‚úÖ All Clear | ‚ö†Ô∏è Issues Found]

### Summary
- X checks performed
- Y issues found
- Z warnings

### ‚úÖ Passing Checks
- [List what's working correctly]

### ‚ùå Issues Found
- [List problems discovered]

### ‚ö†Ô∏è Warnings
- [List potential concerns]

### üìã Recommendations
- [Suggested actions to fix issues]
```

### Severity Levels

**‚ùå Critical**: Must fix before proceeding
- Phantom tasks (DASHBOARD promises don't exist)
- Implementation started before brainstorming complete
- Task structure violates Golden Rule

**‚ö†Ô∏è Warning**: Should fix soon
- Status marker inconsistency (cosmetic)
- Unchecked action items with work complete
- Minor file reference issues

**‚ÑπÔ∏è Info**: Nice to fix
- Formatting inconsistencies
- Missing optional documentation

## References

- **Status Markers**: DEVELOPMENT_FRAMEWORK.md lines 1872-1968
- **Task Structure Rules**: DEVELOPMENT_FRAMEWORK.md lines 238-566
- **Implementation Gates**: DEVELOPMENT_FRAMEWORK.md lines 1798-1836
- **Slash Command**: `/flow-verify-plan` (automated verification)

## Key Reminders

**Before reviewing**:
- [ ] Understand what user wants reviewed (full plan, specific task, status audit)
- [ ] Use read-only tools (Grep, Read, Glob)
- [ ] Never modify files during review

**During review**:
- [ ] Check status marker consistency
- [ ] Verify no phantom tasks
- [ ] Validate implementation gates
- [ ] Check task structure (Golden Rule)
- [ ] Verify action item completion

**After review**:
- [ ] Report findings in structured format
- [ ] Prioritize issues by severity
- [ ] Suggest specific actions to fix
- [ ] Don't modify files - let user or other Skills handle fixes
SKILL_FLOW_REVIEWER_EOF
}

get_skill_flow_reviewer_verify() {
  cat <<'SKILL_FLOW_REVIEWER_VERIFY_EOF'
# Verification Scripts

Quick reference for common Flow framework verification tasks using bash commands.

> **Note**: This is a Level 3 resource for the flow-reviewer Skill. See [SKILL.md](SKILL.md) for complete review guidance.

## Status Consistency Checks

### Find All IN PROGRESS Items
```bash
grep -r "üöß IN PROGRESS" .flow/
```

### Count Active Work Items
```bash
grep -r "üöß IN PROGRESS" .flow/ | wc -l
# Should be 1 (only one active item at a time)
```

### Find Mismatched Status Markers
```bash
# Find headers marked IN PROGRESS
grep -B 2 "### üöß" .flow/phase-*/*.md

# Check if their implementation sections match
grep -A 5 "Status.*COMPLETE" .flow/phase-*/*.md | grep "### üöß"
```

## Incomplete Work Detection

### Find Unchecked Action Items
```bash
grep -r "\[ \]" .flow/phase-*/*.md
```

### Find Iterations Marked Complete with Unchecked Items
```bash
for file in .flow/phase-*/task-*.md; do
  if grep -q "### ‚úÖ.*Iteration" "$file"; then
    echo "Checking $file..."
    grep -A 50 "### ‚úÖ.*Iteration" "$file" | grep "\[ \]" && echo "‚ùå Found unchecked items in complete iteration"
  fi
done
```

## Phantom Task Detection

### List Tasks from DASHBOARD
```bash
grep -E "Task [0-9]:" .flow/DASHBOARD.md | sed 's/.*Task /Task /'
```

### List Actual Task Files
```bash
ls .flow/phase-*/task-*.md | xargs -n 1 basename
```

### Compare (Find Missing Files)
```bash
# Extract task numbers from DASHBOARD
dashboard_tasks=$(grep -oE "Task [0-9]+" .flow/DASHBOARD.md | sort -u)

# Check each one exists
for task in $dashboard_tasks; do
  task_num=$(echo $task | grep -oE "[0-9]+")
  if ! ls .flow/phase-*/task-${task_num}.md 2>/dev/null | grep -q .; then
    echo "‚ùå Phantom task: $task (file missing)"
  fi
done
```

## Implementation Gate Verification

### Check Brainstorming Status Before Implementation
```bash
for file in .flow/phase-*/task-*.md; do
  if grep -q "## Brainstorming" "$file"; then
    brainstorm_status=$(grep -A 2 "## Brainstorming" "$file" | grep "Status" | head -1)
    impl_status=$(grep -A 2 "## Implementation" "$file" | grep "Status" | head -1 2>/dev/null)

    if echo "$impl_status" | grep -q "IN PROGRESS" && ! echo "$brainstorm_status" | grep -q "COMPLETE"; then
      echo "‚ùå Gate violation in $file"
      echo "   Brainstorming: $brainstorm_status"
      echo "   Implementation: $impl_status"
    fi
  fi
done
```

## Task Structure Validation

### Find Tasks with Both Standalone Items AND Iterations
```bash
for file in .flow/phase-*/task-*.md; do
  has_items=$(grep -c "^## Action Items" "$file" 2>/dev/null || echo 0)
  has_iterations=$(grep -c "### .*Iteration" "$file" 2>/dev/null || echo 0)

  if [ "$has_items" -gt 0 ] && [ "$has_iterations" -gt 0 ]; then
    echo "‚ùå Golden Rule violation: $file has both standalone items AND iterations"
  fi
done
```

## Common Verification Workflows

### Full Plan Health Check
```bash
#!/bin/bash
echo "=== Flow Plan Health Check ==="
echo

echo "1. Checking for multiple IN PROGRESS items..."
in_progress=$(grep -r "üöß IN PROGRESS" .flow/ | wc -l)
if [ "$in_progress" -gt 1 ]; then
  echo "‚ö†Ô∏è  Found $in_progress IN PROGRESS items (should be max 1)"
  grep -r "üöß IN PROGRESS" .flow/
else
  echo "‚úÖ Only $in_progress IN PROGRESS item"
fi
echo

echo "2. Checking for phantom tasks..."
# (phantom task check from above)
echo

echo "3. Checking for unchecked items in complete iterations..."
# (unchecked items check from above)
echo

echo "=== Health Check Complete ==="
```

### Quick Status Audit
```bash
echo "Task Status Summary:"
echo "==================="
echo "COMPLETE: $(grep -r "‚úÖ COMPLETE" .flow/ | wc -l)"
echo "IN PROGRESS: $(grep -r "üöß IN PROGRESS" .flow/ | wc -l)"
echo "PENDING: $(grep -r "‚è≥ PENDING" .flow/ | wc -l)"
echo "READY: $(grep -r "üé® READY" .flow/ | wc -l)"
```

## Issue Reporting Template

When verification finds issues, report them like this:

```markdown
## Verification Results

**Date**: 2025-10-30
**Scope**: Full plan review

### Issues Found

#### ‚ùå Issue 1: Multiple IN PROGRESS Items
- **Details**: Found 3 items marked üöß IN PROGRESS
- **Locations**:
  - Phase 2, Task 3, Iteration 2
  - Phase 2, Task 4, Iteration 1
  - Phase 3, Task 1, Iteration 1
- **Action**: Mark 2 as complete or pending, keep only 1 active

#### ‚ö†Ô∏è Warning: Unchecked Action Items
- **Details**: Iteration marked complete but has unchecked items
- **Location**: Phase 2, Task 3, Iteration 2
- **Action**: Check off items or mark iteration IN PROGRESS
```
SKILL_FLOW_REVIEWER_VERIFY_EOF
}

get_skill_flow_documenter() {
  cat <<'SKILL_FLOW_DOCUMENTER_EOF'
---
name: flow-documenter
description: Document findings and maintain task notes in Flow framework. Use when user says "document", "document this", "document finding", "add notes", "add this to notes", "write this down", "summarize", "summarize this", "generate changelog", "create changelog", or wants to capture discoveries. Helps update task Notes sections, create summaries with /flow-summarize, and keep documentation synchronized with work. Focuses on concise, actionable documentation.
---

# Flow Documenter

Help users document discoveries, maintain task notes, and generate summaries in Flow framework projects. This Skill ensures documentation stays synchronized with actual work and follows Flow patterns.

## When to Use This Skill

Activate when the user wants to document:
- "Document this finding"
- "Add notes to the task"
- "Write this down"
- "Summarize what we did"
- "Generate a changelog"
- "Update the task notes"
- "Record this discovery"

## Documentation Philosophy

**Keep it Actionable**: Documentation should help future work, not just record history.

**Where to Document**:
- **Task ## Notes**: Discoveries, decisions, patterns found during work
- **Implementation Notes**: What was built, why, challenges solved
- **DASHBOARD.md**: Phase/task completion summaries
- **PLAN.md**: Architecture decisions, DO/DON'T guidelines (via flow-architect)

**Slash Commands**:
- `/flow-summarize`: Generate project summary from all phases/tasks/iterations

## Task Notes Section

### What Goes in ## Notes

**Discoveries**:
- Patterns found during implementation
- Unexpected behaviors discovered
- Design insights that emerged
- Technical constraints learned

**Decisions**:
- Choices made and why
- Trade-offs accepted
- Approaches tried and rejected

**References**:
- Related tasks or iterations
- External documentation consulted
- Framework patterns followed

### Task Notes Template

```markdown
## Notes

**Key Discoveries**:
- [Discovery 1]: [What was found and why it matters]
- [Discovery 2]: [What was found and why it matters]

**Design Decisions**:
- [Decision 1]: Chose [approach] because [rationale]
- [Decision 2]: Deferred [feature] to V2 due to [constraint]

**Challenges & Solutions**:
- **Challenge**: [Problem encountered]
  - **Solution**: [How it was solved]
  - **Impact**: [Effect on design/implementation]

**References**:
- Related to [Task X, Iteration Y]
- Pattern from DEVELOPMENT_FRAMEWORK.md lines [X-Y]
- External: [URL or doc reference]
```

### Example Task Notes

```markdown
## Notes

**Key Discoveries**:
- **Stripe SDK Limitation**: v12 doesn't expose retry configuration hooks
  - Led to custom RetryPolicy implementation
  - See PLAN.md Technology Choices section for detailed rationale
- **Error Classification Pattern**: Transient vs permanent errors need different handling
  - Implemented ErrorMapper with strategy pattern
  - Allows easy extension for new error types

**Design Decisions**:
- Chose exponential backoff over linear for retry logic
  - Rationale: Better for API rate limiting (Stripe recommendation)
  - Added jitter to prevent thundering herd problem
- Deferred refund processing to V2
  - Rationale: Not needed for initial launch, adds complexity
  - Can be added later without refactoring payment flow

**Challenges & Solutions**:
- **Challenge**: Testing retry timing is difficult (delays slow down test suite)
  - **Solution**: Made clock injectable for testing (dependency injection)
  - **Impact**: Tests run fast, retry logic still thoroughly tested
- **Challenge**: Stripe test API has rate limit (100 req/hour)
  - **Solution**: Used mocks for most tests, real API for critical paths
  - **Impact**: Test suite completes in < 10 seconds

**References**:
- Related to Task 3, Iteration 2 (Error Handling)
- Pattern from DEVELOPMENT_FRAMEWORK.md lines 1798-1836 (Implementation Pattern)
- Stripe API Docs: https://stripe.com/docs/api/errors
```

## Bug Documentation

### When to Document Bugs

**In Task Notes** (if discovered during implementation):
- Bugs found in existing code (not your changes)
- Workarounds applied
- Issues deferred to future tasks

**Use Bug Documentation Template**:

```markdown
**Bugs Discovered**:

### Bug 1: [Short Description]

**Location**: `path/to/file.ts:lines X-Y`

**Problem**:
```[language]
// Current buggy code
```

**Impact**: [What breaks or degrades]

**Action Taken**: [Fixed immediately | Documented for future | Workaround applied]

**Fix** (if applied):
```[language]
// Corrected code
```

**Recommendation**: [Priority level and next steps]
```

### Example Bug Documentation

```markdown
**Bugs Discovered**:

### Bug 1: Race Condition in PaymentService

**Location**: `src/services/PaymentService.ts:145-152`

**Problem**:
```typescript
async processPayment(amount: number) {
  const status = await this.checkStatus();
  // Race condition: status can change between check and update
  await this.updatePayment(status);
}
```

**Impact**: Could cause duplicate charges in concurrent requests

**Action Taken**: Documented here, created separate task for fix (not in scope of current iteration)

**Recommendation**: High priority fix for next sprint - use database transactions
```

## Changelog Generation

### Using /flow-summarize

The `/flow-summarize` command generates summaries from PLAN.md structure:

```bash
/flow-summarize
```

**Outputs**:
- All phases with completion status
- All tasks with iteration counts
- High-level summary of what was accomplished

### Manual Changelog Format

For release notes or detailed changelogs:

```markdown
## Changelog - [Version/Date]

### Added
- [Feature 1]: [Brief description]
- [Feature 2]: [Brief description]

### Changed
- [Change 1]: [What changed and why]
- [Change 2]: [What changed and why]

### Fixed
- [Bug 1]: [What was fixed]
- [Bug 2]: [What was fixed]

### Deprecated
- [Old feature]: [Replacement or removal plan]
```

### Example Changelog

```markdown
## Changelog - Payment Integration V1

### Added
- Payment processing via Stripe API
  - Credit card charges (Visa, Mastercard, Amex)
  - Retry logic with exponential backoff
  - Error classification (transient vs permanent)
- Transaction logging for audit trail
- Error handling with user-friendly messages

### Changed
- Refactored PaymentService to use dependency injection
  - Improves testability
  - Allows easy swapping of payment providers
- Updated error responses to include retry guidance

### Fixed
- Race condition in payment status checks
  - Now uses database transactions
  - Prevents duplicate charge scenarios

### Deferred to V2
- Refund processing
- Subscription billing
- Multi-currency support
```

## DASHBOARD Updates

### When to Update DASHBOARD

**Task completion**:
- Mark task ‚úÖ COMPLETE
- Update completion percentages
- Update "üìç Current Work" section

**Phase completion**:
- Mark phase ‚úÖ COMPLETE
- Add phase summary
- Update overall project status

### DASHBOARD Update Pattern

```markdown
## üìç Current Work

- **Phase**: [Current Phase Name](phase-X/)
- **Task**: [Current Task Name](phase-X/task-Y.md)
- **Status**: [Brief status summary]
- **Next**: [What to do next]

---

## üìä Progress Overview

### Phase X: [Phase Name] ‚úÖ COMPLETE

**Summary**: [1-2 sentence summary of what was accomplished]

**Key Deliverables**:
- [Deliverable 1]
- [Deliverable 2]

**Tasks**:
- ‚úÖ **Task 1**: [Name] (X/Y iterations)
- ‚úÖ **Task 2**: [Name] (X/Y iterations)
```

## Pre-Implementation Task Documentation

### Pre-Task Notes Pattern

When documenting completed pre-implementation tasks:

```markdown
#### Pre-Implementation Tasks

##### ‚úÖ Pre-Task 1: [Name]

**Completed**: 2025-01-15

**Why Blocking**: [Explanation of why this had to be done first]

**Changes Made**:
- [Change 1]: [Description]
- [Change 2]: [Description]
- [Change 3]: [Description]

**Files Modified**:
- `path/to/file1.ts` (+X lines, -Y lines)
- `path/to/file2.ts` (+X lines, -Y lines)

**Impact on Main Iteration**:
[How this pre-task enables or simplifies the main work]
```

## Discovery Documentation

### When You Discover Something Important

**Document immediately** in task notes if it's:
- A pattern that should be followed consistently
- A constraint that affects future work
- An insight that changes understanding
- A decision that future developers need to know

### Discovery Template

```markdown
**Discovery: [Short Title]**

**Context**: [When/how this was discovered]

**What We Learned**:
[Detailed explanation of the discovery]

**Implications**:
- [Impact 1]: [How this affects current or future work]
- [Impact 2]: [How this affects current or future work]

**Action Taken**:
- [Action 1]: [What was done in response]
- [Action 2]: [What was done in response]
```

### Example Discovery

```markdown
**Discovery: Stripe Webhook Signatures Expire After 5 Minutes**

**Context**: While implementing webhook endpoint, discovered signature validation fails for delayed webhooks

**What We Learned**:
Stripe webhook signatures include a timestamp and expire after 5 minutes to prevent replay attacks. If webhook processing is delayed (queue backlog, system downtime), validation will fail even for legitimate webhooks.

**Implications**:
- **Current Work**: Need to capture raw webhook payload before validation for debugging
- **Future Work**: V2 webhook processing must handle signature expiration gracefully
- **Monitoring**: Add alerts for webhook validation failures

**Action Taken**:
- Documented in PLAN.md Scope section (V1 assumes < 5min processing)
- Added pre-validation logging of raw payload
- Created V2 task for robust webhook handling
```

## Interaction with Other Flow Skills

**Planning Stage** (flow-planner Skill):
- Planner creates structure
- Documenter captures decisions made

**Architecture Stage** (flow-architect Skill):
- Architect updates PLAN.md
- Documenter adds task-specific notes

**Implementation Stage** (flow-implementer Skill):
- Implementer executes work
- Documenter records discoveries ‚Üê YOU ARE HERE

**Review Stage** (flow-reviewer Skill):
- Reviewer validates consistency
- Documenter updates based on findings

## References

- **Task Structure**: DEVELOPMENT_FRAMEWORK.md lines 238-566
- **Implementation Pattern**: DEVELOPMENT_FRAMEWORK.md lines 1798-1836
- **Status Markers**: DEVELOPMENT_FRAMEWORK.md lines 1872-1968
- **Slash Command**: `/flow-summarize` (generate summaries)

## Key Reminders

**Before documenting**:
- [ ] Identify correct location (Task Notes, DASHBOARD, PLAN.md)
- [ ] Keep it concise and actionable
- [ ] Focus on "why" not just "what"

**During documentation**:
- [ ] Use templates for consistency
- [ ] Link to related tasks/iterations
- [ ] Include impact/implications

**After documenting**:
- [ ] Verify documentation is findable (proper section, clear title)
- [ ] Check if DASHBOARD needs updating
- [ ] Consider if discovery should go in PLAN.md (via flow-architect)
SKILL_FLOW_DOCUMENTER_EOF
}

update_claude_md() {
  local force="$1"
  local claude_md="$(pwd)/CLAUDE.md"

  # Flow framework notice content (without header for insertion)
  local flow_content='- **This project leverages '\''flow framework'\''**: This project uses the flow framework for project management. Follow flow conventions for tasks, iterations, and brainstorming. Try to use the skills agents where possible for the best results. Alternatively, use the slash commands to interact with the flow system.'

  echo -e "${CYAN}üìù Checking CLAUDE.md...${NC}"

  # Check if CLAUDE.md exists
  if [ ! -f "$claude_md" ]; then
    # CLAUDE.md doesn't exist - skip
    echo -e "${YELLOW}‚è≠Ô∏è  No CLAUDE.md found - skipping${NC}"
    return 0
  fi

  # CLAUDE.md exists - check if Flow notice is present
  if grep -qi "flow framework" "$claude_md"; then
    # Flow framework mention found
    if [ "$force" = true ]; then
      # Force mode: update/replace the section
      echo -e "${YELLOW}üîÑ Updating Flow framework section (--force mode)...${NC}"

      # Strategy: Remove old flow section, then add new one
      local temp_file="${claude_md}.tmp"
      local in_flow_section=0

      # First pass: remove old flow section
      while IFS= read -r line; do
        if [[ "$line" =~ ^##\ Important\ rules\ and\ guidelines ]]; then
          in_flow_section=1
          continue
        fi

        if [ $in_flow_section -eq 1 ] && [[ "$line" =~ ^## ]]; then
          in_flow_section=0
        fi

        if [[ "$line" =~ flow\ framework ]] && [ $in_flow_section -eq 1 ]; then
          continue
        fi

        if [ $in_flow_section -eq 0 ]; then
          echo "$line"
        fi
      done < "$claude_md" > "$temp_file"

      # Second pass: add new flow section after title + boilerplate
      local final_file="${claude_md}.final"
      local inserted=0
      local after_title=0

      while IFS= read -r line; do
        echo "$line"

        # Track when we pass the title
        if [[ "$line" =~ ^#\ CLAUDE\.md ]]; then
          after_title=1
        fi

        # Insert after the boilerplate line (the "This file provides..." line)
        if [ $after_title -eq 1 ] && [ $inserted -eq 0 ]; then
          if [[ "$line" =~ This\ file\ provides\ guidance ]]; then
            echo ""
            echo "## Important rules and guidelines"
            echo "${flow_content}"
            echo ""
            inserted=1
          fi
        fi

        # Fallback: if we hit another ## section and still haven't inserted, insert before it
        if [[ "$line" =~ ^## ]] && [ $inserted -eq 0 ] && [ $after_title -eq 0 ]; then
          echo "## Important rules and guidelines"
          echo "${flow_content}"
          echo ""
          inserted=1
          echo "$line"
          continue
        fi
      done < "$temp_file" > "$final_file"

      # If never inserted (no title, no ## sections), add at top
      if [ $inserted -eq 0 ]; then
        {
          echo "## Important rules and guidelines"
          echo "${flow_content}"
          echo ""
          cat "$temp_file"
        } > "$final_file"
      fi

      mv "$final_file" "$claude_md"
      rm -f "$temp_file"
      echo -e "${GREEN}‚úÖ Updated Flow framework section in CLAUDE.md${NC}"
    else
      # Not force mode - skip
      echo -e "${GREEN}‚úÖ CLAUDE.md already has Flow framework notice (use --force to update)${NC}"
    fi
    return 0
  fi

  # Flow notice not found - add it
  echo -e "${BLUE}Adding Flow framework notice to CLAUDE.md...${NC}"

  local temp_file="${claude_md}.tmp"
  local inserted=0
  local after_title=0
  local prev_line=""

  # Check if file has "# CLAUDE.md" title
  if grep -q "^# CLAUDE.md" "$claude_md"; then
    # Has title - insert after title + boilerplate
    while IFS= read -r line; do
      echo "$line"

      # Track when we pass the title
      if [[ "$line" =~ ^#\ CLAUDE\.md ]]; then
        after_title=1
      fi

      # Insert after the boilerplate line (the "This file provides..." line)
      if [ $after_title -eq 1 ] && [ $inserted -eq 0 ]; then
        if [[ "$line" =~ This\ file\ provides\ guidance ]]; then
          echo ""
          echo "## Important rules and guidelines"
          echo "${flow_content}"
          echo ""
          inserted=1
        fi
      fi

      prev_line="$line"
    done < "$claude_md" > "$temp_file"
  else
    # No title - insert at very top
    {
      echo "## Important rules and guidelines"
      echo "${flow_content}"
      echo ""
      cat "$claude_md"
    } > "$temp_file"
  fi

  mv "$temp_file" "$claude_md"
  echo -e "${GREEN}‚úÖ Added Flow framework notice to CLAUDE.md${NC}"
}

deploy_commands() {
  local target_dir="$1"
  local force="$2"
  local success_count=0

  # If force mode, clean up deprecated commands first
  if [ "$force" = true ]; then
    echo -e "${CYAN}üßπ Cleaning deprecated commands...${NC}"
    for deprecated_cmd in "${DEPRECATED_COMMANDS[@]}"; do
      local deprecated_file="$target_dir/${deprecated_cmd}.md"
      if [ -f "$deprecated_file" ]; then
        rm -f "$deprecated_file"
        echo -e "${YELLOW}üóëÔ∏è  Removed deprecated: ${deprecated_cmd}.md${NC}"
      fi
    done
    echo ""
  fi

  for cmd in "${COMMANDS[@]}"; do
    local cmd_file="$target_dir/${cmd}.md"

    # If force mode, delete existing file first to ensure clean write
    if [ "$force" = true ] && [ -f "$cmd_file" ]; then
      rm -f "$cmd_file"
    fi

    [ -f "$cmd_file" ] && [ "$force" = false ] && { echo -e "${YELLOW}‚è≠Ô∏è  Skip ${cmd}.md${NC}"; continue; }

    local content=$(extract_command "$cmd")
    [ -z "$content" ] && { echo -e "${RED}‚ùå Failed ${cmd}${NC}"; continue; }

    echo "$content" > "$cmd_file" && { echo -e "${GREEN}‚úÖ ${cmd}.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå ${cmd}.md${NC}"
  done

  echo "$success_count"
}

deploy_framework() {
  local target_dir="$1"
  local force="$2"
  local framework_dir="$target_dir/framework"
  local framework_file="$framework_dir/DEVELOPMENT_FRAMEWORK.md"
  local examples_dir="$framework_dir/examples"

  # Create framework directory
  mkdir -p "$framework_dir" || { echo -e "${RED}‚ùå mkdir framework/${NC}"; return 1; }

  # If force mode, delete existing files first to ensure clean write
  if [ "$force" = true ]; then
    [ -f "$framework_file" ] && rm -f "$framework_file"
    [ -d "$examples_dir" ] && rm -rf "$examples_dir"
  fi

  # Deploy framework guide
  if [ -f "$framework_file" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip framework/DEVELOPMENT_FRAMEWORK.md${NC}"
  else
    get_framework_content > "$framework_file" && echo -e "${GREEN}‚úÖ framework/DEVELOPMENT_FRAMEWORK.md${NC}" || { echo -e "${RED}‚ùå Framework${NC}"; return 1; }
  fi

  # Deploy examples
  if [ -d "$examples_dir" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip framework/examples/${NC}"
  else
    # Create examples directory structure
    mkdir -p "$examples_dir/phase-1" || { echo -e "${RED}‚ùå framework/examples/phase-1${NC}"; return 1; }
    mkdir -p "$examples_dir/phase-2" || { echo -e "${RED}‚ùå framework/examples/phase-2${NC}"; return 1; }

    # Deploy example files
    get_example_dashboard > "$examples_dir/DASHBOARD.md" && echo -e "${GREEN}‚úÖ framework/examples/DASHBOARD.md${NC}" || { echo -e "${RED}‚ùå framework/examples/DASHBOARD.md${NC}"; return 1; }
    get_example_plan > "$examples_dir/PLAN.md" && echo -e "${GREEN}‚úÖ framework/examples/PLAN.md${NC}" || { echo -e "${RED}‚ùå framework/examples/PLAN.md${NC}"; return 1; }
    get_example_task_standalone > "$examples_dir/phase-1/task-1.md" && echo -e "${GREEN}‚úÖ framework/examples/phase-1/task-1.md${NC}" || { echo -e "${RED}‚ùå framework/examples/phase-1/task-1.md${NC}"; return 1; }
    get_example_task_iterations > "$examples_dir/phase-2/task-3.md" && echo -e "${GREEN}‚úÖ framework/examples/phase-2/task-3.md${NC}" || { echo -e "${RED}‚ùå framework/examples/phase-2/task-3.md${NC}"; return 1; }
  fi

  # Deploy Skills Guide
  local skills_guide="$framework_dir/skills/SKILLS_GUIDE.md"
  mkdir -p "$framework_dir/skills" || { echo -e "${RED}‚ùå mkdir framework/skills${NC}"; return 1; }

  if [ -f "$skills_guide" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip framework/skills/SKILLS_GUIDE.md${NC}"
  else
    get_skills_guide > "$skills_guide" && echo -e "${GREEN}‚úÖ framework/skills/SKILLS_GUIDE.md${NC}" || { echo -e "${RED}‚ùå Skills Guide${NC}"; return 1; }
  fi

  return 0
}

deploy_skills() {
  local target_dir="$1"
  local force="$2"
  local success_count=0

  # target_dir already points to .claude/skills, no need to add /skills again
  mkdir -p "$target_dir" || { echo -e "${RED}‚ùå mkdir skills/${NC}"; return 1; }

  # Deploy flow-navigator Skill
  local navigator_dir="$target_dir/flow-navigator"
  mkdir -p "$navigator_dir" || { echo -e "${RED}‚ùå mkdir flow-navigator${NC}"; return 1; }

  if [ "$force" = true ] && [ -f "$navigator_dir/SKILL.md" ]; then
    rm -f "$navigator_dir/SKILL.md"
  fi

  if [ -f "$navigator_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-navigator/SKILL.md${NC}"
  else
    get_skill_flow_navigator > "$navigator_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-navigator/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-navigator/SKILL.md${NC}"
  fi

  # Deploy flow-planner Skill
  local planner_dir="$target_dir/flow-planner"
  mkdir -p "$planner_dir" || { echo -e "${RED}‚ùå mkdir flow-planner${NC}"; return 1; }

  if [ "$force" = true ]; then
    [ -f "$planner_dir/SKILL.md" ] && rm -f "$planner_dir/SKILL.md"
    [ -f "$planner_dir/TEMPLATES.md" ] && rm -f "$planner_dir/TEMPLATES.md"
  fi

  if [ -f "$planner_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-planner/SKILL.md${NC}"
  else
    get_skill_flow_planner > "$planner_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-planner/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-planner/SKILL.md${NC}"
  fi

  if [ -f "$planner_dir/TEMPLATES.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-planner/TEMPLATES.md${NC}"
  else
    get_skill_flow_planner_templates > "$planner_dir/TEMPLATES.md" && { echo -e "${GREEN}‚úÖ flow-planner/TEMPLATES.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-planner/TEMPLATES.md${NC}"
  fi

  # Deploy flow-implementer Skill
  local implementer_dir="$target_dir/flow-implementer"
  mkdir -p "$implementer_dir" || { echo -e "${RED}‚ùå mkdir flow-implementer${NC}"; return 1; }

  if [ "$force" = true ]; then
    [ -f "$implementer_dir/SKILL.md" ] && rm -f "$implementer_dir/SKILL.md"
    [ -f "$implementer_dir/PATTERNS.md" ] && rm -f "$implementer_dir/PATTERNS.md"
    [ -f "$implementer_dir/VERIFICATION.md" ] && rm -f "$implementer_dir/VERIFICATION.md"
  fi

  if [ -f "$implementer_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-implementer/SKILL.md${NC}"
  else
    get_skill_flow_implementer > "$implementer_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-implementer/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-implementer/SKILL.md${NC}"
  fi

  if [ -f "$implementer_dir/PATTERNS.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-implementer/PATTERNS.md${NC}"
  else
    get_skill_flow_implementer_patterns > "$implementer_dir/PATTERNS.md" && { echo -e "${GREEN}‚úÖ flow-implementer/PATTERNS.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-implementer/PATTERNS.md${NC}"
  fi

  if [ -f "$implementer_dir/VERIFICATION.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-implementer/VERIFICATION.md${NC}"
  else
    get_skill_flow_implementer_verification > "$implementer_dir/VERIFICATION.md" && { echo -e "${GREEN}‚úÖ flow-implementer/VERIFICATION.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-implementer/VERIFICATION.md${NC}"
  fi

  # Deploy flow-architect Skill
  local architect_dir="$target_dir/flow-architect"
  mkdir -p "$architect_dir" || { echo -e "${RED}‚ùå mkdir flow-architect${NC}"; return 1; }

  if [ "$force" = true ]; then
    [ -f "$architect_dir/SKILL.md" ] && rm -f "$architect_dir/SKILL.md"
    [ -f "$architect_dir/PLAN_UPDATES.md" ] && rm -f "$architect_dir/PLAN_UPDATES.md"
  fi

  if [ -f "$architect_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-architect/SKILL.md${NC}"
  else
    get_skill_flow_architect > "$architect_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-architect/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-architect/SKILL.md${NC}"
  fi

  if [ -f "$architect_dir/PLAN_UPDATES.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-architect/PLAN_UPDATES.md${NC}"
  else
    get_skill_flow_architect_plan_updates > "$architect_dir/PLAN_UPDATES.md" && { echo -e "${GREEN}‚úÖ flow-architect/PLAN_UPDATES.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-architect/PLAN_UPDATES.md${NC}"
  fi

  # Deploy flow-reviewer Skill
  local reviewer_dir="$target_dir/flow-reviewer"
  mkdir -p "$reviewer_dir" || { echo -e "${RED}‚ùå mkdir flow-reviewer${NC}"; return 1; }

  if [ "$force" = true ]; then
    [ -f "$reviewer_dir/SKILL.md" ] && rm -f "$reviewer_dir/SKILL.md"
    [ -f "$reviewer_dir/VERIFY.md" ] && rm -f "$reviewer_dir/VERIFY.md"
  fi

  if [ -f "$reviewer_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-reviewer/SKILL.md${NC}"
  else
    get_skill_flow_reviewer > "$reviewer_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-reviewer/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-reviewer/SKILL.md${NC}"
  fi

  if [ -f "$reviewer_dir/VERIFY.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-reviewer/VERIFY.md${NC}"
  else
    get_skill_flow_reviewer_verify > "$reviewer_dir/VERIFY.md" && { echo -e "${GREEN}‚úÖ flow-reviewer/VERIFY.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-reviewer/VERIFY.md${NC}"
  fi

  # Deploy flow-documenter Skill
  local documenter_dir="$target_dir/flow-documenter"
  mkdir -p "$documenter_dir" || { echo -e "${RED}‚ùå mkdir flow-documenter${NC}"; return 1; }

  if [ "$force" = true ] && [ -f "$documenter_dir/SKILL.md" ]; then
    rm -f "$documenter_dir/SKILL.md"
  fi

  if [ -f "$documenter_dir/SKILL.md" ] && [ "$force" = false ]; then
    echo -e "${YELLOW}‚è≠Ô∏è  Skip flow-documenter/SKILL.md${NC}"
  else
    get_skill_flow_documenter > "$documenter_dir/SKILL.md" && { echo -e "${GREEN}‚úÖ flow-documenter/SKILL.md${NC}"; ((success_count++)); } || echo -e "${RED}‚ùå flow-documenter/SKILL.md${NC}"
  fi

  echo "$success_count"
  return 0
}

validate() {
  local commands_dir="$1"
  local flow_dir="$2"
  local skills_dir="$3"
  local valid=true

  echo -e "\n${CYAN}üîç Validating...${NC}\n"

  # Check framework
  [ ! -f "$flow_dir/framework/DEVELOPMENT_FRAMEWORK.md" ] && { echo -e "${RED}‚ùå Framework missing${NC}"; valid=false; } || echo -e "${GREEN}‚úÖ Framework${NC}"

  # Check examples
  [ ! -d "$flow_dir/framework/examples" ] && { echo -e "${RED}‚ùå Examples missing${NC}"; valid=false; } || echo -e "${GREEN}‚úÖ Examples (4 files)${NC}"

  # Check commands
  local count=0
  for cmd in "${COMMANDS[@]}"; do
    [ -f "$commands_dir/${cmd}.md" ] && ((count++))
  done

  echo -e "${GREEN}‚úÖ Commands: $count/${#COMMANDS[@]}${NC}"
  [ "$count" -eq 0 ] && { echo -e "${RED}‚ùå No commands${NC}"; valid=false; }

  # Check Skills
  local skills_count=0
  [ -f "$skills_dir/flow-navigator/SKILL.md" ] && ((skills_count++))
  [ -f "$skills_dir/flow-planner/SKILL.md" ] && ((skills_count++))
  [ -f "$skills_dir/flow-implementer/SKILL.md" ] && ((skills_count++))
  [ -f "$skills_dir/flow-architect/SKILL.md" ] && ((skills_count++))
  [ -f "$skills_dir/flow-reviewer/SKILL.md" ] && ((skills_count++))
  [ -f "$skills_dir/flow-documenter/SKILL.md" ] && ((skills_count++))

  if [ "$skills_count" -eq 6 ]; then
    echo -e "${GREEN}‚úÖ Skills: $skills_count/6 (with supporting files)${NC}"
  elif [ "$skills_count" -gt 0 ]; then
    echo -e "${YELLOW}‚ö†Ô∏è  Skills: $skills_count/6 (partial)${NC}"
  else
    echo -e "${RED}‚ùå No Skills${NC}"
    valid=false
  fi

  [ "$valid" = true ]
}

main() {
  while [[ $# -gt 0 ]]; do
    case $1 in
      --force|-f) FORCE=true; shift;;
      --version|-v) print_version; exit 0;;
      --help|-h) print_help; exit 0;;
      *) echo -e "${RED}Unknown: $1${NC}"; print_help; exit 1;;
    esac
  done

  echo -e "\n${BLUE}üöÄ Flow Framework v$FLOW_VERSION${NC}\n"
  echo -e "Target Project: ${BLUE}$(pwd)${NC}"
  echo -e "Force: $([ "$FORCE" = true ] && echo "${GREEN}Yes${NC}" || echo "${RED}No${NC}")"
  echo -e "Mode: ${CYAN}Self-contained${NC}\n"

  local commands_dir="$(pwd)/.claude/commands"
  local skills_dir="$(pwd)/.claude/skills"
  local flow_dir="$(pwd)/.flow"

  # Create directories
  mkdir -p "$commands_dir" || { echo -e "${RED}‚ùå mkdir .claude/commands failed${NC}"; exit 1; }
  mkdir -p "$skills_dir" || { echo -e "${RED}‚ùå mkdir .claude/skills failed${NC}"; exit 1; }
  mkdir -p "$flow_dir" || { echo -e "${RED}‚ùå mkdir .flow failed${NC}"; exit 1; }
  echo -e "${BLUE}üìÅ Created directories${NC}\n"

  # Deploy slash commands
  echo -e "${BLUE}üì¶ Installing slash commands...${NC}\n"
  local count=$(deploy_commands "$commands_dir" "$FORCE")

  # Deploy framework docs
  echo -e "\n${BLUE}üìö Installing framework documentation...${NC}\n"
  deploy_framework "$flow_dir" "$FORCE"

  # Deploy Skills
  echo -e "\n${BLUE}üéØ Installing Agent Skills...${NC}\n"
  local skills_count=$(deploy_skills "$skills_dir" "$FORCE")

  # Update CLAUDE.md
  echo -e "\n${BLUE}üìù Updating project CLAUDE.md...${NC}\n"
  update_claude_md "$FORCE"

  # Validate
  if validate "$commands_dir" "$flow_dir" "$skills_dir"; then
    echo ""
    echo "=================================================="
    echo -e "${GREEN}‚úÖ Flow Framework Installed!${NC}\n"
    echo -e "${CYAN}üìÇ Structure:${NC}"
    echo "   .claude/commands/       (${#COMMANDS[@]} slash commands)"
    echo "   .claude/skills/         (6 Agent Skills)"
    echo "   .flow/                  (your workspace)"
    echo "     ‚îî‚îÄ‚îÄ framework/        (AI reference files)"
    echo "         ‚îú‚îÄ‚îÄ DEVELOPMENT_FRAMEWORK.md"
    echo "         ‚îú‚îÄ‚îÄ skills/SKILLS_GUIDE.md"
    echo "         ‚îî‚îÄ‚îÄ examples/"
    echo "             ‚îú‚îÄ‚îÄ DASHBOARD.md"
    echo "             ‚îú‚îÄ‚îÄ PLAN.md"
    echo "             ‚îú‚îÄ‚îÄ phase-1/task-1.md"
    echo "             ‚îî‚îÄ‚îÄ phase-2/task-3.md"
    echo ""
    echo -e "${CYAN}üéØ Agent Skills Installed:${NC}"
    echo "   flow-navigator       - Dashboard-first navigation"
    echo "   flow-planner         - Planning new features/iterations"
    echo "   flow-implementer     - Implementation workflow guidance"
    echo "   flow-architect       - Architecture decisions & DO/DON'Ts"
    echo "   flow-reviewer        - Plan/code verification (read-only)"
    echo "   flow-documenter      - Task notes & discoveries"
    echo ""
    echo -e "${CYAN}üöÄ Next Steps:${NC}"
    echo "   1. Restart Claude Code (if running)"
    echo "   2. Run: /flow-blueprint <your-feature-name>"
    echo "   3. Read: .flow/framework/DEVELOPMENT_FRAMEWORK.md"
    echo "   4. Examples: .flow/framework/examples/"
    echo "   5. Skills Guide: .flow/framework/skills/SKILLS_GUIDE.md"
    echo ""
    echo "üí° Share this script - it's self-contained!"
    echo "=================================================="
    echo ""
    exit 0
  else
    echo ""
    echo -e "${YELLOW}‚ö†Ô∏è  Deployment completed with warnings${NC}"
    echo ""
    exit 1
  fi
}

main "$@"
